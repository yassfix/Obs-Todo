<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Task Dashboard (Daily Progress)</title>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-light: #a29bfe;
            --secondary: #00b894;
            --background: #000000;
            --card: #000000ec;
            --text: #dfe6e9;
            --accent: #fd79a8;
            --warning: #fdcb6e;
            --danger: #e17055;
        }
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}
        body{background-color:var(--background);color:var(--text);padding:15px;max-width:900px;margin:0 auto}
        .dashboard{display:flex;flex-direction:column;gap:20px}
        .header{text-align:center;margin-bottom:5px}
        .header h1{color:var(--primary);font-size:1.8rem;margin-bottom:3px}
        .header p{color:var(--primary-light);font-size:0.95rem}
        .focus-section{background-color:var(--card);border-radius:10px;padding:20px;box-shadow:0 4px 15px rgba(0,0,0,.2);position:relative;overflow:hidden;}
        .section-header{display:flex;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary)}
        .section-header h2{font-size:1.4rem;margin-left:10px}
        .tabs-container{display:flex;border-bottom:2px solid var(--primary);margin-bottom:15px}
        .tab{flex:1;text-align:center;padding:10px 0;cursor:pointer;transition:all 0.3s;border-bottom:2px solid transparent}
        .tab.active{color:var(--primary);border-bottom-color:var(--primary);font-weight:bold}
        .tab:hover:not(.active){background-color:rgba(255,255,255,0.05)}
        .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;color:white;font-weight:bold;background-color:var(--accent)}
        .task-list{list-style-type:none;margin-bottom:20px;position:relative;}
        .task-item{display:flex;align-items:center;padding:12px 10px;margin-bottom:8px;background-color:rgba(255,255,255,.05);border-radius:8px;transition:all .3s;cursor:grab;}
        .task-item:hover{background-color:rgba(255,255,255,.1)}
        .task-item.dragging{opacity:0.5;background-color:rgba(255,255,255,.2);cursor:grabbing;}
        .task-checkbox{margin-right:12px;width:18px;height:18px;accent-color:var(--secondary);cursor:pointer}
        .task-text{flex-grow:1;font-size:1rem;margin-right:15px;word-wrap:break-word;overflow-wrap:break-word;white-space:normal}
        .task-input{flex-grow:1;padding:5px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:1rem;margin-right:15px}
        .task-meta{display:flex;gap:10px;align-items:center;flex-shrink:0}
        .task-time{font-size:.8rem;color:var(--primary-light);white-space:nowrap;min-width: 70px;text-align: center;}
        .timer-controls{display:flex;gap:5px;}
        .timer-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .timer-btn:hover{background-color:rgba(255,255,255,0.1);}
        .timer-btn:disabled{color:rgba(255,255,255,0.3);cursor:not-allowed;}
        .timer-btn.running{color:var(--secondary);}
        .completed{text-decoration:line-through;opacity:.7}
        .progress-container{margin-top:15px}
        .progress-header{display:flex;justify-content:space-between;margin-bottom:6px;font-size:.9rem}
        .progress-bar{height:8px;background-color:rgba(255,255,255,.1);border-radius:4px;overflow:hidden}
        .progress-fill{height:100%;background-color:var(--secondary);border-radius:4px;transition:width .5s}
        .stats{display:flex;justify-content:space-between;margin-top:10px;font-size:.85rem;color:var(--primary-light)}
        .time-stats{display:flex;justify-content:space-between;margin-top:15px;padding:10px;background-color:rgba(255,255,255,.05);border-radius:8px;}
        .time-stat{display:flex;flex-direction:column;align-items:center;flex:1;}
        .time-stat-value{font-size:1.2rem;font-weight:bold;color:var(--secondary);}
        .time-stat-label{font-size:0.75rem;color:var(--primary-light);margin-top:5px;}
        .footer{text-align:center;margin-top:15px;color:var(--primary-light);font-size:.85rem}
        .new-task{display:flex;margin-top:15px;gap:8px}
        .new-task-input{flex-grow:1;padding:10px 12px;border:none;border-radius:6px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:.9rem}
        .new-task-button{padding:10px 15px;border:none;border-radius:6px;background-color:var(--primary);color:white;font-weight:bold;font-size:.9rem;cursor:pointer;white-space:nowrap}
        .empty-state{text-align:center;padding:20px;color:var(--primary-light);font-size:.9rem}
        .drag-handle{cursor:grab;margin-right:10px;color:var(--primary-light);}
        .task-actions{display:flex;gap:5px;margin-left:5px;}
        .action-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;display:flex;align-items:center;justify-content:center;}
        .action-btn:hover{background-color:rgba(255,255,255,0.1);}
        .completion-date{font-size:0.7rem;color:var(--primary-light);margin-top:2px;font-style:italic;}
        .task-content{flex-grow:1;display:flex;flex-direction:column;margin-right:15px;overflow:hidden;min-width:0} /* Added min-width:0 for proper flexbox wrapping */
        
        /* Keyword/Tag Styles - UPDATED */
        .keywords-container{display:none;flex-wrap:wrap;gap:5px;margin-bottom:8px;align-items:center;}
        .keywords-container.visible{display:flex;}
        .keyword-tag{display:inline-flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:2px 8px;border-radius:12px;font-size:0.7rem;cursor:pointer;margin:2px;}
        .keyword-tag:hover{background-color:var(--primary);}
        .keyword-tag.selected{background-color:var(--secondary);}
        .keyword-remove{background:none;border:none;color:var(--background);cursor:pointer;margin-left:4px;font-size:0.7rem;font-weight:bold;padding:0;width:14px;height:14px;display:flex;align-items:center;justify-content:center;}
        .add-keyword-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .add-keyword-btn:hover{background-color:rgba(255,255,255,0.1);}
        .keyword-input-container{display:flex;gap:5px;margin-top:5px;}
        .keyword-input{flex-grow:1;padding:4px 8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:0.8rem;}
        .add-keyword-confirm{background-color:var(--secondary);color:white;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:0.8rem;}
        
        /* Keyword Management Styles */
        .keyword-management{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;justify-content:center;align-items:center;}
        .keyword-management.visible{display:flex;}
        .keyword-management-content{background-color:var(--card);padding:20px;border-radius:10px;width:90%;max-width:500px;max-height:80vh;overflow-y:auto;}
        .keyword-management-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:1px solid var(--primary);padding-bottom:10px;}
        .keyword-management-header h3{color:var(--primary);}
        .close-keyword-management{background:none;border:none;color:var(--primary-light);font-size:1.5rem;cursor:pointer;}
        .keyword-list{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:15px;}
        .keyword-item{display:flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:5px 10px;border-radius:15px;}
        .keyword-item input{background:none;border:none;color:var(--background);font-size:0.8rem;width:100px;}
        .keyword-item input:focus{outline:none;}
        .keyword-item-actions{display:flex;gap:5px;margin-left:5px;}
        .keyword-item-btn{background:none;border:none;color:var(--background);cursor:pointer;font-size:0.8rem;padding:2px 5px;}
        .new-keyword-input{display:flex;gap:8px;margin-top:10px;}
        .new-keyword-input input{flex-grow:1;padding:8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);}
        .new-keyword-input button{padding:8px 15px;border:none;border-radius:4px;background-color:var(--primary);color:white;cursor:pointer;}
        .show-keywords-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.7rem;padding:2px 5px;border-radius:3px;margin-bottom:5px;}
        .show-keywords-btn:hover{background-color:rgba(255,255,255,0.1);}
        .manage-keywords-btn{background-color:var(--primary);color:white;border:none;padding:8px 15px;border-radius:6px;cursor:pointer;margin-top:10px;font-size:0.9rem;}
        
        /* NEW STYLES FOR THE LAYOUT CHANGES */
        .time-stats-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            position: relative;
            z-index: 2;
        }
        .timers-section {
            display: flex;
            gap: 15px;
            flex: 1;
        }
        .progress-section {
            width: 50%;
        }
        .progress-section .progress-container {
            margin-top: 0;
        }
        .progress-section .progress-bar {
            width: 100%;
        }
        
        /* NEW STYLES FOR DROPDOWN FUNCTIONALITY */
        .task-main-content {
            display: flex;
            align-items: center;
            width: 100%;
        }
        .dropdown-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            transition: transform 0.3s;
        }
        .dropdown-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .dropdown-btn.rotated {
            transform: rotate(180deg);
        }
        .task-details {
            display: none;
            width: 100%;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 8px;
        }
        .task-details.visible {
            display: flex;
            flex-direction: column;
        }
        .task-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        /* DISPLAY MODE SECTION */
        .display-mode-section {
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
            margin-top: 20px;
        }

        .display-mode-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .mode-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .mode-option {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .mode-option input[type="radio"] {
            margin-right: 8px;
            accent-color: var(--primary);
        }

        .mode-option label {
            cursor: pointer;
            font-size: 0.9rem;
        }

        .mode-description {
            font-size: 0.85rem;
            color: var(--primary-light);
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 6px;
        }

        /* CONVEYOR BELT ANIMATION STYLES */
        .conveyor-container {
            position: relative;
            overflow: hidden;
            height: auto;
            min-height: 100px;
        }

        .conveyor-track {
            position: relative;
            transition: transform 0.1s linear;
        }

        .conveyor-task {
            transition: opacity 0.5s ease;
            margin-bottom: 8px;
        }

        .task-entering {
            opacity: 0;
            transform: translateY(20px);
        }

        .task-visible {
            opacity: 1;
            transform: translateY(0);
        }

        .task-exiting {
            opacity: 0;
            transform: translateY(-20px);
        }

        /* NEW STYLES FOR LIMITED VISIBLE AREA AND SCROLLING */
        .tasks-container {
            max-height: 272px; /* 4 tasks * 68px (approx task height with margin) */
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-light) rgba(255,255,255,0.1);
            margin-bottom: 15px;
            border-radius: 8px;
            padding-right: 5px;
        }

        .tasks-container::-webkit-scrollbar {
            width: 8px;
        }

        .tasks-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-light);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary);
        }

        /* For mobile responsiveness */
        @media (max-width:600px){
            .task-meta{flex-direction:column;gap:3px;align-items:flex-end}
            .task-time{font-size:.7rem}
            .time-stats-container {
                flex-direction: column;
                gap: 15px;
            }
            .timers-section {
                width: 100%;
            }
            .progress-section {
                width: 100%;
            }
            .task-details-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .mode-selector {
                flex-direction: column;
                gap: 10px;
            }
        }
        /* Add to CSS section for smooth bottom entrance */
        .conveyor-reset {
            animation: slideFromBottom 0.5s ease-out;
        }

        @keyframes slideFromBottom {
            0% {
                transform: translateY(100%);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>Obs Todo</h1>
        </div>
        <div class="focus-section">
            <div class="tabs-container">
                <div class="tab active" data-tab="active">Current Focus</div>
                <div class="tab" data-tab="completed">Completed Tasks</div>
            </div>
            
            <div class="time-stats-container">
                <div class="timers-section">
                    <div class="time-stat">
                        <div class="time-stat-value" id="daily-total">00:00:00</div>
                        <div class="time-stat-label">Today</div>
                    </div>
                    <div class="time-stat">
                        <div class="time-stat-value" id="lifetime-total">00:00:00</div>
                        <div class="time-stat-label">Lifetime</div>
                    </div>
                </div>
                <div class="progress-section">
                    <div class="progress-container">
                        <div class="progress-header">
                            <span>Today's Progress</span>
                            <span id="progress-percent">0%</span>
                        </div>
                        <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
                    </div>
                </div>
            </div>
            
            <div class="tasks-container" id="tasks-container">
                <div class="conveyor-container" id="conveyor-container">
                    <div class="conveyor-track" id="conveyor-track">
                        <ul class="task-list" id="task-list"></ul>
                    </div>
                </div>
            </div>
            <div class="new-task">
                <input type="text" class="new-task-input" placeholder="Add a new task..." id="new-task-input">
                <button class="new-task-button" id="add-task-btn">Add</button>
            </div>
            <button class="manage-keywords-btn" id="manage-keywords-btn">Manage Keywords</button>
            <div class="stats">
                <span id="completed-count">0 of 0 completed today</span>
                <span id="remaining-count">0 tasks remaining</span>
            </div>
            
            <div class="display-mode-section">
                <h3>Display Mode</h3>
                <div class="mode-selector">
                    <div class="mode-option">
                        <input type="radio" id="mode-static" name="display-mode" value="static" >
                        <label for="mode-static">Static Todo List</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="mode-loop-incompleted" name="display-mode" value="loop-incompleted" checked>
                        <label for="mode-loop-incompleted">Loop Incompleted Tasks</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="mode-loop-all" name="display-mode" value="loop-all">
                        <label for="mode-loop-all">Loop All Tasks</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="mode-rotate-incompleted" name="display-mode" value="rotate-incompleted">
                        <label for="mode-rotate-incompleted">Rotate Incompleted Tasks (Keep Top)</label>
                    </div>
                </div>
                <div class="mode-description" id="mode-description">
                    Current tasks are displayed in a static list.
                </div>
            </div>
        </div>
        <div class="footer">
            <p id="timestamp">Updated: --</p>
        </div>
    </div>

    <div class="keyword-management" id="keyword-management">
        <div class="keyword-management-content">
            <div class="keyword-management-header">
                <h3>Manage Keywords</h3>
                <button class="close-keyword-management" id="close-keyword-management">&times;</button>
            </div>
            <div class="keyword-list" id="keyword-list-manager"></div>
            <div class="new-keyword-input">
                <input type="text" id="new-keyword-input" placeholder="Add a new keyword...">
                <button id="add-new-keyword-btn">Add</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDEEMO9MlcNsb_QLIRTDJM4rXqxGZuYJps",
            authDomain: "obs-todo-68da2.firebaseapp.com",
            databaseURL: "https://obs-todo-68da2-default-rtdb.firebaseio.com",
            projectId: "obs-todo-68da2",
            storageBucket: "obs-todo-68da2.firebasestorage.app",
            messagingSenderId: "594250582895",
            appId: "1:594250582895:web:62414c9f759b99904cb69a",
            measurementId: "G-N94MD8GRJQ"
        };

        let useFirebase = false;
        try {
            if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                firebase.initializeApp(firebaseConfig);
                useFirebase = true;
            }
        } catch (err) {
            console.warn('Firebase init failed, falling back to localStorage:', err);
            useFirebase = false;
        }

        // DOM elements
        const taskListEl = document.getElementById('task-list');
        const tasksContainer = document.getElementById('tasks-container');
        const conveyorContainer = document.getElementById('conveyor-container');
        const conveyorTrack = document.getElementById('conveyor-track');
        const inputEl = document.getElementById('new-task-input');
        const addBtn = document.getElementById('add-task-btn');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const completedCount = document.getElementById('completed-count');
        const remainingCount = document.getElementById('remaining-count');
        const timestampEl = document.getElementById('timestamp');
        const tabs = document.querySelectorAll('.tab');
        const dailyTotalEl = document.getElementById('daily-total');
        const lifetimeTotalEl = document.getElementById('lifetime-total');
        const manageKeywordsBtn = document.getElementById('manage-keywords-btn');
        const keywordManagement = document.getElementById('keyword-management');
        const closeKeywordManagement = document.getElementById('close-keyword-management');
        const keywordListManager = document.getElementById('keyword-list-manager');
        const newKeywordInput = document.getElementById('new-keyword-input');
        const addNewKeywordBtn = document.getElementById('add-new-keyword-btn');

        // App state
        let tasks = {};
        let dbRef = null;
        let currentTab = 'active';
        let timerIntervals = {};
        let dragSrcEl = null;
        let editingTaskId = null;
        let editingKeywordIndex = null;
        let expandedTasks = {}; // Track which tasks are expanded

        // Display mode variables
        let displayMode = 'static';
        let conveyorInterval = null;
        let conveyorTasks = [];
        let conveyorPosition = 0;
        let isConveyorPaused = false;
        let conveyorSpeed = 50; // pixels per second

        // Default keywords
        let keywords = ['Work', 'Personal', 'Urgent', 'Important', 'Shopping'];

        // Utility function to check if a date is today
        function isToday(date) {
            const today = new Date();
            const checkDate = new Date(date);
            return checkDate.getDate() === today.getDate() &&
                   checkDate.getMonth() === today.getMonth() &&
                   checkDate.getFullYear() === today.getFullYear();
        }

        // ADDED: Function to trigger OBS refresh
        function triggerObsRefresh() {
            // This is a common technique to force OBS Browser Source to refresh
            // by appending a changing hash to the URL without navigating away.
            const now = new Date().getTime();
            window.location.hash = `refresh=${now}`;
        }
        
        // Format date for display
        function formatDate(date) {
            const d = new Date(date);
            const now = new Date();
            const diffTime = now.getTime() - d.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return `Today at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else if (diffDays === 1) {
                return `Yesterday at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else {
                return `${d.toLocaleDateString()} at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            }
        }

        // Timer functions
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function startTimer(taskId) {
            if (timerIntervals[taskId]) return; // Timer already running
            
            const task = tasks[taskId];
            if (!task.timerStartTime) {
                task.timerStartTime = Date.now();
            }
            
            timerIntervals[taskId] = setInterval(() => {
                const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                task.timeSpent = (task.timeSpent || 0) + elapsed;
                task.timerStartTime = Date.now();
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
                updateTimeStats();
            }, 1000);
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        function pauseTimer(taskId) {
            if (timerIntervals[taskId]) {
                clearInterval(timerIntervals[taskId]);
                delete timerIntervals[taskId];
                
                const task = tasks[taskId];
                if (task.timerStartTime) {
                    const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                    task.timeSpent = (task.timeSpent || 0) + elapsed;
                    task.timerStartTime = null;
                }
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
                updateTimeStats();
            }
        }

        function stopTimer(taskId) {
            pauseTimer(taskId);
            
            const task = tasks[taskId];
            task.timerStartTime = null;
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        // Time statistics functions
        function calculateDailyTotal() {
            const today = new Date().toDateString();
            let totalSeconds = 0;
            
            Object.values(tasks).forEach(task => {
                // Check if task was completed today or has time spent today
                if (task.completedAt) {
                    const completedDate = new Date(task.completedAt).toDateString();
                    if (completedDate === today) {
                        totalSeconds += task.timeSpent || 0;
                    }
                } else if (task.timeSpent && task.lastUpdated) {
                    const lastUpdatedDate = new Date(task.lastUpdated).toDateString();
                    if (lastUpdatedDate === today) {
                        totalSeconds += task.timeSpent || 0;
                    }
                }
            });
            
            return totalSeconds;
        }

        function calculateLifetimeTotal() {
            let totalSeconds = 0;
            
            Object.values(tasks).forEach(task => {
                if (task.completed) {
                    totalSeconds += task.timeSpent || 0;
                }
            });
            
            return totalSeconds;
        }

        function updateTimeStats() {
            const dailyTotalSeconds = calculateDailyTotal();
            const lifetimeTotalSeconds = calculateLifetimeTotal();
            dailyTotalEl.textContent = formatTime(dailyTotalSeconds);
            lifetimeTotalEl.textContent = formatTime(lifetimeTotalSeconds);
        }

        // Drag and drop functions
        function handleDragStart(e) {
            if (currentTab !== 'active') return;
            
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (dragSrcEl !== this) {
                const taskItems = Array.from(taskListEl.querySelectorAll('.task-item'));
                const srcIndex = taskItems.indexOf(dragSrcEl);
                const destIndex = taskItems.indexOf(this);
                
                if (srcIndex !== -1 && destIndex !== -1) {
                    // Reorder tasks in the data structure
                    const taskKeys = Object.keys(tasks).filter(key => !tasks[key].completed);
                    const movedKey = taskKeys[srcIndex];
                    
                    // Remove from current position
                    taskKeys.splice(srcIndex, 1);
                    // Insert at new position
                    taskKeys.splice(destIndex, 0, movedKey);
                    
                    // Update order in tasks object
                    taskKeys.forEach((key, index) => {
                        tasks[key].order = index;
                    });
                    
                    // Save and re-render
                    saveAllTasks();
                    renderTasks();
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('over', 'dragging');
            });
        }

        // Task removal function
        function removeTask(taskId) {
            if (confirm('Are you sure you want to remove this task?')) {
                if (useFirebase) {
                    firebase.database().ref('tasks/' + taskId).remove();
                } else {
                    delete tasks[taskId];
                    saveAllTasks();
                    renderTasks();
                }
            }
        }

        // Task editing functions
        function startEditingTask(taskId) {
            editingTaskId = taskId;
            renderTasks();
            
            // Focus the input field after a short delay
            setTimeout(() => {
                const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveTaskEdit(taskId) {
            const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
            if (input) {
                const newText = input.value.trim();
                if (newText) {
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ text: newText });
                    } else {
                        tasks[taskId].text = newText;
                        saveAllTasks();
                    }
                }
            }
            editingTaskId = null;
            renderTasks();
        }

        function cancelTaskEdit() {
            editingTaskId = null;
            renderTasks();
        }

        // Keyword functions
        function toggleKeyword(taskId, keyword) {
            const task = tasks[taskId];
            if (!task.keywords) {
                task.keywords = [];
            }
            
            const index = task.keywords.indexOf(keyword);
            if (index === -1) {
                // Add keyword
                task.keywords.push(keyword);
            } else {
                // Remove keyword
                task.keywords.splice(index, 1);
            }
            
            if (useFirebase) {
                firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
            } else {
                saveAllTasks();
            }
            renderTasks();
        }

        function removeKeywordFromTask(taskId, keyword) {
            const task = tasks[taskId];
            if (task.keywords) {
                const index = task.keywords.indexOf(keyword);
                if (index !== -1) {
                    task.keywords.splice(index, 1);
                    
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                    renderTasks();
                }
            }
        }

        function addNewKeyword(taskId, keywordInputId) {
            const input = document.getElementById(keywordInputId);
            const newKeyword = input.value.trim();
            
            if (newKeyword) {
                // Add to global keywords if not already there
                if (!keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveKeywords();
                }
                
                // Add to task
                const task = tasks[taskId];
                if (!task.keywords) {
                    task.keywords = [];
                }
                if (!task.keywords.includes(newKeyword)) {
                    task.keywords.push(newKeyword);
                    
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                }
                
                // Clear input
                input.value = '';
                renderTasks();
            }
        }

        function saveKeywords() {
            if (useFirebase) {
                firebase.database().ref('keywords').set(keywords);
            } else {
                localStorage.setItem('obs_todo_keywords', JSON.stringify(keywords));
            }
        }

        function loadKeywords() {
            if (useFirebase) {
                firebase.database().ref('keywords').once('value').then(snap => {
                    const storedKeywords = snap.val();
                    if (storedKeywords && storedKeywords.length > 0) {
                        keywords = storedKeywords;
                    }
                });
            } else {
                const stored = localStorage.getItem('obs_todo_keywords');
                if (stored) {
                    keywords = JSON.parse(stored);
                }
            }
        }

        // Display Mode Storage Functions
        function saveDisplayMode() {
            if (useFirebase) {
                firebase.database().ref('displayMode').set(displayMode);
            } else {
                localStorage.setItem('obs_todo_displayMode', displayMode);
            }
        }

        function loadDisplayMode(callback) {
            if (useFirebase) {
                firebase.database().ref('displayMode').once('value').then(snap => {
                    const storedMode = snap.val();
                    if (storedMode) {
                        displayMode = storedMode;
                        // Update the radio button
                        document.getElementById(`mode-${displayMode}`).checked = true;
                        updateModeDescription();
                    }
                    if (callback) callback();
                });
            } else {
                const storedMode = localStorage.getItem('obs_todo_displayMode');
                if (storedMode) {
                    displayMode = storedMode;
                    // Update the radio button
                    document.getElementById(`mode-${displayMode}`).checked = true;
                    updateModeDescription();
                }
                if (callback) callback();
            }
        }

        // Keyword management functions
        function showKeywordManagement() {
            keywordManagement.classList.add('visible');
            renderKeywordManager();
        }

        function hideKeywordManagement() {
            keywordManagement.classList.remove('visible');
            editingKeywordIndex = null;
        }

        function renderKeywordManager() {
            keywordListManager.innerHTML = '';
            
            keywords.forEach((keyword, index) => {
                const keywordItem = document.createElement('div');
                keywordItem.className = 'keyword-item';
                
                if (editingKeywordIndex === index) {
                    keywordItem.innerHTML = `
                        <input type="text" value="${escapeHtml(keyword)}" id="edit-keyword-${index}">
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="saveKeywordEdit(${index})">‚úì</button>
                            <button class="keyword-item-btn" onclick="cancelKeywordEdit()">‚úó</button>
                        </div>
                    `;
                } else {
                    keywordItem.innerHTML = `
                        <span>${escapeHtml(keyword)}</span>
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="startEditingKeyword(${index})">‚úèÔ∏è</button>
                            <button class="keyword-item-btn" onclick="removeKeyword(${index})">üóëÔ∏è</button>
                        </div>
                    `;
                }
                
                keywordListManager.appendChild(keywordItem);
            });
        }

        function startEditingKeyword(index) {
            editingKeywordIndex = index;
            renderKeywordManager();
            
            // Focus the input field
            setTimeout(() => {
                const input = document.getElementById(`edit-keyword-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveKeywordEdit(index) {
            const input = document.getElementById(`edit-keyword-${index}`);
            if (input) {
                const newKeyword = input.value.trim();
                if (newKeyword) {
                    const oldKeyword = keywords[index];
                    keywords[index] = newKeyword;
                    
                    // Update all tasks that use this keyword
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.keywords && task.keywords.includes(oldKeyword)) {
                            const keywordIndex = task.keywords.indexOf(oldKeyword);
                            task.keywords[keywordIndex] = newKeyword;
                            
                            if (useFirebase) {
                                firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                            }
                        }
                    });
                    
                    saveKeywords();
                    saveAllTasks();
                    editingKeywordIndex = null;
                    renderKeywordManager();
                    renderTasks();
                }
            }
        }

        function cancelKeywordEdit() {
            editingKeywordIndex = null;
            renderKeywordManager();
        }

        function removeKeyword(index) {
            const keywordToRemove = keywords[index];
            
            if (confirm(`Are you sure you want to remove the keyword "${keywordToRemove}"? This will remove it from all tasks.`)) {
                // Remove from global keywords
                keywords.splice(index, 1);
                
                // Remove from all tasks
                Object.keys(tasks).forEach(taskId => {
                    const task = tasks[taskId];
                    if (task.keywords && task.keywords.includes(keywordToRemove)) {
                        const keywordIndex = task.keywords.indexOf(keywordToRemove);
                        task.keywords.splice(keywordIndex, 1);
                        
                        if (useFirebase) {
                            firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                        }
                    }
                });
                
                saveKeywords();
                saveAllTasks();
                renderKeywordManager();
                renderTasks();
            }
        }

        // Toggle task details visibility
        function toggleTaskDetails(taskId) {
            expandedTasks[taskId] = !expandedTasks[taskId];
            renderTasks();
        }

        // Render functions
        function renderTaskElement(taskId, task) {
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item conveyor-task';
            taskItem.dataset.id = taskId;
            taskItem.draggable = currentTab === 'active' && displayMode === 'static';
            
            if (task.completed) {
                taskItem.classList.add('completed');
            }

            const isExpanded = expandedTasks[taskId];
            
            // Keyword related elements
            const keywordsContainer = document.createElement('div');
            keywordsContainer.className = 'keywords-container';
            keywordsContainer.id = `keywords-${taskId}`;
            
            let assignedKeywordsHTML = '';
            if (task.keywords && task.keywords.length > 0) {
                assignedKeywordsHTML = task.keywords.map(k => `
                    <span class="keyword-tag selected">
                        ${escapeHtml(k)}
                        <button class="keyword-remove" onclick="removeKeywordFromTask('${taskId}', '${escapeHtml(k)}')">&times;</button>
                    </span>
                `).join('');
            }
            
            // Available keywords to add
            let availableKeywordsHTML = '';
            
            // We change the loop to include 'index'
            keywords.forEach((keyword, index) => {
                if (!task.keywords || !task.keywords.includes(keyword)) {
                    // We build a container with all 3 buttons
                    availableKeywordsHTML += `
                        <div class="keyword-tag" style="display:inline-flex; align-items:center; padding: 0; background-color: #4a505c;">
                            
                            <span style="padding: 2px 8px; cursor:pointer;" 
                                  title="Add '${escapeHtml(keyword)}' to task"
                                  onclick="toggleKeyword('${taskId}', '${escapeHtml(keyword)}')">
                                + ${escapeHtml(keyword)}
                            </span>
                            
                            <button class="keyword-item-btn" 
                                    title="Rename '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); startEditingKeyword(${index}); showKeywordManagement();">
                                ‚úèÔ∏è
                            </button>
                            
                            <button class="keyword-item-btn" 
                                    title="Remove '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); removeKeyword(${index});">
                                üóëÔ∏è
                            </button>
                        </div>
                    `;
                }
            });

            // Add new keyword input
            const keywordInputId = `keyword-input-${taskId}`;
            const keywordInputHTML = `
                <div class="keyword-input-container">
                    <input type="text" class="keyword-input" id="${keywordInputId}" placeholder="Add new...">
                    <button class="add-keyword-confirm" onclick="addNewKeyword('${taskId}', '${keywordInputId}')">+</button>
                </div>
            `;
            
            keywordsContainer.innerHTML = assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML;
            
            // Main task content
            let taskContentHTML;
            if (editingTaskId === taskId) {
                // Editing view
                taskContentHTML = `
                    <div class="task-main-content">
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        <input type="text" class="task-input" value="${escapeHtml(task.text)}">
                        <div class="task-actions">
                            <button class="action-btn" onclick="saveTaskEdit('${taskId}')">‚úîÔ∏è</button>
                            <button class="action-btn" onclick="cancelTaskEdit()">‚ùå</button>
                        </div>
                    </div>
                `;
            } else {
                // Normal view
                const isTimerRunning = !!timerIntervals[taskId];
                taskContentHTML = `
                    <div class="task-main-content">
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        <div class="task-content">
                            <span class="task-text">${escapeHtml(task.text)}</span>
                            ${task.completed && task.completedAt ? `<span class="completion-date">Completed: ${formatDate(task.completedAt)}</span>` : ''}
                        </div>
                        <button class="dropdown-btn ${isExpanded ? 'rotated' : ''}" onclick="toggleTaskDetails('${taskId}')">‚ñº</button>
                    </div>
                    <div class="task-details ${isExpanded ? 'visible' : ''}">
                        <div class="task-details-row">
                            <div class="task-time" id="timer-${taskId}">${formatTime(task.timeSpent || 0)}</div>
                            <div class="timer-controls">
                                <button class="timer-btn ${isTimerRunning ? 'running' : ''}" onclick="startTimer('${taskId}')" ${task.completed || isTimerRunning ? 'disabled' : ''}>‚ñ∂</button>
                                <button class="timer-btn" onclick="pauseTimer('${taskId}')" ${task.completed || !isTimerRunning ? 'disabled' : ''}>‚ùö‚ùö</button>
                                <button class="timer-btn" onclick="stopTimer('${taskId}')" ${task.completed ? 'disabled' : ''}>‚ñ†</button>
                            </div>
                        </div>
                        <div class="task-details-row">
                            <div class="task-actions">
                                <button class="action-btn" onclick="startEditingTask('${taskId}')">‚úèÔ∏è Edit</button>
                                <button class="action-btn" onclick="removeTask('${taskId}')">üóëÔ∏è Delete</button>
                            </div>
                        </div>
                        <div class="keywords-container ${isExpanded ? 'visible' : ''}">
                            ${assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML}
                        </div>
                    </div>
                `;
            }
            
            taskItem.innerHTML = taskContentHTML;
            
            // Add drag events only in static mode
            if (currentTab === 'active' && displayMode === 'static') {
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragenter', handleDragEnter);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('dragleave', handleDragLeave);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
            }

            return taskItem;
        }

        function renderTasks() {
            taskListEl.innerHTML = '';
            
            const taskEntries = Object.entries(tasks);
            
            // Filter tasks based on the current tab
            const filteredTasks = taskEntries.filter(([id, task]) => {
                if (currentTab === 'active') {
                    return !task.completed;
                } else {
                    return task.completed && isToday(task.completedAt);
                }
            });

            // Sort tasks
            if (currentTab === 'active') {
                // Sort by 'order' property
                filteredTasks.sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            } else {
                // Sort completed tasks by completion time, newest first
                filteredTasks.sort(([, a], [, b]) => new Date(b.completedAt) - new Date(a.completedAt));
            }
            
            if (filteredTasks.length === 0) {
                const message = currentTab === 'active' ? 'No active tasks. Add one below!' : 'No tasks completed today.';
                taskListEl.innerHTML = `<li class="empty-state">${message}</li>`;
            } else {
                filteredTasks.forEach(([id, task]) => {
                    const taskItem = renderTaskElement(id, task);
                    taskListEl.appendChild(taskItem);
                });
            }
            
            updateStats();
            updateTimeStats();
            timestampEl.textContent = `Updated: ${new Date().toLocaleString()}`;
            
            // Initialize conveyor if needed
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            }
        }

        function updateTaskDisplay(taskId) {
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (taskItem) {
                const task = tasks[taskId];
                const timerEl = taskItem.querySelector(`#timer-${taskId}`);
                if (timerEl) {
                    timerEl.textContent = formatTime(task.timeSpent || 0);
                }
                
                // Update timer button states
                const isTimerRunning = !!timerIntervals[taskId];
                const timerBtns = taskItem.querySelectorAll('.timer-btn');
                if (timerBtns.length > 0) {
                    timerBtns[0].disabled = task.completed || isTimerRunning;
                    timerBtns[1].disabled = task.completed || !isTimerRunning;
                    timerBtns[2].disabled = task.completed;
                    timerBtns[0].classList.toggle('running', isTimerRunning);
                }
            }
        }
        
        function updateStats() {
            const allTasks = Object.values(tasks);
            const activeTasks = allTasks.filter(task => !task.completed);
            const completedTasks = allTasks.filter(task => task.completed && isToday(task.completedAt));
            
            // Count ALL incomplete tasks (not just today's) and today's completed tasks
            const totalIncomplete = activeTasks.length;
            const completedToday = completedTasks.length;
            
            // Progress = completed today / (completed today + total incomplete)
            const totalRelevant = completedToday + totalIncomplete;
            
            let percent = 0;
            if (totalRelevant > 0) {
                percent = Math.round((completedToday / totalRelevant) * 100);
            }
            
            progressFill.style.width = `${percent}%`;
            progressPercent.textContent = `${percent}%`;
            completedCount.textContent = `${completedToday} completed today`;
            remainingCount.textContent = `${totalIncomplete} tasks remaining`;
        }
        
        function escapeHtml(str) {
            return (str || '').replace(/[&<>"']/g, match => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[match]));
        }

        // Task operations
        function addTask() {
            const text = inputEl.value.trim();
            if (text) {
                const newTaskId = useFirebase ? dbRef.push().key : `task-${Date.now()}`;
                const activeTasks = Object.values(tasks).filter(t => !t.completed);
                
                const newTask = {
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    order: activeTasks.length, // Set order to be the last one
                    timeSpent: 0,
                    timerStartTime: null,
                    lastUpdated: new Date().toISOString(),
                    keywords: []
                };
                
                if (useFirebase) {
                    dbRef.child(newTaskId).set(newTask);
                } else {
                    tasks[newTaskId] = newTask;
                    saveAllTasks();
                    renderTasks();
                }
                
                inputEl.value = '';
            }
        }

        function toggleTask(taskId) {
            const task = tasks[taskId];
            task.completed = !task.completed;
            
            if (task.completed) {
                task.completedAt = new Date().toISOString();
                // Stop timer when completing
                stopTimer(taskId);
            } else {
                task.completedAt = null;
            }
            
            updateTaskInStorage(taskId);
            
            // Re-render all tasks to update stats and lists
            renderTasks();
        }

        // Storage functions
        function updateTaskInStorage(taskId) {
            tasks[taskId].lastUpdated = new Date().toISOString();
            if (useFirebase) {
                dbRef.child(taskId).update(tasks[taskId]);
            } else {
                saveAllTasks();
            }
        }

        function saveAllTasks() {
            if (!useFirebase) {
                localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
            }
        }

        function loadTasks() {
            if (useFirebase) {
                dbRef = firebase.database().ref('tasks');
                dbRef.on('value', snap => {
                    tasks = snap.val() || {};
                    // Load display mode first, then render tasks
                    loadDisplayMode(() => {
                        renderTasks();
                    });
                });
            } else {
                const storedTasks = localStorage.getItem('obs_todo_tasks');
                tasks = storedTasks ? JSON.parse(storedTasks) : {};
                // Load display mode first, then render tasks
                loadDisplayMode(() => {
                    renderTasks();
                });
            }
        }

        // Display Mode Functions - CONVEYOR BELT IMPLEMENTATION
        function handleDisplayModeChange() {
            const selectedMode = document.querySelector('input[name="display-mode"]:checked').value;
            displayMode = selectedMode;
            
            // Save the display mode
            saveDisplayMode();
            
            // Update mode description
            updateModeDescription();
            
            // Stop any existing conveyor
            stopConveyor();
            
            // Clear any existing intervals
            if (conveyorInterval) {
                clearInterval(conveyorInterval);
                conveyorInterval = null;
            }
            
            // Reset conveyor state
            conveyorTasks = [];
            conveyorPosition = 0;
            isConveyorPaused = false;
            
            // Apply the selected mode
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            } else {
                // Reset to normal rendering for static mode
                conveyorContainer.classList.remove('conveyor-container');
                conveyorTrack.style.transform = 'translateY(0)';
                renderTasks();
            }

            // ADDED: Trigger OBS Refresh by changing the URL hash
            triggerObsRefresh(); 
        }

        function updateModeDescription() {
            const descriptionEl = document.getElementById('mode-description');
            let description = '';
            
            switch(displayMode) {
                case 'static':
                    description = 'Current tasks are displayed in a static list.';
                    break;
                case 'loop-incompleted':
                    description = 'Incompleted tasks will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'loop-all':
                    description = 'All tasks (including completed) will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'rotate-incompleted':
                    description = 'Incompleted tasks (except the top one) will rotate positions periodically.';
                    break;
            }
            
            descriptionEl.textContent = description;
        }

        function initConveyor() {
            // Clear any existing interval
            if (conveyorInterval) {
                clearInterval(conveyorInterval);
                conveyorInterval = null;
            }
            
            // Get tasks for conveyor based on mode
            conveyorTasks = Object.entries(tasks)
                .filter(([id, task]) => {
                    if (displayMode === 'loop-incompleted' || displayMode === 'rotate-incompleted') {
                        return !task.completed;
                    } else if (displayMode === 'loop-all') {
                        return true; // All tasks
                    }
                    return false;
                })
                .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            
            if (conveyorTasks.length === 0) {
                // No tasks to display in conveyor mode
                renderTasks();
                return;
            }
            
            conveyorPosition = 0;
            isConveyorPaused = false;
            
            // Reset container to conveyor mode
            conveyorContainer.classList.add('conveyor-container');
            conveyorTrack.style.transform = 'translateY(0)';
            
            // Render initial conveyor tasks
            renderConveyorTasks();
            
            // Start conveyor animation
            startConveyor();
        }

        function startConveyor() {
            if (conveyorInterval) clearInterval(conveyorInterval);
            
            // Set up conveyor animation (60fps for smooth movement)
            conveyorInterval = setInterval(() => {
                if (!isConveyorPaused) {
                    moveConveyor();
                }
            }, 16); // ~60fps
        }

        function stopConveyor() {
            if (conveyorInterval) {
                clearInterval(conveyorInterval);
                conveyorInterval = null;
            }
            
            // Reset container to normal rendering
            taskListEl.innerHTML = '';
            conveyorContainer.classList.remove('conveyor-container');
            conveyorTrack.style.transform = 'translateY(0)';
        }

        function renderConveyorTasks() {
            taskListEl.innerHTML = '';
            conveyorContainer.classList.add('conveyor-container');
            
            if (conveyorTasks.length === 0) {
                taskListEl.innerHTML = `<li class="empty-state">No tasks to display.</li>`;
                return;
            }
            
            // Create all tasks for the conveyor
            conveyorTasks.forEach(([taskId, task]) => {
                const taskItem = renderTaskElement(taskId, task);
                taskListEl.appendChild(taskItem);
            });
            
            // For rotate-incompleted mode, keep the first task fixed
            if (displayMode === 'rotate-incompleted' && conveyorTasks.length > 1) {
                const firstTask = taskListEl.querySelector('.task-item:first-child');
                if (firstTask) {
                    firstTask.style.position = 'sticky';
                    firstTask.style.top = '0';
                    firstTask.style.zIndex = '10';
                    firstTask.style.backgroundColor = 'rgba(255,255,255,.08)';
                }
            }
        }

        
        function moveConveyor() {
            if (conveyorTasks.length === 0) return;

            const movement = conveyorSpeed / 60; // pixels per frame
            conveyorPosition -= movement;

            const trackHeight = conveyorTrack.scrollHeight;
            const containerHeight = conveyorContainer.clientHeight;

            // When list scrolls past top, reset to bottom ‚Äî but hide the reset visually
            if (Math.abs(conveyorPosition) >=  containerHeight) {
                // Hide the track before resetting (so the jump isn't seen)
                conveyorTrack.style.opacity = '0';
                conveyorTrack.style.transition = 'none'; // disable smooth transition during reset

                // Reset position instantly
                conveyorPosition = containerHeight;
                conveyorTrack.style.transform = `translateY(${conveyorPosition}px)`;

                // Force reflow (ensures browser applies these immediately)
                void conveyorTrack.offsetHeight;

                // Show the track again after a tiny delay
                setTimeout(() => {
                conveyorTrack.style.transition = ''; // restore normal transition (if any)
                conveyorTrack.style.opacity = '1';
                }, 50);
            } else {
                // Normal movement
                conveyorTrack.style.transform = `translateY(${conveyorPosition}px)`;
            }

            // Rotate mode logic (unchanged)
            if (displayMode === 'rotate-incompleted' && conveyorTasks.length > 1) {
                handleRotateIncompleted();
            }
        }

        function handleRotateIncompleted() {
            // For rotate-incompleted mode, we periodically rotate the tasks (except the first one)
            // Check if it's time to rotate (every 5 seconds)
            const now = Date.now();
            if (!window.lastRotateTime) window.lastRotateTime = now;
            
            if (now - window.lastRotateTime > 5000) { // 5 seconds
                window.lastRotateTime = now;
                
                // Get incomplete tasks except the first one
                const incompleteTasks = Object.entries(tasks)
                    .filter(([id, task]) => !task.completed)
                    .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
                
                if (incompleteTasks.length <= 2) return;
                
                // Keep the first task fixed, rotate the rest
                const fixedTask = incompleteTasks[0];
                const tasksToRotate = incompleteTasks.slice(1);
                
                // Rotate the tasks (move first to end)
                const rotatedTasks = [...tasksToRotate.slice(1), tasksToRotate[0]];
                
                // Update the order
                let order = 1; // Start from 1 because 0 is the fixed task
                rotatedTasks.forEach(([id, task]) => {
                    tasks[id].order = order++;
                });
                
                // Save and re-render
                saveAllTasks();
                renderTasks();
            }
        }

        function pauseConveyor() {
            isConveyorPaused = true;
        }

        function resumeConveyor() {
            isConveyorPaused = false;
        }

        // Initialize display mode on page load
        function initializeDisplayMode() {
            // Load display mode from storage (this will set displayMode variable and update radio button)
            loadDisplayMode(() => {
                // If no stored mode, default to 'loop-incompleted'
                if (!displayMode) {
                    displayMode = 'loop-incompleted';
                    document.getElementById('mode-loop-incompleted').checked = true;
                    saveDisplayMode(); // Save the default
                }
                
                // Stop any existing conveyor
                stopConveyor();
                
                // Initialize conveyor for the current mode
                if (currentTab === 'active' && displayMode !== 'static') {
                    initConveyor();
                }
                
                updateModeDescription();
            });
        }

        // Event listeners
        addBtn.addEventListener('click', addTask);
        inputEl.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                editingTaskId = null; // Cancel editing when switching tabs
                
                // Stop conveyor if switching to completed tab
                if (currentTab === 'completed') {
                    stopConveyor();
                } else if (displayMode !== 'static') {
                    initConveyor();
                }
                
                renderTasks();
            });
        });

        // Keyword management listeners
        manageKeywordsBtn.addEventListener('click', showKeywordManagement);
        closeKeywordManagement.addEventListener('click', hideKeywordManagement);
        addNewKeywordBtn.addEventListener('click', () => {
            const newKeyword = newKeywordInput.value.trim();
            if (newKeyword && !keywords.includes(newKeyword)) {
                keywords.push(newKeyword);
                saveKeywords();
                renderKeywordManager();
                renderTasks(); // Re-render tasks to show new keyword
                newKeywordInput.value = '';
            }
        });
        newKeywordInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                addNewKeywordBtn.click();
            }
        });
        
        // Display mode listeners
        document.addEventListener('DOMContentLoaded', function() {
            const modeRadios = document.querySelectorAll('input[name="display-mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', handleDisplayModeChange);
            });
            
            // Initialize mode description (will be updated by initializeDisplayMode)
            updateModeDescription();
        });

        // Pause conveyor when interacting with tasks
        document.addEventListener('mouseenter', function(e) {
            if (e.target.closest('.task-item') && displayMode !== 'static') {
                pauseConveyor();
            }
        });

        document.addEventListener('mouseleave', function(e) {
            if (e.target.closest('.task-item') && displayMode !== 'static') {
                // Small delay before resuming
                setTimeout(resumeConveyor, 1000);
            }
        });
        
        // Initial load
        loadKeywords();
        loadTasks();
    </script>
</body>
</html>