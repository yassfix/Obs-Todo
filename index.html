<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Task Dashboard (Daily Progress)</title>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-light: #a29bfe;
            --secondary: #00b894;
            --background: #2d3436;
            --card: #353b48;
            --text: #dfe6e9;
            --accent: #fd79a8;
            --warning: #fdcb6e;
            --danger: #e17055;
        }
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}
        body{background-color:var(--background);color:var(--text);padding:15px;max-width:900px;margin:0 auto}
        .dashboard{display:flex;flex-direction:column;gap:20px}
        .header{text-align:center;margin-bottom:5px}
        .header h1{color:var(--primary);font-size:1.8rem;margin-bottom:3px}
        .header p{color:var(--primary-light);font-size:0.95rem}
        .focus-section{background-color:var(--card);border-radius:10px;padding:20px;box-shadow:0 4px 15px rgba(0,0,0,.2)}
        .section-header{display:flex;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary)}
        .section-header h2{font-size:1.4rem;margin-left:10px}
        .tabs-container{display:flex;border-bottom:2px solid var(--primary);margin-bottom:15px}
        .tab{flex:1;text-align:center;padding:10px 0;cursor:pointer;transition:all 0.3s;border-bottom:2px solid transparent}
        .tab.active{color:var(--primary);border-bottom-color:var(--primary);font-weight:bold}
        .tab:hover:not(.active){background-color:rgba(255,255,255,0.05)}
        .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;color:white;font-weight:bold;background-color:var(--accent)}
        .task-list{list-style-type:none;margin-bottom:20px}
        .task-item{display:flex;align-items:center;padding:12px 10px;margin-bottom:8px;background-color:rgba(255,255,255,.05);border-radius:8px;transition:all .3s;cursor:grab;}
        .task-item:hover{background-color:rgba(255,255,255,.1)}
        .task-item.dragging{opacity:0.5;background-color:rgba(255,255,255,.2);cursor:grabbing;}
        .task-checkbox{margin-right:12px;width:18px;height:18px;accent-color:var(--secondary);cursor:pointer}
        .task-text{flex-grow:1;font-size:1rem;margin-right:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .task-input{flex-grow:1;padding:5px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:1rem;margin-right:15px}
        .task-meta{display:flex;gap:10px;align-items:center;flex-shrink:0}
        .task-time{font-size:.8rem;color:var(--primary-light);white-space:nowrap;min-width: 70px;text-align: center;}
        .timer-controls{display:flex;gap:5px;}
        .timer-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .timer-btn:hover{background-color:rgba(255,255,255,0.1);}
        .timer-btn:disabled{color:rgba(255,255,255,0.3);cursor:not-allowed;}
        .timer-btn.running{color:var(--secondary);}
        .completed{text-decoration:line-through;opacity:.7}
        .progress-container{margin-top:15px}
        .progress-header{display:flex;justify-content:space-between;margin-bottom:6px;font-size:.9rem}
        .progress-bar{height:8px;background-color:rgba(255,255,255,.1);border-radius:4px;overflow:hidden}
        .progress-fill{height:100%;background-color:var(--secondary);border-radius:4px;transition:width .5s}
        .stats{display:flex;justify-content:space-between;margin-top:10px;font-size:.85rem;color:var(--primary-light)}
        .time-stats{display:flex;justify-content:space-between;margin-top:15px;padding:10px;background-color:rgba(255,255,255,.05);border-radius:8px;}
        .time-stat{display:flex;flex-direction:column;align-items:center;flex:1;}
        .time-stat-value{font-size:1.2rem;font-weight:bold;color:var(--secondary);}
        .time-stat-label{font-size:0.75rem;color:var(--primary-light);margin-top:5px;}
        .footer{text-align:center;margin-top:15px;color:var(--primary-light);font-size:.85rem}
        .new-task{display:flex;margin-top:15px;gap:8px}
        .new-task-input{flex-grow:1;padding:10px 12px;border:none;border-radius:6px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:.9rem}
        .new-task-button{padding:10px 15px;border:none;border-radius:6px;background-color:var(--primary);color:white;font-weight:bold;font-size:.9rem;cursor:pointer;white-space:nowrap}
        .empty-state{text-align:center;padding:20px;color:var(--primary-light);font-size:.9rem}
        .drag-handle{cursor:grab;margin-right:10px;color:var(--primary-light);}
        .task-actions{display:flex;gap:5px;margin-left:5px;}
        .action-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;display:flex;align-items:center;justify-content:center;}
        .action-btn:hover{background-color:rgba(255,255,255,0.1);}
        .completion-date{font-size:0.7rem;color:var(--primary-light);margin-top:2px;font-style:italic;}
        .task-content{flex-grow:1;display:flex;flex-direction:column;margin-right:15px;overflow:hidden;}
        
        /* Keyword/Tag Styles - UPDATED */
        .keywords-container{display:none;flex-wrap:wrap;gap:5px;margin-bottom:8px;align-items:center;}
        .keywords-container.visible{display:flex;}
        .keyword-tag{display:inline-flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:2px 8px;border-radius:12px;font-size:0.7rem;cursor:pointer;margin:2px;}
        .keyword-tag:hover{background-color:var(--primary);}
        .keyword-tag.selected{background-color:var(--secondary);}
        .keyword-remove{background:none;border:none;color:var(--background);cursor:pointer;margin-left:4px;font-size:0.7rem;font-weight:bold;padding:0;width:14px;height:14px;display:flex;align-items:center;justify-content:center;}
        .add-keyword-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .add-keyword-btn:hover{background-color:rgba(255,255,255,0.1);}
        .keyword-input-container{display:flex;gap:5px;margin-top:5px;}
        .keyword-input{flex-grow:1;padding:4px 8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:0.8rem;}
        .add-keyword-confirm{background-color:var(--secondary);color:white;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:0.8rem;}
        
        /* Keyword Management Styles */
        .keyword-management{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;justify-content:center;align-items:center;}
        .keyword-management.visible{display:flex;}
        .keyword-management-content{background-color:var(--card);padding:20px;border-radius:10px;width:90%;max-width:500px;max-height:80vh;overflow-y:auto;}
        .keyword-management-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:1px solid var(--primary);padding-bottom:10px;}
        .keyword-management-header h3{color:var(--primary);}
        .close-keyword-management{background:none;border:none;color:var(--primary-light);font-size:1.5rem;cursor:pointer;}
        .keyword-list{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:15px;}
        .keyword-item{display:flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:5px 10px;border-radius:15px;}
        .keyword-item input{background:none;border:none;color:var(--background);font-size:0.8rem;width:100px;}
        .keyword-item input:focus{outline:none;}
        .keyword-item-actions{display:flex;gap:5px;margin-left:5px;}
        .keyword-item-btn{background:none;border:none;color:var(--background);cursor:pointer;font-size:0.8rem;padding:2px 5px;}
        .new-keyword-input{display:flex;gap:8px;margin-top:10px;}
        .new-keyword-input input{flex-grow:1;padding:8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);}
        .new-keyword-input button{padding:8px 15px;border:none;border-radius:4px;background-color:var(--primary);color:white;cursor:pointer;}
        .show-keywords-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.7rem;padding:2px 5px;border-radius:3px;margin-bottom:5px;}
        .show-keywords-btn:hover{background-color:rgba(255,255,255,0.1);}
        .manage-keywords-btn{background-color:var(--primary);color:white;border:none;padding:8px 15px;border-radius:6px;cursor:pointer;margin-top:10px;font-size:0.9rem;}
        
        @media (max-width:600px){.task-meta{flex-direction:column;gap:3px;align-items:flex-end}.task-time{font-size:.7rem}}
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>Enhanced Task Dashboard</h1>
            <p>Drag tasks to reorder ‚Ä¢ Timers track your time spent ‚Ä¢ Progress shows today's completion</p>
        </div>
        <div class="focus-section">
            <div class="tabs-container">
                <div class="tab active" data-tab="active">Current Focus</div>
                <div class="tab" data-tab="completed">Completed Tasks</div>
            </div>
            
            <div class="time-stats">
                <div class="time-stat">
                    <div class="time-stat-value" id="daily-total">00:00:00</div>
                    <div class="time-stat-label">Today</div>
                </div>
                <div class="time-stat">
                    <div class="time-stat-value" id="lifetime-total">00:00:00</div>
                    <div class="time-stat-label">Lifetime</div>
                </div>
            </div>
            
            <ul class="task-list" id="task-list"></ul>
            <div class="new-task">
                <input type="text" class="new-task-input" placeholder="Add a new task..." id="new-task-input">
                <button class="new-task-button" id="add-task-btn">Add</button>
            </div>
            <button class="manage-keywords-btn" id="manage-keywords-btn">Manage Keywords</button>
            <div class="progress-container">
                <div class="progress-header">
                    <span>Today's Progress</span>
                    <span id="progress-percent">0%</span>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
            </div>
            <div class="stats">
                <span id="completed-count">0 of 0 completed today</span>
                <span id="remaining-count">0 tasks remaining</span>
            </div>
        </div>
        <div class="footer">
            <p id="timestamp">Updated: --</p>
        </div>
    </div>

    <div class="keyword-management" id="keyword-management">
        <div class="keyword-management-content">
            <div class="keyword-management-header">
                <h3>Manage Keywords</h3>
                <button class="close-keyword-management" id="close-keyword-management">&times;</button>
            </div>
            <div class="keyword-list" id="keyword-list-manager"></div>
            <div class="new-keyword-input">
                <input type="text" id="new-keyword-input" placeholder="Add a new keyword...">
                <button id="add-new-keyword-btn">Add</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDEEMO9MlcNsb_QLIRTDJM4rXqxGZuYJps",
            authDomain: "obs-todo-68da2.firebaseapp.com",
            databaseURL: "https://obs-todo-68da2-default-rtdb.firebaseio.com",
            projectId: "obs-todo-68da2",
            storageBucket: "obs-todo-68da2.firebasestorage.app",
            messagingSenderId: "594250582895",
            appId: "1:594250582895:web:62414c9f759b99904cb69a",
            measurementId: "G-N94MD8GRJQ"
        };

        let useFirebase = false;
        try {
            if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                firebase.initializeApp(firebaseConfig);
                useFirebase = true;
            }
        } catch (err) {
            console.warn('Firebase init failed, falling back to localStorage:', err);
            useFirebase = false;
        }

        // DOM elements
        const taskListEl = document.getElementById('task-list');
        const inputEl = document.getElementById('new-task-input');
        const addBtn = document.getElementById('add-task-btn');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const completedCount = document.getElementById('completed-count');
        const remainingCount = document.getElementById('remaining-count');
        const timestampEl = document.getElementById('timestamp');
        const tabs = document.querySelectorAll('.tab');
        const dailyTotalEl = document.getElementById('daily-total');
        const lifetimeTotalEl = document.getElementById('lifetime-total');
        const manageKeywordsBtn = document.getElementById('manage-keywords-btn');
        const keywordManagement = document.getElementById('keyword-management');
        const closeKeywordManagement = document.getElementById('close-keyword-management');
        const keywordListManager = document.getElementById('keyword-list-manager');
        const newKeywordInput = document.getElementById('new-keyword-input');
        const addNewKeywordBtn = document.getElementById('add-new-keyword-btn');

        // App state
        let tasks = {};
        let dbRef = null;
        let currentTab = 'active';
        let timerIntervals = {};
        let dragSrcEl = null;
        let editingTaskId = null;
        let lifetimeTotalSeconds = 0;
        let editingKeywordIndex = null;

        // Default keywords
        let keywords = ['Work', 'Personal', 'Urgent', 'Important', 'Shopping'];

        // Utility function to check if a date is today
        function isToday(date) {
            const today = new Date();
            const checkDate = new Date(date);
            return checkDate.getDate() === today.getDate() &&
                   checkDate.getMonth() === today.getMonth() &&
                   checkDate.getFullYear() === today.getFullYear();
        }

        // Format date for display
        function formatDate(date) {
            const d = new Date(date);
            const now = new Date();
            const diffTime = now.getTime() - d.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return `Today at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else if (diffDays === 1) {
                return `Yesterday at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else {
                return `${d.toLocaleDateString()} at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            }
        }

        // Timer functions
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function startTimer(taskId) {
            if (timerIntervals[taskId]) return; // Timer already running
            
            const task = tasks[taskId];
            if (!task.timerStartTime) {
                task.timerStartTime = Date.now();
            }
            
            timerIntervals[taskId] = setInterval(() => {
                const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                task.timeSpent = (task.timeSpent || 0) + elapsed;
                task.timerStartTime = Date.now();
                
                // Update lifetime total
                lifetimeTotalSeconds += elapsed;
                saveLifetimeTotal();
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
                updateTimeStats();
            }, 1000);
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        function pauseTimer(taskId) {
            if (timerIntervals[taskId]) {
                clearInterval(timerIntervals[taskId]);
                delete timerIntervals[taskId];
                
                const task = tasks[taskId];
                if (task.timerStartTime) {
                    const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                    task.timeSpent = (task.timeSpent || 0) + elapsed;
                    task.timerStartTime = null;
                    
                    // Update lifetime total
                    lifetimeTotalSeconds += elapsed;
                    saveLifetimeTotal();
                }
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
                updateTimeStats();
            }
        }

        function stopTimer(taskId) {
            pauseTimer(taskId);
            
            const task = tasks[taskId];
            task.timerStartTime = null;
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        // Time statistics functions
        function calculateDailyTotal() {
            const today = new Date().toDateString();
            let totalSeconds = 0;
            
            Object.values(tasks).forEach(task => {
                // Check if task was completed today or has time spent today
                if (task.completedAt) {
                    const completedDate = new Date(task.completedAt).toDateString();
                    if (completedDate === today) {
                        totalSeconds += task.timeSpent || 0;
                    }
                } else if (task.timeSpent && task.lastUpdated) {
                    const lastUpdatedDate = new Date(task.lastUpdated).toDateString();
                    if (lastUpdatedDate === today) {
                        totalSeconds += task.timeSpent || 0;
                    }
                }
            });
            
            return totalSeconds;
        }

        function updateTimeStats() {
            const dailyTotalSeconds = calculateDailyTotal();
            dailyTotalEl.textContent = formatTime(dailyTotalSeconds);
            lifetimeTotalEl.textContent = formatTime(lifetimeTotalSeconds);
        }

        function loadLifetimeTotal() {
            if (useFirebase) {
                firebase.database().ref('lifetimeTotal').once('value').then(snap => {
                    lifetimeTotalSeconds = snap.val() || 0;
                    updateTimeStats();
                });
            } else {
                const stored = localStorage.getItem('obs_todo_lifetime_total');
                lifetimeTotalSeconds = stored ? parseInt(stored) : 0;
                updateTimeStats();
            }
        }

        function saveLifetimeTotal() {
            if (useFirebase) {
                firebase.database().ref('lifetimeTotal').set(lifetimeTotalSeconds);
            } else {
                localStorage.setItem('obs_todo_lifetime_total', lifetimeTotalSeconds.toString());
            }
        }

        // Drag and drop functions
        function handleDragStart(e) {
            if (currentTab !== 'active') return;
            
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (dragSrcEl !== this) {
                const taskItems = Array.from(taskListEl.querySelectorAll('.task-item'));
                const srcIndex = taskItems.indexOf(dragSrcEl);
                const destIndex = taskItems.indexOf(this);
                
                if (srcIndex !== -1 && destIndex !== -1) {
                    // Reorder tasks in the data structure
                    const taskKeys = Object.keys(tasks).filter(key => !tasks[key].completed);
                    const movedKey = taskKeys[srcIndex];
                    
                    // Remove from current position
                    taskKeys.splice(srcIndex, 1);
                    // Insert at new position
                    taskKeys.splice(destIndex, 0, movedKey);
                    
                    // Update order in tasks object
                    taskKeys.forEach((key, index) => {
                        tasks[key].order = index;
                    });
                    
                    // Save and re-render
                    saveAllTasks();
                    renderTasks();
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('over', 'dragging');
            });
        }

        // Task removal function
        function removeTask(taskId) {
            if (confirm('Are you sure you want to remove this task?')) {
                if (useFirebase) {
                    firebase.database().ref('tasks/' + taskId).remove();
                } else {
                    delete tasks[taskId];
                    saveAllTasks();
                    renderTasks();
                }
            }
        }

        // Task editing functions
        function startEditingTask(taskId) {
            editingTaskId = taskId;
            renderTasks();
            
            // Focus the input field after a short delay
            setTimeout(() => {
                const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveTaskEdit(taskId) {
            const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
            if (input) {
                const newText = input.value.trim();
                if (newText) {
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ text: newText });
                    } else {
                        tasks[taskId].text = newText;
                        saveAllTasks();
                    }
                }
            }
            editingTaskId = null;
            renderTasks();
        }

        function cancelTaskEdit() {
            editingTaskId = null;
            renderTasks();
        }

        // Keyword functions
        function toggleKeyword(taskId, keyword) {
            const task = tasks[taskId];
            if (!task.keywords) {
                task.keywords = [];
            }
            
            const index = task.keywords.indexOf(keyword);
            if (index === -1) {
                // Add keyword
                task.keywords.push(keyword);
            } else {
                // Remove keyword
                task.keywords.splice(index, 1);
            }
            
            if (useFirebase) {
                firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
            } else {
                saveAllTasks();
            }
            renderTasks();
        }

        function removeKeywordFromTask(taskId, keyword) {
            const task = tasks[taskId];
            if (task.keywords) {
                const index = task.keywords.indexOf(keyword);
                if (index !== -1) {
                    task.keywords.splice(index, 1);
                    
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                    renderTasks();
                }
            }
        }

        function addNewKeyword(taskId, keywordInputId) {
            const input = document.getElementById(keywordInputId);
            const newKeyword = input.value.trim();
            
            if (newKeyword) {
                // Add to global keywords if not already there
                if (!keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveKeywords();
                }
                
                // Add to task
                const task = tasks[taskId];
                if (!task.keywords) {
                    task.keywords = [];
                }
                if (!task.keywords.includes(newKeyword)) {
                    task.keywords.push(newKeyword);
                    
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                }
                
                // Clear input
                input.value = '';
                renderTasks();
            }
        }

        function saveKeywords() {
            if (useFirebase) {
                firebase.database().ref('keywords').set(keywords);
            } else {
                localStorage.setItem('obs_todo_keywords', JSON.stringify(keywords));
            }
        }

        function loadKeywords() {
            if (useFirebase) {
                firebase.database().ref('keywords').once('value').then(snap => {
                    const storedKeywords = snap.val();
                    if (storedKeywords && storedKeywords.length > 0) {
                        keywords = storedKeywords;
                    }
                });
            } else {
                const stored = localStorage.getItem('obs_todo_keywords');
                if (stored) {
                    keywords = JSON.parse(stored);
                }
            }
        }

        // Keyword management functions
        function showKeywordManagement() {
            keywordManagement.classList.add('visible');
            renderKeywordManager();
        }

        function hideKeywordManagement() {
            keywordManagement.classList.remove('visible');
            editingKeywordIndex = null;
        }

        function renderKeywordManager() {
            keywordListManager.innerHTML = '';
            
            keywords.forEach((keyword, index) => {
                const keywordItem = document.createElement('div');
                keywordItem.className = 'keyword-item';
                
                if (editingKeywordIndex === index) {
                    keywordItem.innerHTML = `
                        <input type="text" value="${escapeHtml(keyword)}" id="edit-keyword-${index}">
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="saveKeywordEdit(${index})">‚úì</button>
                            <button class="keyword-item-btn" onclick="cancelKeywordEdit()">‚úó</button>
                        </div>
                    `;
                } else {
                    keywordItem.innerHTML = `
                        <span>${escapeHtml(keyword)}</span>
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="startEditingKeyword(${index})">‚úèÔ∏è</button>
                            <button class="keyword-item-btn" onclick="removeKeyword(${index})">üóëÔ∏è</button>
                        </div>
                    `;
                }
                
                keywordListManager.appendChild(keywordItem);
            });
        }

        function startEditingKeyword(index) {
            editingKeywordIndex = index;
            renderKeywordManager();
            
            // Focus the input field
            setTimeout(() => {
                const input = document.getElementById(`edit-keyword-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveKeywordEdit(index) {
            const input = document.getElementById(`edit-keyword-${index}`);
            if (input) {
                const newKeyword = input.value.trim();
                if (newKeyword) {
                    const oldKeyword = keywords[index];
                    keywords[index] = newKeyword;
                    
                    // Update all tasks that use this keyword
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.keywords && task.keywords.includes(oldKeyword)) {
                            const keywordIndex = task.keywords.indexOf(oldKeyword);
                            task.keywords[keywordIndex] = newKeyword;
                            
                            if (useFirebase) {
                                firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                            }
                        }
                    });
                    
                    saveKeywords();
                    saveAllTasks();
                    editingKeywordIndex = null;
                    renderKeywordManager();
                    renderTasks();
                }
            }
        }

        function cancelKeywordEdit() {
            editingKeywordIndex = null;
            renderKeywordManager();
        }

        function removeKeyword(index) {
            const keywordToRemove = keywords[index];
            
            if (confirm(`Are you sure you want to remove the keyword "${keywordToRemove}"? This will remove it from all tasks.`)) {
                // Remove from global keywords
                keywords.splice(index, 1);
                
                // Remove from all tasks
                Object.keys(tasks).forEach(taskId => {
                    const task = tasks[taskId];
                    if (task.keywords && task.keywords.includes(keywordToRemove)) {
                        const keywordIndex = task.keywords.indexOf(keywordToRemove);
                        task.keywords.splice(keywordIndex, 1);
                        
                        if (useFirebase) {
                            firebase.database().ref('tasks/' + taskId).update({ keywords: task.keywords });
                        }
                    }
                });
                
                saveKeywords();
                saveAllTasks();
                renderKeywordManager();
                renderTasks();
            }
        }
        
        // =================================================================
        //               *** CODE CHANGE IS IN THIS SECTION ***
        // =================================================================

        // Render functions
        function renderTaskElement(taskId, task) {
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item';
            taskItem.dataset.id = taskId;
            taskItem.draggable = currentTab === 'active';
            
            if (task.completed) {
                taskItem.classList.add('completed');
            }

            // Keyword related elements
            const keywordsContainer = document.createElement('div');
            keywordsContainer.className = 'keywords-container';
            keywordsContainer.id = `keywords-${taskId}`;
            
            let assignedKeywordsHTML = '';
            if (task.keywords && task.keywords.length > 0) {
                assignedKeywordsHTML = task.keywords.map(k => `
                    <span class="keyword-tag selected">
                        ${escapeHtml(k)}
                        <button class="keyword-remove" onclick="removeKeywordFromTask('${taskId}', '${escapeHtml(k)}')">&times;</button>
                    </span>
                `).join('');
            }
            
            // Available keywords to add
            let availableKeywordsHTML = '';
            
            // =================================================================
            //               *** THIS IS THE MODIFIED BLOCK ***
            // =================================================================
            // We change the loop to include 'index'
            keywords.forEach((keyword, index) => {
                if (!task.keywords || !task.keywords.includes(keyword)) {
                    // We build a container with all 3 buttons
                    availableKeywordsHTML += `
                        <div class="keyword-tag" style="display:inline-flex; align-items:center; padding: 0; background-color: #4a505c;">
                            
                            <span style="padding: 2px 8px; cursor:pointer;" 
                                  title="Add '${escapeHtml(keyword)}' to task"
                                  onclick="toggleKeyword('${taskId}', '${escapeHtml(keyword)}')">
                                + ${escapeHtml(keyword)}
                            </span>
                            
                            <button class="keyword-item-btn" 
                                    title="Rename '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); startEditingKeyword(${index}); showKeywordManagement();">
                                ‚úèÔ∏è
                            </button>
                            
                            <button class="keyword-item-btn" 
                                    title="Remove '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); removeKeyword(${index});">
                                üóëÔ∏è
                            </button>
                        </div>
                    `;
                }
            });
            // =================================================================
            //               *** END OF MODIFIED BLOCK ***
            // =================================================================


            // Add new keyword input
            const keywordInputId = `keyword-input-${taskId}`;
            const keywordInputHTML = `
                <div class="keyword-input-container">
                    <input type="text" class="keyword-input" id="${keywordInputId}" placeholder="Add new...">
                    <button class="add-keyword-confirm" onclick="addNewKeyword('${taskId}', '${keywordInputId}')">+</button>
                </div>
            `;
            
            keywordsContainer.innerHTML = assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML;
            
            // Main task content
            let taskContentHTML;
            if (editingTaskId === taskId) {
                // Editing view
                taskContentHTML = `
                    <input type="text" class="task-input" value="${escapeHtml(task.text)}">
                    <div class="task-actions">
                        <button class="action-btn" onclick="saveTaskEdit('${taskId}')">‚úîÔ∏è</button>
                        <button class="action-btn" onclick="cancelTaskEdit()">‚ùå</button>
                    </div>
                `;
            } else {
                // Normal view
                const isTimerRunning = !!timerIntervals[taskId];
                taskContentHTML = `
                    <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                    <div class="task-content">
                        <span class="task-text">${escapeHtml(task.text)}</span>
                        ${task.completed && task.completedAt ? `<span class="completion-date">Completed: ${formatDate(task.completedAt)}</span>` : ''}
                    </div>
                    <div class="task-meta">
                        <div class="task-time" id="timer-${taskId}">${formatTime(task.timeSpent || 0)}</div>
                        <div class="timer-controls">
                            <button class="timer-btn ${isTimerRunning ? 'running' : ''}" onclick="startTimer('${taskId}')" ${task.completed || isTimerRunning ? 'disabled' : ''}>‚ñ∂</button>
                            <button class="timer-btn" onclick="pauseTimer('${taskId}')" ${task.completed || !isTimerRunning ? 'disabled' : ''}>‚ùö‚ùö</button>
                            <button class="timer-btn" onclick="stopTimer('${taskId}')" ${task.completed ? 'disabled' : ''}>‚ñ†</button>
                        </div>
                        <div class="task-actions">
                            <button class="action-btn" onclick="startEditingTask('${taskId}')">‚úèÔ∏è</button>
                            <button class="action-btn" onclick="removeTask('${taskId}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }
            
            taskItem.innerHTML = taskContentHTML;
            
            // Add keyword button and container (conditionally)
            if (currentTab === 'active') {
                const showKeywordsBtn = document.createElement('button');
                showKeywordsBtn.className = 'show-keywords-btn';
                showKeywordsBtn.innerHTML = 'üè∑Ô∏è Keywords';
                showKeywordsBtn.onclick = () => {
                    keywordsContainer.classList.toggle('visible');
                };
                
                // Insert keyword elements after the task-content
                const taskContentDiv = taskItem.querySelector('.task-content');
                if (taskContentDiv) {
                    taskContentDiv.insertAdjacentElement('afterend', showKeywordsBtn);
                    showKeywordsBtn.insertAdjacentElement('afterend', keywordsContainer);
                }
            }

            // Add drag events
            if (currentTab === 'active') {
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragenter', handleDragEnter);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('dragleave', handleDragLeave);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
            }

            return taskItem;
        }

        function renderTasks() {
            taskListEl.innerHTML = '';
            
            const taskEntries = Object.entries(tasks);
            
            // Filter tasks based on the current tab
            const filteredTasks = taskEntries.filter(([id, task]) => {
                if (currentTab === 'active') {
                    return !task.completed;
                } else {
                    return task.completed && isToday(task.completedAt);
                }
            });

            // Sort tasks
            if (currentTab === 'active') {
                // Sort by 'order' property
                filteredTasks.sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            } else {
                // Sort completed tasks by completion time, newest first
                filteredTasks.sort(([, a], [, b]) => new Date(b.completedAt) - new Date(a.completedAt));
            }
            
            if (filteredTasks.length === 0) {
                const message = currentTab === 'active' ? 'No active tasks. Add one below!' : 'No tasks completed today.';
                taskListEl.innerHTML = `<li class="empty-state">${message}</li>`;
            } else {
                filteredTasks.forEach(([id, task]) => {
                    const taskItem = renderTaskElement(id, task);
                    taskListEl.appendChild(taskItem);
                });
            }
            
            updateStats();
            updateTimeStats();
            timestampEl.textContent = `Updated: ${new Date().toLocaleString()}`;
        }
        
        // (The rest of the script continues...)
        // ...
        
    </script>
    
    <script>
        // ... (All previous script content) ...
        
        // =================================================================
        // *** THIS IS THE ONLY FUNCTION I'VE MODIFIED ***
        // =================================================================
        
        // Render functions
        function renderTaskElement(taskId, task) {
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item';
            taskItem.dataset.id = taskId;
            taskItem.draggable = currentTab === 'active';
            
            if (task.completed) {
                taskItem.classList.add('completed');
            }

            // Keyword related elements
            const keywordsContainer = document.createElement('div');
            keywordsContainer.className = 'keywords-container';
            keywordsContainer.id = `keywords-${taskId}`;
            
            let assignedKeywordsHTML = '';
            if (task.keywords && task.keywords.length > 0) {
                assignedKeywordsHTML = task.keywords.map(k => `
                    <span class="keyword-tag selected">
                        ${escapeHtml(k)}
                        <button class="keyword-remove" onclick="removeKeywordFromTask('${taskId}', '${escapeHtml(k)}')">&times;</button>
                    </span>
                `).join('');
            }
            
            // Available keywords to add
            let availableKeywordsHTML = '';
            
            // =================================================================
            //               *** THIS IS THE MODIFIED BLOCK ***
            // =================================================================
            // We change the loop to include 'index'
            keywords.forEach((keyword, index) => {
                if (!task.keywords || !task.keywords.includes(keyword)) {
                    // We build a container with all 3 buttons
                    availableKeywordsHTML += `
                        <div class="keyword-tag" style="display:inline-flex; align-items:center; padding: 0; background-color: #4a505c;">
                            
                            <span style="padding: 2px 8px; cursor:pointer;" 
                                  title="Add '${escapeHtml(keyword)}' to task"
                                  onclick="toggleKeyword('${taskId}', '${escapeHtml(keyword)}')">
                                + ${escapeHtml(keyword)}
                            </span>
                            
                            <button class="keyword-item-btn" 
                                    title="Rename '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); startEditingKeyword(${index}); showKeywordManagement();">
                                ‚úèÔ∏è
                            </button>
                            
                            <button class="keyword-item-btn" 
                                    title="Remove '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); removeKeyword(${index});">
                                üóëÔ∏è
                            </button>
                        </div>
                    `;
                }
            });
            // =================================================================
            //               *** END OF MODIFIED BLOCK ***
            // =================================================================


            // Add new keyword input
            const keywordInputId = `keyword-input-${taskId}`;
            const keywordInputHTML = `
                <div class="keyword-input-container">
                    <input type="text" class="keyword-input" id="${keywordInputId}" placeholder="Add new...">
                    <button class="add-keyword-confirm" onclick="addNewKeyword('${taskId}', '${keywordInputId}')">+</button>
                </div>
            `;
            
            keywordsContainer.innerHTML = assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML;
            
            // Main task content
            let taskContentHTML;
            if (editingTaskId === taskId) {
                // Editing view
                taskContentHTML = `
                    <input type="text" class="task-input" value="${escapeHtml(task.text)}">
                    <div class="task-actions">
                        <button class="action-btn" onclick="saveTaskEdit('${taskId}')">‚úîÔ∏è</button>
                        <button class="action-btn" onclick="cancelTaskEdit()">‚ùå</button>
                    </div>
                `;
            } else {
                // Normal view
                const isTimerRunning = !!timerIntervals[taskId];
                taskContentHTML = `
                    <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                    <div class="task-content">
                        <span class="task-text">${escapeHtml(task.text)}</span>
                        ${task.completed && task.completedAt ? `<span class="completion-date">Completed: ${formatDate(task.completedAt)}</span>` : ''}
                    </div>
                    <div class="task-meta">
                        <div class="task-time" id="timer-${taskId}">${formatTime(task.timeSpent || 0)}</div>
                        <div class="timer-controls">
                            <button class="timer-btn ${isTimerRunning ? 'running' : ''}" onclick="startTimer('${taskId}')" ${task.completed || isTimerRunning ? 'disabled' : ''}>‚ñ∂</button>
                            <button class="timer-btn" onclick="pauseTimer('${taskId}')" ${task.completed || !isTimerRunning ? 'disabled' : ''}>‚ùö‚ùö</button>
                            <button class="timer-btn" onclick="stopTimer('${taskId}')" ${task.completed ? 'disabled' : ''}>‚ñ†</button>
                        </div>
                        <div class="task-actions">
                            <button class="action-btn" onclick="startEditingTask('${taskId}')">‚úèÔ∏è</button>
                            <button class="action-btn" onclick="removeTask('${taskId}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }
            
            taskItem.innerHTML = taskContentHTML;
            
            // Add keyword button and container (conditionally)
            if (currentTab === 'active') {
                const showKeywordsBtn = document.createElement('button');
                showKeywordsBtn.className = 'show-keywords-btn';
                showKeywordsBtn.innerHTML = 'üè∑Ô∏è Keywords';
                showKeywordsBtn.onclick = () => {
                    keywordsContainer.classList.toggle('visible');
                };
                
                // Insert keyword elements after the task-content
                const taskContentDiv = taskItem.querySelector('.task-content');
                if (taskContentDiv) {
                    taskContentDiv.insertAdjacentElement('afterend', showKeywordsBtn);
                    showKeywordsBtn.insertAdjacentElement('afterend', keywordsContainer);
                }
            }

            // Add drag events
            if (currentTab === 'active') {
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragenter', handleDragEnter);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('dragleave', handleDragLeave);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
            }

            return taskItem;
        }

        function renderTasks() {
            taskListEl.innerHTML = '';
            
            const taskEntries = Object.entries(tasks);
            
            // Filter tasks based on the current tab
            const filteredTasks = taskEntries.filter(([id, task]) => {
                if (currentTab === 'active') {
                    return !task.completed;
                } else {
                    return task.completed && isToday(task.completedAt);
                }
            });

            // Sort tasks
            if (currentTab === 'active') {
                // Sort by 'order' property
                filteredTasks.sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            } else {
                // Sort completed tasks by completion time, newest first
                filteredTasks.sort(([, a], [, b]) => new Date(b.completedAt) - new Date(a.completedAt));
            }
            
            if (filteredTasks.length === 0) {
                const message = currentTab === 'active' ? 'No active tasks. Add one below!' : 'No tasks completed today.';
                taskListEl.innerHTML = `<li class="empty-state">${message}</li>`;
            } else {
                filteredTasks.forEach(([id, task]) => {
                    const taskItem = renderTaskElement(id, task);
                    taskListEl.appendChild(taskItem);
                });
            }
            
            updateStats();
            updateTimeStats();
            timestampEl.textContent = `Updated: ${new Date().toLocaleString()}`;
        }

        function updateTaskDisplay(taskId) {
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (taskItem) {
                const task = tasks[taskId];
                const timerEl = taskItem.querySelector(`#timer-${taskId}`);
                if (timerEl) {
                    timerEl.textContent = formatTime(task.timeSpent || 0);
                }
                
                // Update timer button states
                const isTimerRunning = !!timerIntervals[taskId];
                taskItem.querySelector('.timer-btn:nth-child(1)').disabled = task.completed || isTimerRunning;
                taskItem.querySelector('.timer-btn:nth-child(2)').disabled = task.completed || !isTimerRunning;
                taskItem.querySelector('.timer-btn:nth-child(3)').disabled = task.completed;
                taskItem.querySelector('.timer-btn:nth-child(1)').classList.toggle('running', isTimerRunning);
            }
        }
        
        function updateStats() {
            const allTasks = Object.values(tasks);
            const activeTasks = allTasks.filter(task => !task.completed);
            const todayTasks = allTasks.filter(task => isToday(task.createdAt) || (task.completed && isToday(task.completedAt)));
            const completedToday = todayTasks.filter(task => task.completed);

            const totalToday = todayTasks.length;
            const completedCountToday = completedToday.length;
            
            let percent = 0;
            if (totalToday > 0) {
                percent = Math.round((completedCountToday / totalToday) * 100);
            }
            
            progressFill.style.width = `${percent}%`;
            progressPercent.textContent = `${percent}%`;
            completedCount.textContent = `${completedCountToday} of ${totalToday} completed today`;
            remainingCount.textContent = `${activeTasks.length} tasks remaining`;
        }
        
        function escapeHtml(str) {
            return (str || '').replace(/[&<>"']/g, match => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[match]));
        }

        // Task operations
        function addTask() {
            const text = inputEl.value.trim();
            if (text) {
                const newTaskId = useFirebase ? dbRef.push().key : `task-${Date.now()}`;
                const activeTasks = Object.values(tasks).filter(t => !t.completed);
                
                const newTask = {
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    order: activeTasks.length, // Set order to be the last one
                    timeSpent: 0,
                    timerStartTime: null,
                    lastUpdated: new Date().toISOString(),
                    keywords: []
                };
                
                if (useFirebase) {
                    dbRef.child(newTaskId).set(newTask);
                } else {
                    tasks[newTaskId] = newTask;
                    saveAllTasks();
                    renderTasks();
                }
                
                inputEl.value = '';
            }
        }

        function toggleTask(taskId) {
            const task = tasks[taskId];
            task.completed = !task.completed;
            
            if (task.completed) {
                task.completedAt = new Date().toISOString();
                // Stop timer when completing
                stopTimer(taskId);
            } else {
                task.completedAt = null;
            }
            
            updateTaskInStorage(taskId);
            
            // Re-render all tasks to update stats and lists
            renderTasks();
        }

        // Storage functions
        function updateTaskInStorage(taskId) {
            tasks[taskId].lastUpdated = new Date().toISOString();
            if (useFirebase) {
                dbRef.child(taskId).update(tasks[taskId]);
            } else {
                saveAllTasks();
            }
        }

        function saveAllTasks() {
            if (!useFirebase) {
                localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
            }
        }

        function loadTasks() {
            if (useFirebase) {
                dbRef = firebase.database().ref('tasks');
                dbRef.on('value', snap => {
                    tasks = snap.val() || {};
                    renderTasks();
                });
            } else {
                const storedTasks = localStorage.getItem('obs_todo_tasks');
                tasks = storedTasks ? JSON.parse(storedTasks) : {};
                renderTasks();
            }
        }

        // Event listeners
        addBtn.addEventListener('click', addTask);
        inputEl.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                editingTaskId = null; // Cancel editing when switching tabs
                renderTasks();
            });
        });

        // Keyword management listeners
        manageKeywordsBtn.addEventListener('click', showKeywordManagement);
        closeKeywordManagement.addEventListener('click', hideKeywordManagement);
        addNewKeywordBtn.addEventListener('click', () => {
            const newKeyword = newKeywordInput.value.trim();
            if (newKeyword && !keywords.includes(newKeyword)) {
                keywords.push(newKeyword);
                saveKeywords();
                renderKeywordManager();
                renderTasks(); // Re-render tasks to show new keyword
                newKeywordInput.value = '';
            }
        });
        newKeywordInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                addNewKeywordBtn.click();
            }
        });

        // Initial load
        loadKeywords();
        loadLifetimeTotal();
        loadTasks();
    </script>
</body>
</html>