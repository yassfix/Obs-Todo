<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Dashboard | Obs-todo </title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> <style></style>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-light: #a29bfe;
            --secondary: #00b894;
            --background: #000000;
            --card: #000000ec;
            --text: #dfe6e9;
            --accent: #fd79a8;
            --warning: #fdcb6e;
            --danger: #e17055;
        }
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}
        body{background-color:var(--background);color:var(--text);padding:15px;max-width:900px;margin:0 auto}
        .dashboard{display:flex;flex-direction:column;gap:20px}
        .header{text-align:center;margin-bottom:5px}
        .header h1{color:var(--primary);font-size:1.5rem;margin-bottom:3px}
        .header p{color:var(--primary-light);font-size:0.95rem}
        .focus-section{background-color:var(--card);border-radius:10px;padding:20px;box-shadow:0 4px 15px rgba(0,0,0,.2);position:relative;overflow:hidden;}
        .section-header{display:flex;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary)}
        .section-header h2{font-size:1.4rem;margin-left:10px}
        .tabs-container{display:flex;border-bottom:2px solid var(--primary);margin-bottom:15px}
        .tab{flex:1;text-align:center;padding:10px 0;cursor:pointer;transition:all 0.3s;border-bottom:2px solid transparent}
        .tab.active{color:var(--primary);border-bottom-color:var(--primary);font-weight:bold}
        .tab:hover:not(.active){background-color:rgba(255,255,255,0.05)}
        .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;color:white;font-weight:bold;background-color:var(--accent)}
        .task-list{list-style-type:none;margin-bottom:20px;position:relative;}
        .task-item{display:flex;align-items:center;padding:12px 10px;margin-bottom:8px;background-color:rgba(255,255,255,.05);border-radius:8px;transition:all .3s;cursor:grab;}
        .task-item:hover{background-color:rgba(255,255,255,.1)}
        .task-item.dragging{opacity:0.5;background-color:rgba(255,255,255,.2);cursor:grabbing;}
        
        .task-checkbox{margin-right:20px;width:18px;height:18px;accent-color:var(--secondary);cursor:pointer}
        
        .task-text{flex-grow:1;font-size:1.1rem;font-family: 'Times New Roman', Times, serif;margin-right:15px;margin-left:10px;word-wrap:break-word;overflow-wrap:break-word;white-space:normal}
        
        .task-input{flex-grow:1;padding:5px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:1rem;margin-right:15px}
        .task-meta{display:flex;gap:10px;align-items:center;flex-shrink:0}
        .task-time{font-size:.8rem;color:var(--primary-light);white-space:nowrap;min-width: 70px;text-align: center;}
        .timer-controls{display:flex;gap:5px;}
        .timer-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .timer-btn:hover:not(:disabled){background-color:rgba(255,255,255,0.1);}
        .timer-btn:disabled{color:rgba(255,255,255,0.3);cursor:not-allowed;}
        .timer-btn.running{color:var(--secondary);}
        .completed{text-decoration:line-through;opacity:.7}
        .progress-container{margin-top:15px}
        .progress-header{display:flex;justify-content:space-between;margin-bottom:6px;font-size:.9rem}
        .progress-bar{height:8px;background-color:rgba(255,255,255,.1);border-radius:4px;overflow:hidden}
        .progress-fill{height:100%;background-color:var(--secondary);border-radius:4px;transition:width .5s}
        .stats{display:flex;justify-content:space-between;margin-top:10px;font-size:.85rem;color:var(--primary-light)}
        .time-stats{display:flex;justify-content:space-between;margin-top:15px;padding:10px;background-color:rgba(255,255,255,.05);border-radius:8px;}
        .time-stat{display:flex;flex-direction:column;align-items:center;flex:1;}
        .time-stat-value{font-size:1.2rem;font-weight:bold;color:var(--secondary);}
        .time-stat-label{font-size:0.75rem;color:var(--primary-light);margin-top:5px;}
        .footer{text-align:center;margin-top:15px;color:var(--primary-light);font-size:.85rem}
        .new-task{display:flex;margin-top:15px;gap:8px}
        .new-task-input{flex-grow:1;padding:10px 12px;border:none;border-radius:6px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:.9rem}
        .new-task-button{padding:10px 15px;border:none;border-radius:6px;background-color:var(--primary);color:white;font-weight:bold;font-size:.9rem;cursor:pointer;white-space:nowrap}
        .empty-state{text-align:center;padding:20px;color:var(--primary-light);font-size:.9rem}
        .drag-handle{cursor:grab;margin-right:10px;color:var(--primary-light);}
        .task-actions{display:flex;gap:5px;margin-left:5px;}
        .action-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;display:flex;align-items:center;justify-content:center;}
        .action-btn:hover{background-color:rgba(255,255,255,0.1);}
        .completion-date{font-size:0.7rem;color:var(--primary-light);margin-top:2px;font-style:italic;}
        .task-content{flex-grow:1;display:flex;flex-direction:column;margin-right:15px;overflow:hidden;min-width:0} /* Added min-width:0 for proper flexbox wrapping */
        
        /* Keyword/Tag Styles */
        .keywords-container{display:none;flex-wrap:wrap;gap:5px;margin-bottom:8px;align-items:center;}
        .keywords-container.visible{display:flex;}
        .keyword-tag{display:inline-flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:2px 8px;border-radius:12px;font-size:0.7rem;cursor:pointer;margin:2px;}
        .keyword-tag:hover{background-color:var(--primary);}
        .keyword-tag.selected{background-color:var(--secondary);}
        .keyword-remove{background:none;border:none;color:var(--background);cursor:pointer;margin-left:4px;font-size:0.7rem;font-weight:bold;padding:0;width:14px;height:14px;display:flex;align-items:center;justify-content:center;}
        .add-keyword-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .add-keyword-btn:hover{background-color:rgba(255,255,255,0.1);}
        .keyword-input-container{display:flex;gap:5px;margin-top:5px;}
        .keyword-input{flex-grow:1;padding:4px 8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:0.8rem;}
        .add-keyword-confirm{background-color:var(--secondary);color:white;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:0.8rem;}
        
        /* Keyword Management Styles */
        .keyword-management{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;justify-content:center;align-items:center;}
        .keyword-management.visible{display:flex;}
        .keyword-management-content{background-color:var(--card);padding:20px;border-radius:10px;width:90%;max-width:500px;max-height:80vh;overflow-y:auto;}
        .keyword-management-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:1px solid var(--primary);padding-bottom:10px;}
        .keyword-management-header h3{color:var(--primary);}
        .close-keyword-management{background:none;border:none;color:var(--primary-light);font-size:1.5rem;cursor:pointer;}
        .keyword-list{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:15px;}
        .keyword-item{display:flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:5px 10px;border-radius:15px;}
        .keyword-item input{background:none;border:none;color:var(--background);font-size:0.8rem;width:100px;}
        .keyword-item input:focus{outline:none;}
        .keyword-item-actions{display:flex;gap:5px;margin-left:5px;}
        .keyword-item-btn{background:none;border:none;color:var(--background);cursor:pointer;font-size:0.8rem;padding:2px 5px;}
        .new-keyword-input{display:flex;gap:8px;margin-top:10px;}
        .new-keyword-input input{flex-grow:1;padding:8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);}
        .new-keyword-input button{padding:8px 15px;border:none;border-radius:4px;background-color:var(--primary);color:white;cursor:pointer;}
        .show-keywords-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.7rem;padding:2px 5px;border-radius:3px;margin-bottom:5px;}
        .show-keywords-btn:hover{background-color:rgba(255,255,255,0.1);}
        .manage-keywords-btn{background-color:var(--primary);color:white;border:none;padding:8px 15px;border-radius:6px;cursor:pointer;margin-top:10px;font-size:0.9rem;}
        
        /*  STYLES FOR THE LAYOUT CHANGES */
        .time-stats-container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            position: relative;
            z-index: 2;
        }
        .timers-section {
            display: flex;
            gap: 15px;
            flex: 1;
            align-items: center; 
        justify-content: space-around; 
        }
        .progress-section {
            width: 50%;
        }
        .progress-section .progress-container {
            margin-top: 0;
        }
        .progress-section .progress-bar {
            width: 100%;
        }
        
        /* STYLES FOR DROPDOWN FUNCTIONALITY */
        .task-main-content {
            display: flex;
            align-items: center;
            width: 100%;
        }
        .dropdown-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            transition: transform 0.3s;
        }
        .dropdown-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .dropdown-btn.rotated {
            transform: rotate(180deg);
        }
        .task-details {
            display: none;
            width: 100%;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 8px;
        }
        .task-details.visible {
            display: flex;
            flex-direction: column;
        }
        .task-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        /* --- NEW DISPLAY MODE STYLING --- */

        /* Container Layout */
        .display-mode-section {
            background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(0,0,0,0.4) 100%);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        /* Add a subtle top border accent */
        .display-mode-section::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        .display-mode-section h3 {
            text-align: center;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--primary-light);
            margin-bottom: 20px;
            opacity: 0.8;
        }

        /* Grid for the cards */
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        /* The Card Option Wrapper */
        .mode-option {
            display: inherit !important;
            position: relative;
            margin: 0; /* Reset */
        }

        /* Hide the default radio button completely */
        .mode-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* The visual card label */
        .mode-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            height: 100%;
            min-height: 90px;
            color: var(--text);
            font-size: 0.85rem;
            font-weight: 500;
        }

        /* Icon styling inside label (We will add spans to HTML) */
        .mode-option label span.icon {
            font-size: 1.5rem;
            margin-bottom: 8px;
            background: none;
            width: auto;
            height: auto;
            color: var(--primary-light);
            transition: transform 0.3s ease;
        }

        /* HOVER STATE */
        .mode-option label:hover {
            background-color: rgba(255, 255, 255, 0.08);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }

        /* CHECKED/ACTIVE STATE */
        .mode-option input[type="radio"]:checked + label {
            background-color: rgba(108, 92, 231, 0.15); /* Primary with opacity */
            border-color: var(--secondary);
            box-shadow: 0 0 15px rgba(0, 184, 148, 0.2); /* Secondary glow */
            color: white;
        }

        .mode-option input[type="radio"]:checked + label span.icon {
            color: var(--secondary);
            transform: scale(1.2);
        }

        /* The Description Box */
        .mode-description {
            background-color: rgba(0,0,0,0.3);
            border-left: 3px solid var(--secondary);
            padding: 12px 15px;
            border-radius: 0 6px 6px 0;
            font-family: 'Segoe UI Mono', monospace;
            font-size: 0.8rem;
            color: var(--primary-light);
            line-height: 1.4;
            min-height: 45px;
            display: flex;
            align-items: center;
        }

        /* --- MINIMAL MODE TOGGLE (SWITCH STYLE) --- */
        .minimal-mode-toggle {
            background-color: transparent !important;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 0;
        }

        .minimal-mode-toggle h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text);
        }

        /* Custom Switch Container */
        .switch-container {
            display: flex;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Hide radios in switch */
        .switch-container input {
            display: none;
        }

        .switch-container label {
            padding: 6px 16px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            color: var(--primary-light);
        }

        .switch-container input:checked + label {
            background-color: var(--primary);
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* CONVEYOR BELT ANIMATION STYLES */
        .conveyor-container {
            position: relative;
            overflow: hidden;
            height: auto;
            min-height: 100px;
        }

        .conveyor-track {
            position: relative;
            transition: transform 0.1s linear;
        }

        .conveyor-task {
            transition: opacity 0.5s ease;
            margin-bottom: 8px;
        }

        .task-entering {
            opacity: 0;
            transform: translateY(20px);
        }

        .task-visible {
            opacity: 1;
            transform: translateY(0);
        }

        .task-exiting {
            opacity: 0;
            transform: translateY(-20px);
        }

        /*  STYLES FOR LIMITED VISIBLE AREA AND SCROLLING */
        .tasks-container {
            max-height: 272px; 
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-light) rgba(255,255,255,0.1);
            margin-bottom: 15px;
            border-radius: 8px;
            padding-right: 5px;
        }

        .tasks-container::-webkit-scrollbar {
            width: 8px;
        }

        .tasks-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-light);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary);
        }
        
        /*   STYLES FOR ORDER BUTTONS */
        .task-order-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-right: 8px;
            align-self: stretch; 
        }
        .order-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.7rem;
            line-height: 1;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .order-btn:hover:not(:disabled) {
            background-color: rgba(255,255,255,0.1);
        }
        .order-btn:disabled {
            color: rgba(255,255,255,0.2);
            cursor: not-allowed;
        }
        .task-order-controls + .task-checkbox {
            margin-right: 0;
        }


        /* For mobile responsiveness */
        @media (max-width:600px){
            .task-meta{flex-direction:column;gap:3px;align-items:flex-end}
            .task-time{font-size:.7rem}
            .time-stats-container {
                flex-direction: column;
                gap: 15px;
            }
            .timers-section {
                width: 100%;
            }
            .progress-section {
                width: 100%;
            }
            .task-details-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .mode-selector {
                flex-direction: column;
                gap: 10px;
            }
            .reporting-stats {
                flex-direction: column;
            }
        }
        
        @media (max-width: 768px) {
            .reporting-flex-container {
                flex-direction: column;
            }
        }

        /* smooth bottom entrance */
        .conveyor-reset {
            animation: slideFromBottom 0.5s ease-out;
        }

        @keyframes slideFromBottom {
            0% {
                transform: translateY(100%);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* REPORTING STYLES  */
        #reporting-content-wrapper {
            padding-top: 15px;
        }
        .reporting-stats {
            display: flex;
            gap: 15px;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .stat-card {
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            padding: 15px;
            flex: 1;
            text-align: center;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--secondary);
        }
        .stat-label {
            font-size: 0.85rem;
            color: var(--primary-light);
            margin-top: 5px;
        }
        
        .chart-container {
            margin-top: 20px;
            height: 250px; 
            position: relative;
        }
        
        .chart-container h3 {
            text-align: center;
            color: var(--primary-light);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        /*   Reporting Flex Layout  */
        .reporting-flex-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 20px;
        }

        .reporting-flex-container > div {
            flex: 1; 
            min-width: 0; 
            margin-top: 0 !important;
        }

        /*  LOGIN STYLES  */
        #login-container {
            display: none;
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            margin: 50px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }
        #login-container .header h1 {
            margin-bottom: 20px;
        }
        #login-container form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #login-container input {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background-color: rgba(255,255,255,.1);
            color: var(--text);
        }
        #login-container button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        #signup-btn {
            background-color: var(--primary);
        }
        #login-btn {
            background-color: var(--secondary);
        }
        #guest-btn {
            background-color: var(--accent);
            margin-top: 10px;
        }
        #logout-btn {
            background: none;
            border: 1px solid var(--primary-light);
            color: var(--primary-light);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.7rem;
        }
        
        /* : PASSWORD RESET STYLES  */
        .forgot-password-link {
            color: var(--primary-light);
            text-decoration: none;
            font-size: 0.8rem;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
        }
        .forgot-password-link:hover {
            color: var(--primary);
            text-decoration: underline;
        }
        .password-reset-container {
            display: none;
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            margin: 50px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }
        .password-reset-container h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }
        .password-reset-container p {
            color: var(--primary-light);
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        .password-reset-container input {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background-color: rgba(255,255,255,.1);
            color: var(--text);
            width: 100%;
            margin-bottom: 15px;
        }
        .password-reset-container button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
        }
        #reset-password-btn {
            background-color: var(--primary);
            margin-bottom: 10px;
        }
        #back-to-login-btn {
            background-color: var(--accent);
        }
        .reset-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9rem;
        }
        .reset-success {
            background-color: rgba(0, 184, 148, 0.2);
            color: var(--secondary);
        }
        .reset-error {
            background-color: rgba(225, 112, 85, 0.2);
            color: var(--danger);
        }

        /*  STREAK CALENDAR STYLES */
        .streak-calendar-container {
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }

        .streak-calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 10px;
        }

        .streak-calendar-header h3 {
            color: var(--primary);
            font-size: 1.2rem;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .calendar-nav-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .calendar-nav-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .current-month {
            font-weight: bold;
            color: var(--text);
            min-width: 150px;
            text-align: center;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }

        .calendar-day-header {
            text-align: center;
            font-size: 0.8rem;
            color: var(--primary-light);
            padding: 5px 0;
            font-weight: bold;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 0.8rem;
            background-color: rgba(255,255,255,0.05);
            transition: all 0.2s;
            position: relative;
        }

        .calendar-day.empty {
            background-color: transparent;
        }

        .calendar-day.today {
            border: 2px solid var(--primary);
        }

        .calendar-day.has-streak {
            background-color: var(--secondary);
            color: var(--background);
            font-weight: bold;
        }

        .calendar-day.has-streak::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 6px;
            border: 2px solid var(--secondary);
            animation: pulse 2s infinite;
        }

        /*  Style for frozen streak days */
        .calendar-day.has-frozen-streak {
            background-color: #6c5ce730;
            color: rgb(255, 255, 255);
        }

        .calendar-day.weekend {
            background-color: rgba(255,255,255,0.02);
        }
        /*  Override for frozen weekend days */
        .calendar-day.weekend.has-frozen-streak {
            background-color: #6c5ce730;
        }

        .calendar-day.weekend.has-streak {
            background-color: var(--secondary);
        }

        .streak-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .streak-stat {
            text-align: center;
        }

        .streak-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary);
        }

        .streak-label {
            font-size: 0.8rem;
            color: var(--primary-light);
            margin-top: 5px;
        }

        .streak-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-streak {
            background-color: var(--secondary);
        }

        /*  Style for the frozen legend item */
        .legend-frozen {
            background-color: #6c5ce730;
        }

        .legend-today {
            border: 2px solid var(--primary);
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7;
            }
        }

        /* For mobile responsiveness */
        @media (max-width: 600px) {
            .calendar-grid {
                gap: 3px;
            }
            
            .calendar-day {
                font-size: 0.7rem;
            }
            
            .streak-stats {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        /* Total hours display */
        .total-hours-display {
            font-size: 0.9rem;
            color: var(--primary-light);
            text-align: center;
            margin-top: 10px;
        }

        /*  Insights section styles */
        .insights-section {
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }

        .insights-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        #generate-insights-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        #generate-insights-btn:hover {
            background-color: var(--primary-light);
        }

        #generate-insights-btn:disabled {
            background-color: var(--primary-light);
            cursor: not-allowed;
            opacity: 0.7;
        }

        #insights-loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: var(--primary-light);
        }

        #insights-result {
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            padding: 35px;
            margin-top: 15px;
            white-space: normal;
            line-height: 1.5;
        }
        
        /*  Guest Mode Reporting Message  */
        .guest-reporting-message {
            text-align: center;
            padding: 40px 20px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .guest-reporting-message h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }
        
        .guest-reporting-message p {
            color: var(--primary-light);
            margin-bottom: 20px;
        }

        /* UPDATED: Minimal Mode Styles  */
        .minimal-mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
        }
        
        .minimal-mode-toggle label {
            font-size: 0.9rem;
            color: var(--text);
            cursor: pointer;
        }
        
        .minimal-mode-toggle input[type="radio"] {
            margin-right: 5px;
            accent-color: var(--primary);
        }
        
        .mode-option {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        /* Minimal Mode Styles */
        .minimal-mode .header,
        .minimal-mode .tabs-container,
        .minimal-mode .footer,
        .minimal-mode .display-mode-section,
        .minimal-mode .manage-keywords-btn,
        .minimal-mode .stats,
        .minimal-mode .new-task,
        .minimal-mode .pomo-toggle-section {
         
            display: none !important;
        }
        
        .minimal-mode .focus-section {
            padding: 10px;
            box-shadow: none;
            border-radius: 0;
            margin-top: 0;
        }
        
        .minimal-mode .time-stats-container {
            margin-top: 0;
            padding: 5px;
            background-color: transparent;
        }
        
        .minimal-mode .tasks-container {
            max-height: 300px;
        }
        
        .minimal-mode .minimal-mode-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: var(--card);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            margin-top: 0;
        }
        
        .minimal-mode body {
            padding: 5px;
        }
        
        .minimal-mode .dashboard {
            gap: 5px;
        }
        
        .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        min-height: 40px;
    }

    /* Media Query for Small Screens (e.g., phones) */
    @media (max-width: 680px) {


        button#toggle-user-status-btn {
            margin-left: -70px !important;
            
        }

        /* Target the container for stacking */
        .header-controls {
            /* Change the direction to stack items vertically */
            flex-direction: column; 
            
            /* Center the items when stacked */
            align-items: center; 
            
            /* Add some space between the stacked items */
            gap: 10px; 
            
            /* Adjust width/padding if needed for the container itself */
            padding: 10px 0; 
        }
        
        /* Center the user status text */
        #user-status {
            text-align: center;
            /* Ensure it takes full width for better centering */
            width: 100%; 
            margin-left:0px !important;
        }

        /* Adjust the Buy Me A Coffee container for better fit and centering */
        .bmc-container {
            /* Remove the scale/margin overrides which were likely for horizontal alignment */
            margin-right: 0 !important;
            
            /* Center the button itself (if needed) and ensure it doesn't shrink */
            width: auto !important;
            flex-shrink: 0;
            
            /* You might want to adjust the button size back to normal/larger */
            /* If you still want it small, keep the original inline styles, but centering is better */
        }
    }

    /* New Style for Privacy Toggle */
    .hidden-status {
        /* Hide the text by default using a color transition for effect */
        color: transparent !important; 
        transition: color 0.5s ease;
        /* Optional: Keep the space for the text */
        min-width: 150px; 
    }
    .visible-status {
        /* Make the text visible */
        color: var(--primary-light) !important;
    }



        /* task timer styling */
        /* LAYOUT: Timer under name, Button on right */
    .task-content {
        display: flex;
        flex-direction: column; /* Stacks name and timer vertically */
        justify-content: center;
        margin-right: auto; /* Pushes everything else to the right */
        padding-right: 10px;
    }

    .task-timer-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 2px;
    }

    .timer-display-small {
        font-family: 'Segoe UI Mono', monospace;
        font-size: 0.8rem;
        color: var(--primary-light);
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.5px;
        padding-left: 8px;
    }

    .right-play-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2rem; /* Larger, easy to hit button */
        color: var(--primary-light);
        padding: 5px 12px;
        margin-right: 5px;
        border-radius: 50%;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 36px;
        width: 36px;
    }

    .right-play-btn:hover {
        background-color: rgba(255,255,255,0.1);
        color: var(--primary);
    }

    .right-play-btn.running {
        color: var(--secondary); /* Green when running */
        background-color: rgba(0, 184, 148, 0.1);
        box-shadow: 0 0 10px rgba(0, 184, 148, 0.2);
    }

    .right-play-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

        /* --- POMODORO STYLES --- */

    /* Container for the Swap */
    .timers-section {
        position: relative;
    }

    /* Pomodoro UI Styling */
    #pomodoro-container {
    display: none; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(108, 92, 231, 0.1);
    border: 1px solid var(--primary);
    border-radius: 8px;
    padding: 5px 15px; /* Increased side padding slightly for look */
    min-width: 120px; /* Fixed width to prevent jumping */
    margin: 0; /* Ensure no margins push it down */
    }

    #pomo-timer-display {
        font-family: 'Segoe UI Mono', monospace;
        font-size: 1.4rem;
        font-weight: bold;
        color: var(--accent);
        font-variant-numeric: tabular-nums;
    }

    .pomo-controls {
        display: flex;
        gap: 5px;
        margin-top: 5px;
    }

    .pomo-btn {
        background: rgba(255,255,255,0.1);
        border: none;
        color: var(--text);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        transition: background 0.2s;
    }

    .pomo-btn:hover {
        background: var(--primary);
    }

    .pomo-btn.active-opt {
        background: var(--secondary);
        color: white;
    }

    .pomo-btn.control {
        font-weight: bold;
        color: var(--secondary);
        font-size: 0.9rem;
    }

    #pomo-status-label {
        font-size: 0.7rem; 
        margin-top: 2px;
        color: var(--primary-light);
    }

    /* Mode Toggle Section (Bottom) */
    .pomo-toggle-section {
        background-color: var(--card);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(0,0,0,.2);
        margin-top: 20px;
    }

    .pomo-toggle-section h3 {
        color: var(--accent); /* Different color to distinguish */
        margin-bottom: 15px;
        font-size: 1.2rem;
    }

    /* Completion Animation */
    @keyframes flash-screen {
        0% { background-color: var(--background); }
        50% { background-color: rgba(0, 184, 148, 0.3); } /* Green flash */
        100% { background-color: var(--background); }
    }

    .pomo-finished-anim {
        animation: flash-screen 0.5s ease-in-out 4; /* Flash 4 times */
    }

        /* --- FIX CHART SPACING & STYLING --- */

/* 1. Spacing: Push the linear charts down so they aren't crammed against the calendar */
    .reporting-flex-container {
        margin-bottom: 50px !important; 
    }

    /* 2. Card Style: Give each linear chart a distinct box */
    .chart-container {
        background-color: var(--card); /* Dark background */
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        padding: 25px; 
        margin-top: 30px !important; /* More space between stacked charts */
        height: 400px; /* Fixed height for the chart area */
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
    }

    /* Ensure canvas fills the remaining height after title/controls */
    

    /* --- 3. BUTTON FIX: Override big cards to look like simple buttons --- */

    /* Force the container to be a simple row, not a grid */
    .chart-container .mode-selector {
        display: flex !important; 
        flex-direction: row !important;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-bottom: 15px !important;
        border: none;
        background: transparent;
        padding: 0;
    }

    /* Reset the card wrapper */
    .chart-container .mode-option {
        margin: 0 !important;
        width: auto !important;
        display: block !important;
    }

    /* Reset the label styling to be a small "pill" button */
    .chart-container .mode-option label {
        display: inline-flex !important;
        align-items: center;
        justify-content: center;
        min-height: unset !important; /* Remove the big 90px height */
        height: 32px !important;      /* Fixed small height */
        padding: 0 20px !important;   /* Horizontal padding */
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;          /* Rounded pill shape */
        font-size: 0.85rem !important;
        font-weight: normal;
        color: var(--primary-light);
        box-shadow: none !important;  /* Remove the glow */
        transform: none !important;   /* Remove default hover movement */
    }

    /* Active State for Chart Buttons */
    .chart-container .mode-option input[type="radio"]:checked + label {
        background-color: var(--primary);
        border-color: var(--primary);
        color: white;
    }

    /* Hover State for Chart Buttons */
    .chart-container .mode-option label:hover {
        background-color: rgba(255, 255, 255, 0.15);
        border-color: var(--primary-light);
    }

    .chart-container canvas {
        flex-grow: 1;
        /* Removed fixed width/height allows Chart.js to handle the aspect ratio */
        min-height: 0; 
        max-width: 100%;
    }
        

    </style>
</head>
<body>
    <!--  Login Container -->
    <div id="login-container">
        <div class="header">
            <h1>Obs Todo</h1>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: var(--primary); margin-bottom: 15px;">Sign Up</h3>
            <form id="signup-form">
                <input type="email" id="signup-email" placeholder="Email">
                <input type="password" id="signup-password" placeholder="Password">
                <button type="submit" id="signup-btn">Sign Up</button>
            </form>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: var(--primary); margin-bottom: 15px;">Login</h3>
            <form id="login-form">
                <input type="email" id="login-email" placeholder="Email">
                <input type="password" id="login-password" placeholder="Password">
                <button type="submit" id="login-btn">Login</button>
                <a class="forgot-password-link" id="forgot-password-link">Forgot Password?</a>
            </form>
        </div>
        
        <div>
            <div id="auth-error-msg" style="color: #e17055; text-align: center; margin-bottom: 15px; font-size: 0.9rem;"></div>
            <h3 style="color: var(--primary); margin-bottom: 15px;">Guest Mode</h3>
            <p style="color: var(--primary-light); font-size: 0.9rem; margin-bottom: 15px;">
                Use the app without an account. Your completed tasks will be deleted the next day.
            </p>
            <button type="button" id="guest-btn">Continue as Guest</button>
        </div>
    </div>

    <!--  Password Reset Container -->
    <div id="password-reset-container" class="password-reset-container">
        <div class="header">
            <h1>Reset Password</h1>
        </div>
        
        <h3>Forgot your password?</h3>
        <p>Enter your email address and we'll send you a link to reset your password.</p>
        
        <form id="password-reset-form">
            <input type="email" id="reset-email" placeholder="Email" required>
            <button type="submit" id="reset-password-btn">Send Reset Link</button>
        </form>
        
        <button type="button" id="back-to-login-btn">Back to Login</button>
        
        <div id="reset-message" class="reset-message"></div>
    </div>

    <!--  Dashboard wrapper with id -->
    <div class="dashboard" id="dashboard-wrapper" style="display: none;">
        <!--  Header with logout button -->
        <div class="header">
            <h1>Obs Todo <button id="logout-btn">Logout</button></h1>
            
            <div class="header-controls" style="display: flex; justify-content: space-between; align-items: center; width: 100%; min-height: 40px;">
                
                <div style="display: flex; align-items: center; margin-left: 100px;">
                    <button id="toggle-user-status-btn" style="background: none; border: none; color: var(--primary-light); cursor: pointer; font-size: 1.2rem; margin-right: 8px;" title="Show/Hide User Status">
                        ðŸ”’
                    </button>
                    <p id="user-status" class="hidden-status" style="margin: 0;"></p>
                </div>

                <div class="bmc-container" style="width: 120px; transform: scale(0.48); transform-origin: center-right; flex-shrink: 0; margin-right: 100px">
                    <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="Construct.exe" data-color="#FFDD00" data-emoji="" data-font="Cookie" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" ></script>
                </div>

            </div>
        </div>

        <div class="focus-section">
            <div class="tabs-container">
                <div class="tab active" data-tab="active">Current Focus</div>
                <div class="tab" data-tab="completed">Completed Tasks</div>
                <div class="tab" data-tab="reporting">Reporting</div>
            </div>
            
            <div class="time-stats-container">
                <div class="timers-section">
                    <div class="time-stat" id="normal-timer-container">
                        <div class="time-stat-value" id="daily-total">00:00:00</div>
                        <div class="time-stat-label">Today</div>
                    </div>

                    <div class="time-stat" id="pomodoro-container">
                        <div id="pomo-timer-display">25:00</div>
                        <div class="pomo-controls">
                            <button class="pomo-btn active-opt" id="btn-25" onclick="selectPomoDuration(25)">25+5</button>
                            <button class="pomo-btn" id="btn-50" onclick="selectPomoDuration(50)">50+10</button>
                            <button class="pomo-btn control" id="pomo-action-btn" onclick="togglePomodoroAction()">â–¶</button>
                            <button class="pomo-btn control" onclick="resetPomodoro()">â†º</button>
                        </div>
                        <div class="time-stat-label" id="pomo-status-label">Ready to Focus</div>
                    </div>

                    <div class="time-stat">
                        <div class="time-stat-value" id="total-hours">0 hours</div>
                        <div class="time-stat-label">Total Hours</div>
                    </div>
                </div>

                <audio id="pomo-alarm" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>

                <div class="progress-section">
                    <div class="progress-container">
                        <div class="progress-header">
                            <span>Today's Progress</span>
                            <span id="progress-percent">0%</span>
                        </div>
                        <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
                    </div>
                </div>
            </div>
            
            <div id="task-content-wrapper">
                <div class="tasks-container" id="tasks-container">
                    <div class="conveyor-container" id="conveyor-container">
                        <div class="conveyor-track" id="conveyor-track">
                            <ul class="task-list" id="task-list"></ul>
                        </div>
                    </div>
                </div>
                <button id="load-more-btn" style="display: none; width: 100%; margin: 10px 0;" class="new-task-button">Load Past 30 Days</button>
                <p id="no-more-tasks-msg" style="display: none; text-align: center; color: var(--primary-light); margin-top: 10px;">No more completed tasks found.</p>
            
                
                <div class="new-task" id="active-task-input-container">
                    <input type="text" class="new-task-input" placeholder="Add a new task..." id="new-task-input">
                    <button class="new-task-button" id="add-task-btn">Add</button>
                </div>

                <div class="new-task" id="completed-task-input-container" style="display: none; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border: 1px dashed var(--secondary);">
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="new-task-input" placeholder="What did you finish offline?" id="offline-task-text">
                        <input type="text" class="new-task-input" style="max-width: 130px;" placeholder="Time (e.g. 1h 20m)" id="offline-task-time">
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="offline-task-keyword" class="new-task-input" style="flex-grow: 1; cursor: pointer;">
                            <option value="">Select Keyword (Optional)</option>
                            </select>
                        <button class="new-task-button" id="add-offline-btn" style="background-color: var(--secondary);">Add Completed</button>
                    </div>
                </div>



                <div class="pomo-toggle-section">
                    <h3>Timer Mode</h3>
                    <div class="mode-selector">
                        <div class="mode-option">
                            <input type="radio" id="timer-mode-normal" name="timer-mode" value="normal" checked onchange="handleTimerModeChange()">
                            <label for="timer-mode-normal">Standard (Count Up)</label>
                        </div>
                        <div class="mode-option">
                            <input type="radio" id="timer-mode-pomodoro" name="timer-mode" value="pomodoro" onchange="handleTimerModeChange()">
                            <label for="timer-mode-pomodoro">Pomodoro (Count Down)</label>
                        </div>
                    </div>
                    <div class="mode-description">
                        Switch between standard daily tracking or Pomodoro sessions.
                    </div>
                </div>

                <!-- Minimal Mode Toggle -->
                
                <div class="display-mode-section">
                    <h3><span style="opacity:0.6">///</span> Task Flow Control</h3>
                    
                    <div class="mode-selector">
                        <div class="mode-option">
                            <input type="radio" id="mode-static" name="display-mode" value="static" onchange="handleDisplayModeChange()">
                            <label for="mode-static">
                                <span class="icon">ðŸ“„</span>
                                Static List
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-loop-incompleted" name="display-mode" value="loop-incompleted" checked onchange="handleDisplayModeChange()">
                            <label for="mode-loop-incompleted">
                                <span class="icon">âš¡</span>
                                Loop Active
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-loop-all" name="display-mode" value="loop-all" onchange="handleDisplayModeChange()">
                            <label for="mode-loop-all">
                                <span class="icon">ðŸ”„</span>
                                Loop All
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-rotate-incompleted" name="display-mode" value="rotate-incompleted" onchange="handleDisplayModeChange()">
                            <label for="mode-rotate-incompleted">
                                <span class="icon">ðŸ“Œ</span>
                                Pinned Top <br> + looped
                            </label>
                        </div>
                    </div>

                    <div class="mode-description" id="mode-description">
                        Current tasks are displayed in a static list.
                    </div>
                </div> <div class="minimal-mode-toggle">
                    <h3>Minimal View</h3>
                    <div class="switch-container">
                        <div>
                            <input type="radio" id="mode-normal" name="minimal-mode" value="normal" checked>
                            <label for="mode-normal">Normal</label>
                        </div>
                        <div>
                            <input type="radio" id="mode-minimal" name="minimal-mode" value="minimal">
                            <label for="mode-minimal">Minimal</label>
                        </div>
                    </div>
                </div>
                            


            </div> 
            
        
            <div id="reporting-content-wrapper" style="display: none;">
                <!-- Guest mode reporting message -->
                <div id="guest-reporting-message" class="guest-reporting-message" style="display: none;">
                    <h3>Reporting Features</h3>
                    <p>Please sign in to access reporting features.</p>
                    <p>Guest mode only allows task management. Sign up or log in to view statistics, streaks, and insights.</p>
                </div>
                
                <!-- Regular reporting content (hidden for guests) -->
                <div id="authenticated-reporting-content">
                    <div class="section-header">
                        <h2>Your Statistics</h2>
                    </div>
                    
                    <div class="reporting-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="report-current-streak">0</div>
                            <div class="stat-label">Current Streak</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="report-longest-streak">0</div>
                            <div class="stat-label">Longest Streak</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="report-total-completed">0</div>
                            <div class="stat-label">Total Tasks Completed</div>
                        </div>
                        <!-- Total Hours in Reporting -->
                        <div class="stat-card">
                            <div class="stat-value" id="report-total-hours">0</div>
                            <div class="stat-label">Total Hours</div>
                        </div>
                    </div>

                    <!--  Insights Section -->
                    <div class="insights-section">
                        <h3>AI Insights</h3>
                        <button id="generate-insights-btn">Generate AI Insights</button>
                        <div id="insights-loading">
                            <p>Generating insights... This may take a few moments.</p>
                        </div>
                        <div id="insights-result"></div>
                    </div>

                    <!--  Flex container for Calendar and Keyword Chart -->
                    <div class="reporting-flex-container">
                        
                        <!--  Streak Calendar -->
                        <div class="streak-calendar-container">
                            <div class="streak-calendar-header">
                                <h3>Streak Calendar</h3>
                                <div class="calendar-nav">
                                    <button class="calendar-nav-btn" id="prev-month-btn">&lt;</button>
                                    <span class="current-month" id="current-month-display">January 2023</span>
                                    <button class="calendar-nav-btn" id="next-month-btn">&gt;</button>
                                </div>
                            </div>
                            
                            <div class="calendar-grid" id="calendar-days-header">
                                <div class="calendar-day-header">Sun</div>
                                <div class="calendar-day-header">Mon</div>
                                <div class="calendar-day-header">Tue</div>
                                <div class="calendar-day-header">Wed</div>
                                <div class="calendar-day-header">Thu</div>
                                <div class="calendar-day-header">Fri</div>
                                <div class="calendar-day-header">Sat</div>
                            </div>
                            
                            <div class="calendar-grid" id="calendar-days"></div>
                            
                            <div class="streak-stats">
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-current">0 days</div>
                                    <div class="streak-label">Current Streak</div>
                                </div>
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-longest">0 days</div>
                                    <div class="streak-label">Longest Streak</div>
                                </div>
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-total">0 days</div>
                                    <div class="streak-label">Total Streak Days</div>
                                </div>
                            </div>
                        
                            <div class="streak-legend">
                                <div class="legend-item">
                                    <div class="legend-color legend-streak"></div>
                                    <span>Task Completed</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color legend-frozen"></div>
                                    <span>Streak Frozen</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color legend-today"></div>
                                    <span>Today</span>
                                </div>
                            </div>
                        </div>

                        <!--  Time Spent Per Keyword Chart -->
                        <div class="chart-container" style="margin-top: 60px !important;">
                            <h3>Time Spent Per Keyword (Completed Tasks)</h3> 
                            <div style="position: relative; flex: 1; min-height: 0; width: 100%;">
                                <canvas id="time-per-keyword-chart"></canvas>
                            </div>
                        </div>
                    </div>


                    <!-- Daily Progress Chart -->
                    <div class="chart-container" style="margin-top: 20px; margin-bottom: 80px;">
                        <h3>Daily Progress</h3>
                        
                        <div class="mode-selector" style="margin-bottom: 10px; justify-content: center;">
                            <div class="mode-option">
                                <input type="radio" id="metric-time" name="daily-progress-metric" value="time" >
                                <label for="metric-time">Time Spent</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="metric-tasks" name="daily-progress-metric" value="tasks" checked>>
                                <label for="metric-tasks">Tasks Completed</label>
                            </div>
                        </div>

                        <div class="mode-selector" style="margin-bottom: 15px; justify-content: center; font-size: 0.8rem;">
                            <div class="mode-option">
                                <input type="radio" id="range-7" name="daily-progress-range" value="7" checked>
                                <label for="range-7">7 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-30" name="daily-progress-range" value="30">
                                <label for="range-30">30 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-90" name="daily-progress-range" value="90">
                                <label for="range-90">90 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-365" name="daily-progress-range" value="365">
                                <label for="range-365">1 Year</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-lifetime" name="daily-progress-range" value="lifetime">
                                <label for="range-lifetime">Lifetime</label>
                            </div>
                        </div>

                        <canvas id="daily-progress-chart"></canvas>
                    </div>    
        
                    <!-- Cumulative Tasks Chart -->
                    <div class="chart-container" style="margin-top: 20px;">
                        <h3>Cumulative Tasks Completed Over Time</h3>
                        <canvas id="cumulative-tasks-chart"></canvas>
                    </div>
                    
                    <div class="chart-container" style="margin-top: 20px;">
                        <h3>Cumulative Time Spent Over Time (Hours)</h3>
                        <canvas id="cumulative-time-chart"></canvas>
                    </div>
                    
                </div>
            </div> 
   
        </div> 
    </div>








        <div class="footer">
            <p id="timestamp">Updated: --</p>
        </div>
    </div>

    <div class="keyword-management" id="keyword-management">
        <div class="keyword-management-content">
            <div class="keyword-management-header">
                <h3>Manage Keywords</h3>
                <button class="close-keyword-management" id="close-keyword-management">&times;</button>
            </div>
            <div class="keyword-list" id="keyword-list-manager"></div>
            <div class="new-keyword-input">
                <input type="text" id="new-keyword-input" placeholder="Add a new keyword...">
                <button id="add-new-keyword-btn">Add</button>
            </div>
        </div>
    </div>

    <!-- Firebase Functions Script -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-functions-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDEEMO9MlcNsb_QLIRTDJM4rXqxGZuYJps",
            authDomain: "obs-todo-68da2.firebaseapp.com",
            databaseURL: "https://obs-todo-68da2-default-rtdb.firebaseio.com",
            projectId: "obs-todo-68da2",
            storageBucket: "obs-todo-68da2.firebasestorage.app",
            messagingSenderId: "594250582895",
            appId: "1:594250582895:web:62414c9f759b99904cb69a",
            measurementId: "G-N94MD8GRJQ"
        };

        let useFirebase = false;
        try {
            if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                firebase.initializeApp(firebaseConfig);
                useFirebase = true;
            }
        } catch (err) {
            console.warn('Firebase init failed, falling back to localStorage:', err);
            useFirebase = false;
        }

        


        // DOM elements
        const taskListEl = document.getElementById('task-list');
        const tasksContainer = document.getElementById('tasks-container');
        const conveyorContainer = document.getElementById('conveyor-container');
        const conveyorTrack = document.getElementById('conveyor-track');
        const inputEl = document.getElementById('new-task-input');
        const addBtn = document.getElementById('add-task-btn');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const completedCount = document.getElementById('completed-count');
        const remainingCount = document.getElementById('remaining-count');
        const timestampEl = document.getElementById('timestamp');
        const tabs = document.querySelectorAll('.tab');
        const dailyTotalEl = document.getElementById('daily-total');
        const lifetimeTotalEl = document.getElementById('lifetime-total');
        const manageKeywordsBtn = document.getElementById('manage-keywords-btn');
        const keywordManagement = document.getElementById('keyword-management');
        const closeKeywordManagement = document.getElementById('close-keyword-management');
        const keywordListManager = document.getElementById('keyword-list-manager');
        const newKeywordInput = document.getElementById('new-keyword-input');
        const addNewKeywordBtn = document.getElementById('add-new-keyword-btn');

        //  Authentication DOM elements
        const loginContainer = document.getElementById('login-container');
        const dashboardWrapper = document.getElementById('dashboard-wrapper');
        const logoutBtn = document.getElementById('logout-btn');
        const signupForm = document.getElementById('signup-form');
        const loginForm = document.getElementById('login-form');
        const signupEmail = document.getElementById('signup-email');
        const signupPassword = document.getElementById('signup-password');
        const loginEmail = document.getElementById('login-email');
        const loginPassword = document.getElementById('login-password');
        const guestBtn = document.getElementById('guest-btn');
        const userStatusEl = document.getElementById('user-status');
        const toggleUserStatusBtn = document.getElementById('toggle-user-status-btn');

        // Password Reset DOM elements
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const passwordResetContainer = document.getElementById('password-reset-container');
        const passwordResetForm = document.getElementById('password-reset-form');
        const resetEmail = document.getElementById('reset-email');
        const resetPasswordBtn = document.getElementById('reset-password-btn');
        const backToLoginBtn = document.getElementById('back-to-login-btn');
        const resetMessage = document.getElementById('reset-message');

        // Content wrapper DOM elements
        const taskContentWrapper = document.getElementById('task-content-wrapper');
        const reportingContentWrapper = document.getElementById('reporting-content-wrapper');

        const loadMoreBtn = document.getElementById('load-more-btn');
        const noMoreTasksMsg = document.getElementById('no-more-tasks-msg');

        const guestReportingMessage = document.getElementById('guest-reporting-message');
        const authenticatedReportingContent = document.getElementById('authenticated-reporting-content');

        // Streak Calendar DOM elements
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const currentMonthDisplayEl = document.getElementById('current-month-display');
        const calendarDaysEl = document.getElementById('calendar-days');
        const streakCurrentEl = document.getElementById('streak-current');
        const streakLongestEl = document.getElementById('streak-longest');
        const streakTotalEl = document.getElementById('streak-total');

        // Total Hours DOM elements
        const totalHoursEl = document.getElementById('total-hours');
        const reportTotalHoursEl = document.getElementById('report-total-hours');

        // Insights DOM elements
        const generateInsightsBtn = document.getElementById('generate-insights-btn');
        const insightsLoading = document.getElementById('insights-loading');
        const insightsResult = document.getElementById('insights-result');

        // App state
        let tasks = {};
        let dbRef = null;
        let currentTab = 'active'; 
        let completedDaysRange = 1; 
        let timerIntervals = {};
        let dragSrcEl = null;
        let editingTaskId = null;
        let editingKeywordIndex = null;
        let expandedTasks = {}; 
        // Add this variable with your other app state variables
        let masterAnimationFrame = null;
        let lastFrameTime = 0;

        // Display mode variables
        let displayMode = 'static';
        let conveyorInterval = null;
        let conveyorTasks = [];
        let conveyorPosition = 0;
        let isConveyorPaused = false;
        let conveyorSpeed = 50; 

        

        // Default keywords
        let keywords = ['Work', 'Personal', 'Urgent', 'Important', 'Shopping'];

        // Chart variables
        let timePerKeywordChart = null;
        let cumulativeTasksChart = null; 
        let cumulativeTimeChart = null; 
        let dailyProgressChart = null; 


        // Authentication state
        let currentUser = null;
        let currentUserId = null;
        let isGuest = false;

        // Minimal mode state
        let minimalMode = false;

        // --- STREAK CALENDAR VARIABLES ---
        let currentCalendarDate = new Date();
        let streakData = {}; 
        let frozenStreakDays = {}; 

        // --- POMODORO STATE ---
        let isPomodoroMode = false;
        let pomoState = 'IDLE'; // 'IDLE', 'WORK', 'BREAK', 'PAUSED'
        let pomoDurationMins = 25;
        let pomoBreakMins = 5;
        let pomoTimeLeft = 25 * 60 * 1000; // ms
        let pomoAccumulatedContribution = 0; // Seconds tracked for stats
        let lastPomoTick = 0;
        let pomoEndTime = null;
        let lastUiUpdate = 0;



        const alarmSound = document.getElementById('pomo-alarm');



        function setupModeListeners() {
            if (!useFirebase || !currentUserId || isGuest) return;

            // 1. Listen for Display Mode Changes (Static, Loop, etc.)
            firebase.database().ref('users/' + currentUserId + '/displayMode').on('value', snap => {
                const newMode = snap.val();
                // Only act if the mode is actually different from what we have
                if (newMode && newMode !== displayMode) {
                    console.log("Remote display mode change detected:", newMode);
                    displayMode = newMode;
                    
                    // Update the Radio Button UI
                    const radio = document.getElementById(`mode-${displayMode}`);
                    if (radio) radio.checked = true;
                    
                    // Update Text Description
                    updateModeDescription();
                    
                    // Reset/Restart Conveyor Logic
                    stopConveyor();
                    
                    // Reset conveyor logic based on new mode
                    if (displayMode !== 'static' && currentTab === 'active') {
                        initConveyor();
                    } else {
                        conveyorContainer.classList.remove('conveyor-container');
                        conveyorTrack.style.transform = 'translateY(0)';
                        renderTasks();
                    }
                    
                    // Trigger OBS refresh
                    triggerObsRefresh();
                }
            });

            // 2. Listen for Minimal Mode Changes
            firebase.database().ref('users/' + currentUserId + '/minimalMode').on('value', snap => {
                const newMinimal = snap.val();
                // Only act if changed
                if (newMinimal !== null && newMinimal !== minimalMode) {
                    console.log("Remote minimal mode change detected:", newMinimal);
                    minimalMode = newMinimal;
                    
                    // Update UI
                    const radio = document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`);
                    if (radio) radio.checked = true;
                    
                    applyMinimalMode();
                }
            });
        }










        // --- POMODORO LOGIC ---

        function handleTimerModeChange() {
            const mode = document.querySelector('input[name="timer-mode"]:checked').value;
            isPomodoroMode = (mode === 'pomodoro');

            const normalContainer = document.getElementById('normal-timer-container');
            const pomoContainer = document.getElementById('pomodoro-container');

            if (isPomodoroMode) {
                normalContainer.style.display = 'none';
                pomoContainer.style.display = 'flex';
            } else {
                normalContainer.style.display = 'flex';
                pomoContainer.style.display = 'none';
                // Optional: Pause pomodoro if switching away
                if (pomoState === 'WORK' || pomoState === 'BREAK') {
                    togglePomodoroAction(); 
                }
            }
        }

        function selectPomoDuration(mins) {
            if (pomoState === 'WORK' || pomoState === 'BREAK') return; // Lock while running

            pomoDurationMins = mins;
            pomoBreakMins = (mins === 25) ? 5 : 10;
            
            // Visual update for buttons
            document.getElementById('btn-25').classList.toggle('active-opt', mins === 25);
            document.getElementById('btn-50').classList.toggle('active-opt', mins === 50);
            
            resetPomodoro();
        }

        function resetPomodoro() {
            pomoState = 'IDLE';
            pomoTimeLeft = pomoDurationMins * 60 * 1000;
            pomoAccumulatedContribution = 0;
            
            updatePomoDisplay();
            document.getElementById('pomo-action-btn').textContent = 'â–¶';
            document.getElementById('pomo-status-label').textContent = 'Ready to Focus';
            document.getElementById('pomo-timer-display').style.color = 'var(--accent)';
        }

        function togglePomodoroAction() {
            const btn = document.getElementById('pomo-action-btn');
            const label = document.getElementById('pomo-status-label');
            
            if (pomoState === 'IDLE' || pomoState === 'PAUSED') {
                // START or RESUME
                if (pomoState === 'IDLE') {
                    // Starting fresh work session
                    pomoState = 'WORK';
                    pomoTimeLeft = pomoDurationMins * 60 * 1000;
                    pomoAccumulatedContribution = 0;
                } else {
                    // Resuming
                    if (label.textContent.includes('Break')) {
                        pomoState = 'BREAK';
                    } else {
                        pomoState = 'WORK';
                    }
                }
                
                // --- NEW: Set the absolute End Time based on current time + remaining time ---
                pomoEndTime = Date.now() + pomoTimeLeft; 

                btn.textContent = 'âšâš';
                label.textContent = (pomoState === 'WORK') ? 'Focusing...' : 'Break Time';
                
                // Ensure Loop is running
                if (!masterAnimationFrame) startMasterLoop();
                
            } else {
                // PAUSE
                pomoState = 'PAUSED';
                
                // --- NEW: Clear the End Time so we don't keep counting while paused ---
                pomoEndTime = null;

                btn.textContent = 'â–¶';
                label.textContent = (label.textContent.includes('Break')) ? 'Break Paused' : 'Work Paused';
                
                // Optional: We can try to stop the loop here if no other timers are running to save resources
                // But leaving it running is safer to prevent bugs.
            }
}

       function updatePomodoro(deltaTime) {
            if (!isPomodoroMode) return;
            if (pomoState !== 'WORK' && pomoState !== 'BREAK') return;

            // --- NEW: Calculate time based on absolute timestamp ---
            if (pomoEndTime) {
                const now = Date.now();
                pomoTimeLeft = pomoEndTime - now;
            } else {
                // Fallback (shouldn't usually happen if toggle sets endTime correctly)
                pomoTimeLeft -= deltaTime; 
            }

            // --- SMART TIME TRACKING LOGIC ---
            // Only accumulate "Pomo Time" if NO other tasks are running
            // And only during WORK phase
            if (pomoState === 'WORK') {
                if (Object.keys(timerIntervals).length === 0) {
                    // Convert ms to seconds for accumulation
                    pomoAccumulatedContribution += (deltaTime / 1000);
                }
            }
            
            // Check for completion
            if (pomoTimeLeft <= 0) {
                pomoTimeLeft = 0;
                pomoEndTime = null; // Clear the target time
                completePomodoroPhase();
            }

            updatePomoDisplay();
            // Force update global stats so "Today" timer updates in real-time with Pomo contribution
            updateTimeStats(); 
        }


        function updatePomoDisplay() {
            const totalSeconds = Math.ceil(pomoTimeLeft / 1000);
            const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            document.getElementById('pomo-timer-display').textContent = `${m}:${s}`;
        }

        function playThreeTimes(audio) {
            let count = 0;
            
            // Reset audio to start (just in case)
            audio.currentTime = 0;
            
            // 1. Define what happens when audio ends
            audio.onended = () => {
                count++;
                if (count < 3) {
                    audio.currentTime = 0;
                    audio.play().catch(() => {});
                } else {
                    // IMPORTANT: Clean up! Remove the listener so it doesn't 
                    // interfere if you click the button again later.
                    audio.onended = null; 
                }
            };

    // 2. Start the first play
    audio.play().catch(() => {});
}

        function completePomodoroPhase() {
            // 1. Audio & Visuals
            playThreeTimes(alarmSound);
            document.body.classList.add('pomo-finished-anim');
            setTimeout(() => document.body.classList.remove('pomo-finished-anim'), 2000);

            const btn = document.getElementById('pomo-action-btn');
            const label = document.getElementById('pomo-status-label');
            const display = document.getElementById('pomo-timer-display');

            if (pomoState === 'WORK') {
                // --- WORK FINISHED ---
                
                // 1. Save the Task
                savePomodoroTask();
                
                // 2. Switch to Break
                pomoState = 'BREAK';
                pomoTimeLeft = pomoBreakMins * 60 * 1000;
                
                label.textContent = 'Break Time!';
                display.style.color = 'var(--secondary)'; // Green for break
                
            } else {
                // --- BREAK FINISHED ---
                pomoState = 'IDLE';
                btn.textContent = 'â–¶';
                label.textContent = 'Session Complete';
                display.style.color = 'var(--accent)';
                resetPomodoro();
            }
        }

        function savePomodoroTask() {
            // Create a completed task with the accumulated time
            const timeSpent = Math.floor(pomoAccumulatedContribution);
            
            // If 0 time was contributed (because user ran other tasks the whole time),
            // we still save it as a record, but timeSpent is 0.
            
            const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `pomo-${Date.now()}`;
            
            const newTask = {
                text: `Pomodoro Session (${pomoDurationMins} min)`,
                completed: true,
                completedAt: new Date().toISOString(),
                createdAt: new Date().toISOString(),
                order: 0,
                timeSpent: timeSpent, 
                timerStartTime: null,
                lastUpdated: new Date().toISOString(),
                keywords: ['Pomodoro'] 
            };
            
            if (useFirebase && !isGuest) {
                dbRef.child(newTaskId).set(newTask);
            } else {
                tasks[newTaskId] = newTask;
                saveAllTasks();
                renderTasks(); // Update list
            }
            
            // Reset accumulation so we don't double count visually until next session
            pomoAccumulatedContribution = 0;
        }




           // Add this variable outside the function to track UI updates

        function startMasterLoop() {
            if (masterAnimationFrame) cancelAnimationFrame(masterAnimationFrame);
            lastFrameTime = performance.now();
            
            function loop(timestamp) {
                const deltaTime = timestamp - lastFrameTime;
                lastFrameTime = timestamp;

                // 1. Conveyor Logic (KEEPS RUNNING EVERY FRAME = SMOOTH)
                if (displayMode !== 'static' && !isConveyorPaused && conveyorTasks.length > 0) {
                    moveConveyor(deltaTime); 
                }

                // 2. Update Logic (Math calculations run every frame)
                updatePomodoro(deltaTime);

                // 3. UI UPDATES (THROTTLED)
                // Only update the text on screen if 1 second has passed
                if (timestamp - lastUiUpdate >= 1000) {
                    
                    // Update Normal Task Timers
                    Object.keys(timerIntervals).forEach(taskId => {
                        updateTaskDisplay(taskId);
                    });

                    // Update Pomodoro Display text (if needed)
                    if (isPomodoroMode) {
                        updatePomoDisplay();
                    }

                    lastUiUpdate = timestamp;
                }

                masterAnimationFrame = requestAnimationFrame(loop);
            }
            
            masterAnimationFrame = requestAnimationFrame(loop);
        }
                    


        

        function stopMasterLoop() {
            if (masterAnimationFrame) {
                cancelAnimationFrame(masterAnimationFrame);
                masterAnimationFrame = null;
            }
        }
        
        // --- New Function to Toggle User Status Visibility ---
        function toggleUserStatus() {
            // Check if it currently has the hidden-status class
            const isHidden = userStatusEl.classList.contains('hidden-status');
            
            if (isHidden) {
                // SHOW: Remove hidden class and add visible class
                userStatusEl.classList.remove('hidden-status');
                userStatusEl.classList.add('visible-status');
                // Change icon to 'unlocked/open eye'
                toggleUserStatusBtn.textContent = 'ðŸ‘ï¸'; 
                toggleUserStatusBtn.title = 'Hide User Status';
                
                // Ensure the correct text color is set for visibility
                if (isGuest) {
                    userStatusEl.style.color = "var(--accent)";
                } else {
                    userStatusEl.style.color = "var(--primary-light)";
                }
                
            } else {
                // HIDE: Remove visible class and add hidden class
                userStatusEl.classList.remove('visible-status');
                userStatusEl.classList.add('hidden-status');
                // Change icon to 'locked/closed eye'
                toggleUserStatusBtn.textContent = 'ðŸ”’'; 
                toggleUserStatusBtn.title = 'Show User Status';
                
                // The CSS handles changing the color to transparent
            }
        }
        // Utility function to check if a date is today
        function isToday(date) {
            const today = new Date();
            const checkDate = new Date(date);
            return checkDate.getDate() === today.getDate() &&
                   checkDate.getMonth() === today.getMonth() &&
                   checkDate.getFullYear() === today.getFullYear();
        }

        // --- Reporting Helper Functions ---
        // Helper function to check if two dates are the same day
        function isSameDay(d1, d2) {
            const date1 = new Date(d1);
            const date2 = new Date(d2);
            return date1.getFullYear() === date2.getFullYear() &&
                    date1.getMonth() === date2.getMonth() &&
                    date1.getDate() === date2.getDate();
        }

        // Helper function to add days to a date
        function addDays(date, days) {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        }

        // Function to trigger OBS refresh
        function triggerObsRefresh() {
            const now = new Date().getTime();
            window.location.hash = `refresh=${now}`;
        }
        
        // Format date for display
        function formatDate(date) {
            const d = new Date(date);
            const now = new Date();
            const diffTime = now.getTime() - d.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return `Today at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else if (diffDays === 1) {
                return `Yesterday at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else {
                return `${d.toLocaleDateString()} at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            }
        }

        // Timer functions
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Format time in hours
        function formatTimeInHours(seconds) {
            const hours = (seconds / 3600).toFixed(1);
            return `${hours} hours`;
        }

        // Updated timer functions for more accurate display
        function startTimer(taskId) {
            if (timerIntervals[taskId]) return; // Timer already running
            
            const task = tasks[taskId];
            if (!task.timerStartTime) {
                task.timerStartTime = Date.now();
            }
            
            // We use the ID as a flag that the timer is running
            // We DO NOT set a display interval here anymore, the MasterLoop handles it
            timerIntervals[taskId] = {
                // Only save to storage every 10 seconds to prevent lag/stutter
                storageInterval: setInterval(() => {
                    const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                    if (elapsed > 0) {
                        // Silently update local object
                        task.timeSpent = (task.timeSpent || 0) + elapsed;
                        task.timerStartTime = Date.now();
                        
                        // Save silently (without re-rendering)
                        if (useFirebase && !isGuest) {
                            // specific update to avoid triggering full listeners if possible
                            dbRef.child(taskId).child('timeSpent').set(task.timeSpent);
                            dbRef.child(taskId).child('timerStartTime').set(task.timerStartTime);
                        } else {
                            localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
                        }
                    }
                }, 10000) // Save every 10 seconds instead of 1
            };
            
            // Visual update immediately
            const btn = document.getElementById(`quick-btn-${taskId}`);
            if(btn) {
                btn.classList.add('running');
                btn.innerHTML = 'âšâš';
                btn.title = 'Pause Timer';
                btn.setAttribute('onclick', `event.stopPropagation(); pauseTimer('${taskId}')`);
            }
            
            // Ensure master loop is running
            if (!masterAnimationFrame) startMasterLoop();
        }

        function pauseTimer(taskId) {
            if (timerIntervals[taskId]) {
                // Clear the storage saver
                clearInterval(timerIntervals[taskId].storageInterval);
                delete timerIntervals[taskId];
                
                const task = tasks[taskId];
                if (task.timerStartTime) {
                    // Calculate final elapsed time
                    const elapsed = (Date.now() - task.timerStartTime) / 1000;
                    task.timeSpent = (task.timeSpent || 0) + elapsed;
                    task.timerStartTime = null;
                }
                
                // Force a save immediately upon pausing
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId); // Final visual update
                updateTimeStats();
                
                // Visual update
                const btn = document.getElementById(`quick-btn-${taskId}`);
                if(btn) {
                    btn.classList.remove('running');
                    btn.innerHTML = 'â–¶';
                    btn.title = 'Start Timer';
                    btn.setAttribute('onclick', `event.stopPropagation(); startTimer('${taskId}')`);
                }
            }
        }
        // Add this missing function so buttons don't crash
        function stopTimer(taskId) {
            pauseTimer(taskId);
        }

        // function to calculate current display time accurately
        function getCurrentDisplayTime(task) {
            if (task.timerStartTime && timerIntervals[task.id]) {
                const elapsedSeconds = (Date.now() - task.timerStartTime) / 1000;
                return (task.timeSpent || 0) + elapsedSeconds;
            } else {
                return task.timeSpent || 0;
            }
        }

        // Time statistics functions
        function calculateDailyTotal() {
            const today = new Date().toDateString();
            let totalSeconds = 0;
            
            // 1. Sum existing tasks
            Object.entries(tasks).forEach(([taskId, task]) => {
                const timeToUse = getCurrentDisplayTime({ ...task, id: taskId });

                if (task.completedAt) {
                    const completedDate = new Date(task.completedAt).toDateString();
                    if (completedDate === today) {
                        totalSeconds += timeToUse;
                    }
                } else if (task.timeSpent && task.lastUpdated) {
                    const lastUpdatedDate = new Date(task.lastUpdated).toDateString();
                    if (lastUpdatedDate === today) {
                        totalSeconds += timeToUse;
                    }
                } else if (timerIntervals[taskId]) { 
                    totalSeconds += timeToUse;
                }
            });
            
            // 2. Add active Pomodoro contribution (Real-time visual update)
            // We only add this if the task hasn't been saved yet (State is WORK or PAUSED)
            if (isPomodoroMode && (pomoState === 'WORK' || pomoState === 'PAUSED')) {
                totalSeconds += Math.floor(pomoAccumulatedContribution);
            }
            
            return totalSeconds;
        }

        function calculateLifetimeTotal() {
            let totalSeconds = 0;
            
            Object.entries(tasks).forEach(([taskId, task]) => {
                if (task.completed) {
                    const timeToUse = getCurrentDisplayTime({ ...task, id: taskId });
                    totalSeconds += timeToUse;
                }
            });
            
            return totalSeconds;
        }

    function updateTimeStats() {
        const dailyTotalSeconds = calculateDailyTotal();
        const lifetimeTotalSeconds = calculateLifetimeTotal();
        const totalHours = (lifetimeTotalSeconds / 3600).toFixed(1);
        
        if (dailyTotalEl) dailyTotalEl.textContent = formatTime(dailyTotalSeconds);
        // Removed lifetimeTotalEl update
        if (totalHoursEl) totalHoursEl.textContent = `${totalHours} hours`;
        if (reportTotalHoursEl) reportTotalHoursEl.textContent = totalHours;
    }

        // Drag and drop functions
        function handleDragStart(e) {
            if (currentTab !== 'active') return;
            
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (dragSrcEl !== this) {
                const taskItems = Array.from(taskListEl.querySelectorAll('.task-item'));
                const srcIndex = taskItems.indexOf(dragSrcEl);
                const destIndex = taskItems.indexOf(this);
                
                if (srcIndex !== -1 && destIndex !== -1) {
                    const taskKeys = Object.keys(tasks).filter(key => !tasks[key].completed);
                    const movedKey = taskKeys[srcIndex];
                    
                    taskKeys.splice(srcIndex, 1);
                    taskKeys.splice(destIndex, 0, movedKey);
                    
                    taskKeys.forEach((key, index) => {
                        tasks[key].order = index;
                    });
                    
                    saveAllTasks();
                    renderTasks();
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('over', 'dragging');
            });
        }


         // Task removal function
        function removeTask(taskId) {
            // OBS FIX: Removed the confirm() check because OBS blocks popups
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).remove();
            } else {
                delete tasks[taskId];
                saveAllTasks();
                renderTasks();
            }
        }
        
        // --- Task Reordering Function ---
        function moveTask(taskId, direction) {
            if (currentTab !== 'active') return; 


            const activeTasks = Object.entries(tasks)
                .filter(([id, task]) => !task.completed)
                .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

            const taskKeys = activeTasks.map(([id]) => id);
            
            // Find the index of the task we're moving
            const currentIndex = taskKeys.indexOf(taskId);

            if (direction === 'up' && currentIndex > 0) {
                [taskKeys[currentIndex], taskKeys[currentIndex - 1]] = [taskKeys[currentIndex - 1], taskKeys[currentIndex]];
            } else if (direction === 'down' && currentIndex < taskKeys.length - 1) {
                [taskKeys[currentIndex], taskKeys[currentIndex + 1]] = [taskKeys[currentIndex + 1], taskKeys[currentIndex]];
            } else {
                return; 
            }

            taskKeys.forEach((key, index) => {
                tasks[key].order = index;
            });

            saveAllTasks();
            renderTasks();
        }

        // Task editing functions
        function startEditingTask(taskId) {
            editingTaskId = taskId;
            renderTasks();
            
            // Focus the input field after a short delay
            setTimeout(() => {
                const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveTaskEdit(taskId) {
            const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
            if (input) {
                const newText = input.value.trim();
                if (newText) {
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ text: newText });
                    } else {
                        tasks[taskId].text = newText;
                        saveAllTasks();
                    }
                }
            }
            editingTaskId = null;
            renderTasks();
        }

        function cancelTaskEdit() {
            editingTaskId = null;
            renderTasks();
        }

        // Keyword functions
        function toggleKeyword(taskId, keyword) {
            const task = tasks[taskId];
            if (!task.keywords) {
                task.keywords = [];
            }
            
            const index = task.keywords.indexOf(keyword);
            if (index === -1) {
                task.keywords.push(keyword);
            } else {
                task.keywords.splice(index, 1);
            }
            
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).update({ keywords: task.keywords });
            } else {
                saveAllTasks();
            }
            renderTasks();
        }

        function removeKeywordFromTask(taskId, keyword) {
            const task = tasks[taskId];
            if (task.keywords) {
                const index = task.keywords.indexOf(keyword);
                if (index !== -1) {
                    task.keywords.splice(index, 1);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                    renderTasks();
                }
            }
        }

        function addNewKeyword(taskId, keywordInputId) {
            const input = document.getElementById(keywordInputId);
            const newKeyword = input.value.trim();
            
            if (newKeyword) {
                if (!keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveKeywords();
                }
                
                const task = tasks[taskId];
                if (!task.keywords) {
                    task.keywords = [];
                }
                if (!task.keywords.includes(newKeyword)) {
                    task.keywords.push(newKeyword);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                }
                
                input.value = '';
                renderTasks();
            }
        }

        function saveKeywords() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/keywords').set(keywords);
            } else {
                localStorage.setItem('obs_todo_keywords', JSON.stringify(keywords));
            }
        }

        function loadKeywords() {
            // 1. Check if we have a user
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/keywords').once('value').then(snap => {
                    const storedKeywords = snap.val();
                    
                    // 2. If we found keywords in the database, use them
                    if (storedKeywords) {
                        keywords = storedKeywords;
                        
                        // 3. IMPORTANT: Force the UI to update immediately!
                        renderTasks();
                        // Also update the manager if it's open
                        if (document.getElementById('keyword-management').classList.contains('visible')) {
                            renderKeywordManager();
                        }
                    }
                });
            } else {
                // LocalStorage logic for Guest/Offline
                const stored = localStorage.getItem('obs_todo_keywords');
                if (stored) {
                    keywords = JSON.parse(stored);
                    renderTasks(); // Force update
                }
            }
        }

        // Display Mode Storage Functions
        function saveDisplayMode() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/displayMode').set(displayMode);
            } else {
                localStorage.setItem('obs_todo_displayMode', displayMode);
            }
        }

        function loadDisplayMode(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/displayMode').once('value').then(snap => {
                    const storedMode = snap.val();
                    if (storedMode) {
                        displayMode = storedMode;
                        document.getElementById(`mode-${displayMode}`).checked = true;
                        updateModeDescription();
                    }
                    if (callback) callback();
                });
            } else {
                const storedMode = localStorage.getItem('obs_todo_displayMode');
                if (storedMode) {
                    displayMode = storedMode;
                    document.getElementById(`mode-${displayMode}`).checked = true;
                    updateModeDescription();
                }
                if (callback) callback();
            }
        }

        // Keyword management functions
        function showKeywordManagement() {
            keywordManagement.classList.add('visible');
            renderKeywordManager();
        }

        function hideKeywordManagement() {
            keywordManagement.classList.remove('visible');
            editingKeywordIndex = null;
        }

        function renderKeywordManager() {
            keywordListManager.innerHTML = '';
            
            keywords.forEach((keyword, index) => {
                const keywordItem = document.createElement('div');
                keywordItem.className = 'keyword-item';
                
                if (editingKeywordIndex === index) {
                    keywordItem.innerHTML = `
                        <input type="text" value="${escapeHtml(keyword)}" id="edit-keyword-${index}">
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="saveKeywordEdit(${index})">âœ“</button>
                            <button class="keyword-item-btn" onclick="cancelKeywordEdit()">âœ—</button>
                        </div>
                    `;
                } else {
                    keywordItem.innerHTML = `
                        <span>${escapeHtml(keyword)}</span>
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="startEditingKeyword(${index})">âœï¸</button>
                            <button class="keyword-item-btn" onclick="removeKeyword(${index})">ðŸ—‘ï¸</button>
                        </div>
                    `;
                }
                
                keywordListManager.appendChild(keywordItem);
            });
        }

        function startEditingKeyword(index) {
            editingKeywordIndex = index;
            renderKeywordManager();
            
            setTimeout(() => {
                const input = document.getElementById(`edit-keyword-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveKeywordEdit(index) {
            const input = document.getElementById(`edit-keyword-${index}`);
            if (input) {
                const newKeyword = input.value.trim();
                if (newKeyword) {
                    const oldKeyword = keywords[index];
                    keywords[index] = newKeyword;
                    
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.keywords && task.keywords.includes(oldKeyword)) {
                            const keywordIndex = task.keywords.indexOf(oldKeyword);
                            task.keywords[keywordIndex] = newKeyword;
                            
                            if (useFirebase && !isGuest) {
                                dbRef.child(taskId).update({ keywords: task.keywords });
                            }
                        }
                    });
                    
                    saveKeywords();
                    saveAllTasks();
                    editingKeywordIndex = null;
                    renderKeywordManager();
                    renderTasks();
                }
            }
        }

        function cancelKeywordEdit() {
            editingKeywordIndex = null;
            renderKeywordManager();
        }

        function removeKeyword(index) {
            const keywordToRemove = keywords[index];
            
            // OBS FIX: Removed the confirm() check because OBS blocks popups
            keywords.splice(index, 1);
            
            Object.keys(tasks).forEach(taskId => {
                const task = tasks[taskId];
                if (task.keywords && task.keywords.includes(keywordToRemove)) {
                    const keywordIndex = task.keywords.indexOf(keywordToRemove);
                    task.keywords.splice(keywordIndex, 1);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    }
                }
            });
            
            saveKeywords();
            saveAllTasks();
            renderKeywordManager();
            renderTasks();
        }

        // Toggle task details visibility
        function toggleTaskDetails(taskId) {
            expandedTasks[taskId] = !expandedTasks[taskId];
            renderTasks();
        }

        
        // Function to update streak data from tasks
        function updateStreakData() {
            streakData = {};
            const allTasks = Object.values(tasks);
            const completedTasks = allTasks.filter(t => t.completed && t.completedAt);
            
            completedTasks.forEach(task => {
                const completionDate = new Date(task.completedAt);
                const dateKey = formatDateKey(completionDate);
                streakData[dateKey] = true;
            });
            
            saveStreakData();
        }
        
        // Format date as YYYY-MM-DD for use as a key
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Save streak data to storage
        function saveStreakData() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/streakData').set(streakData);
            } else {
                localStorage.setItem('obs_todo_streakData', JSON.stringify(streakData));
            }
        }
        
        // Load streak data from storage
        function loadStreakData(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/streakData').once('value').then(snap => {
                    const storedStreakData = snap.val();
                    if (storedStreakData) {
                        streakData = storedStreakData;
                    }
                    if (callback) callback();
                });
            } else {
                const storedStreakData = localStorage.getItem('obs_todo_streakData');
                if (storedStreakData) {
                    streakData = JSON.parse(storedStreakData);
                }
                if (callback) callback();
            }
        }
        
        // Render the streak calendar
        function renderStreakCalendar() {
            const calendarDaysEl = document.getElementById('calendar-days');
            const currentMonthDisplayEl = document.getElementById('current-month-display');
            calculateStreakStats();            
            
            // Clear previous calendar
            calendarDaysEl.innerHTML = '';
            
            // Set current month display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ];
            currentMonthDisplayEl.textContent = `${monthNames[currentCalendarDate.getMonth()]} ${currentCalendarDate.getFullYear()}`;
            
            const firstDay = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), 1);
            const lastDay = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth() + 1, 0);
            
            const firstDayOfWeek = firstDay.getDay();
            
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day empty';
                calendarDaysEl.appendChild(emptyDay);
            }
            

            const today = new Date();
            const todayKey = formatDateKey(today);
            
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day';
                dayEl.textContent = day;
                
                const dateKey = formatDateKey(new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), day));
                
                if (dateKey === todayKey) {
                    dayEl.classList.add('today');
                }
                
                const dayOfWeek = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), day).getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    dayEl.classList.add('weekend');
                }
                
                if (streakData[dateKey]) {
                    dayEl.classList.add('has-streak');
                } else if (frozenStreakDays[dateKey]) { 
                    dayEl.classList.add('has-frozen-streak'); 
                }
                
                calendarDaysEl.appendChild(dayEl);
            }
            
           
        }
        
        // Calculate streak statistics
        function calculateStreakStats() {
            frozenStreakDays = {}; 
            const today = new Date();
            const todayKey = formatDateKey(today);
            
            const streakDates = Object.keys(streakData)
                .map(key => new Date(key))
                .sort((a, b) => a - b);
            
           
            
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayKey = formatDateKey(yesterday);
            
            let currentStreakStartDate = null;
            
            if (streakData[todayKey]) {
                currentStreakStartDate = new Date(today);
            } else if (streakData[yesterdayKey]) {
                currentStreakStartDate = new Date(yesterday);
            } else {
                currentStreakStartDate = null;
            }

            let currentStreak = 0;
            
            if (currentStreakStartDate) {
                currentStreak = 1; 
                let dateToScan = new Date(currentStreakStartDate);
                dateToScan.setDate(dateToScan.getDate() - 1); 
                
                while (true) {
                    const scanKey = formatDateKey(dateToScan);
                    
                    if (streakData[scanKey]) {
                        currentStreak++;
                    } else {
                        const dayBeforeScan = new Date(dateToScan);
                        dayBeforeScan.setDate(dayBeforeScan.getDate() - 1);
                        const dayBeforeScanKey = formatDateKey(dayBeforeScan);
                        
                        if (streakData[dayBeforeScanKey]) {
                            frozenStreakDays[scanKey] = true; 
                            currentStreak++; 
                            dateToScan = new Date(dayBeforeScan); 
                        } else {
                          
                            break;
                        }
                    }
                    
                    dateToScan.setDate(dateToScan.getDate() - 1);

                    if (streakDates.length > 0 && dateToScan < streakDates[0]) {
                        break;
                    }
                    if ((new Date() - dateToScan) > (365 * 5 * 1000 * 60 * 60 * 24)) { // 5 years
                        break;
                    }
                }
            }
            
            
            // ---  Longest Streak Logic ---
            let longestStreak = 0;
            let tempStreak = 0;
            let prevDate = null;
            
            streakDates.forEach(date => {
                const currentDate = new Date(date);
                
                if (prevDate === null) {
                    // First day in the list
                    tempStreak = 1;
                } else {
                    // Check if dates are consecutive or have one day gap
                    const diffTime = currentDate - prevDate;
                    // Calculate difference in days, rounded to nearest whole number
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                    
                    if (diffDays === 1) {
                        // Consecutive day (e.g., Mon -> Tue)
                        tempStreak++;
                    } else if (diffDays === 2) {
                        // One missed day (e.g., Mon -> Wed). Streak continues.
                        const frozenDate = new Date(prevDate);
                        frozenDate.setDate(prevDate.getDate() + 1);
                        const frozenDateKey = formatDateKey(frozenDate);
                        frozenStreakDays[frozenDateKey] = true;
                        
                        tempStreak++;
                    } else {
                        // Two or more missed days (diffDays > 2). Streak resets.
                        longestStreak = Math.max(longestStreak, tempStreak);
                        tempStreak = 1; // Start new streak from 1
                    }
                }
                prevDate = currentDate; 
            });
            
            // Check the last streak after the loop
            longestStreak = Math.max(longestStreak, tempStreak);

            
            // Update streak display (this part is unchanged)
            document.getElementById('streak-current').textContent = `${currentStreak} day${currentStreak !== 1 ? 's' : ''}`;
            document.getElementById('streak-longest').textContent = `${longestStreak} day${longestStreak !== 1 ? 's' : ''}`;
            document.getElementById('streak-total').textContent = `${Object.keys(streakData).length} day${Object.keys(streakData).length !== 1 ? 's' : ''}`;
            
            // Also update the main reporting stats (this part is unchanged)
            document.getElementById('report-current-streak').textContent = currentStreak;
            document.getElementById('report-longest-streak').textContent = longestStreak;
        }
        
        // Navigate to previous month
        function prevMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderStreakCalendar();
        }
        
        // Navigate to next month
        function nextMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderStreakCalendar();
        }

        // Render functions
        function renderTaskElement(taskId, task) {
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item conveyor-task';
            taskItem.dataset.id = taskId;
            taskItem.draggable = currentTab === 'active' && displayMode === 'static';
            
            if (task.completed) {
                taskItem.classList.add('completed');
            }

            const isExpanded = expandedTasks[taskId];
            
            // --- Logic for order buttons ---
            let orderControlsHTML = '';
            if (currentTab === 'active') {
                // Get all active tasks, sorted by their current order
                const activeTasks = Object.entries(tasks)
                    .filter(([id, task]) => !task.completed)
                    .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
                
                // Find the index of the current task in the sorted list
                const currentIndex = activeTasks.findIndex(([id]) => id === taskId);
                
                // Determine if it's the first or last task
                const isFirst = currentIndex === 0;
                const isLast = currentIndex === activeTasks.length - 1;

                // Create the HTML for the buttons, disabling them if at the top or bottom
                orderControlsHTML = `
                    <div class="task-order-controls">
                        <button class="order-btn order-up" onclick="moveTask('${taskId}', 'up')" ${isFirst ? 'disabled' : ''}>â–²</button>
                        <button class="order-btn order-down" onclick="moveTask('${taskId}', 'down')" ${isLast ? 'disabled' : ''}>â–¼</button>
                    </div>
                `;
            }

            // Keyword related elements
            const keywordsContainer = document.createElement('div');
            keywordsContainer.className = 'keywords-container';
            keywordsContainer.id = `keywords-${taskId}`;
            
            let assignedKeywordsHTML = '';
            if (task.keywords && task.keywords.length > 0) {
                assignedKeywordsHTML = task.keywords.map(k => `
                    <span class="keyword-tag selected">
                        ${escapeHtml(k)}
                        <button class="keyword-remove" onclick="removeKeywordFromTask('${taskId}', '${escapeHtml(k)}')">&times;</button>
                    </span>
                `).join('');
            }
            
            // Available keywords to add
            let availableKeywordsHTML = '';
            
            // We change the loop to include 'index'
            keywords.forEach((keyword, index) => {
                if (!task.keywords || !task.keywords.includes(keyword)) {
                    // We build a container with all 3 buttons
                    availableKeywordsHTML += `
                        <div class="keyword-tag" style="display:inline-flex; align-items:center; padding: 0; background-color: #4a505c;">
                            
                            <span style="padding: 2px 8px; cursor:pointer;" 
                                  title="Add '${escapeHtml(keyword)}' to task"
                                  onclick="toggleKeyword('${taskId}', '${escapeHtml(keyword)}')">
                                + ${escapeHtml(keyword)}
                            </span>
                            
                            <button class="keyword-item-btn" 
                                    title="Rename '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); startEditingKeyword(${index}); showKeywordManagement();">
                                âœï¸
                            </button>
                            
                            <button class="keyword-item-btn" 
                                    title="Remove '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); removeKeyword(${index});">
                                ðŸ—‘ï¸
                            </button>
                        </div>
                    `;
                }
            });

            // Add new keyword input
            const keywordInputId = `keyword-input-${taskId}`;
            const keywordInputHTML = `
                <div class="keyword-input-container">
                    <input type="text" class="keyword-input" id="${keywordInputId}" placeholder="Add new...">
                    <button class="add-keyword-confirm" onclick="addNewKeyword('${taskId}', '${keywordInputId}')">+</button>
                </div>
            `;
            
            keywordsContainer.innerHTML = assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML;
            
            // Updated to use accurate current display time
            const currentDisplayTime = getCurrentDisplayTime({...task, id: taskId});
            
            // Main task content
            let taskContentHTML;
            if (editingTaskId === taskId) {
                // Editing view
                taskContentHTML = `
                    <div class="task-main-content">
                        ${orderControlsHTML}
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        <input type="text" class="task-input" value="${escapeHtml(task.text)}">
                        <div class="task-actions">
                            <button class="action-btn" onclick="saveTaskEdit('${taskId}')">âœ”ï¸</button>
                            <button class="action-btn" onclick="cancelTaskEdit()">âŒ</button>
                        </div>
                    </div>
                `;
            } else {
                // Normal view logic
                const isTimerRunning = !!timerIntervals[taskId];
                
                
                taskContentHTML = `
                    <div class="task-main-content">
                        ${orderControlsHTML}
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        
                        <div class="task-content">
                            <span class="task-text">${escapeHtml(task.text)}</span>
                            
                            <div class="task-timer-row">
                                <span class="timer-display-small" id="timer-${taskId}">
                                    ${formatTime(currentDisplayTime)}
                                </span>
                                ${task.completed && task.completedAt ? 
                                    `<span class="completion-date" style="font-size:0.7rem"> â€¢ ${formatDate(task.completedAt)}</span>` 
                                    : ''}
                            </div>
                        </div>

                        <button class="right-play-btn ${isTimerRunning ? 'running' : ''}" 
                                id="quick-btn-${taskId}"
                                title="${isTimerRunning ? 'Pause Timer' : 'Start Timer'}"
                                onclick="event.stopPropagation(); ${isTimerRunning ? `pauseTimer('${taskId}')` : `startTimer('${taskId}')`}" 
                                ${task.completed ? 'disabled' : ''}>
                            ${isTimerRunning ? 'âšâš' : 'â–¶'}
                        </button>

                        <button class="dropdown-btn ${isExpanded ? 'rotated' : ''}" onclick="toggleTaskDetails('${taskId}')">â–¼</button>
                    </div>
                    
                    <div class="task-details ${isExpanded ? 'visible' : ''}">
                        <div class="task-details-row">
                            <div class="task-actions">
                                <button class="action-btn" onclick="startEditingTask('${taskId}')">âœï¸ Edit</button>
                                <button class="action-btn" onclick="stopTimer('${taskId}')" ${task.completed ? 'disabled' : ''}>â–  Pause </button>
                                <button class="action-btn" onclick="removeTask('${taskId}')">ðŸ—‘ï¸ Delete</button>
                            </div>
                        </div>
                        <div class="keywords-container ${isExpanded ? 'visible' : ''}">
                            ${assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML}
                        </div>
                    </div>
                `;
            }
            
            taskItem.innerHTML = taskContentHTML;
            
            // Add drag events only in static mode
            if (currentTab === 'active' && displayMode === 'static') {
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragenter', handleDragEnter);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('dragleave', handleDragLeave);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
            }

            return taskItem;
        }

        function renderTasks() {
            taskListEl.innerHTML = '';
            
            const taskEntries = Object.entries(tasks);
            
            // Filter tasks based on the current tab
            const filteredTasks = taskEntries.filter(([id, task]) => {
                if (currentTab === 'active') {
                    return !task.completed;
                } else {
                    // This is the 'completed' tab logic
                    if (!task.completed || !task.completedAt) return false;
                    
                    const now = new Date();
                    const cutoffDate = new Date(now);
                    // Set cutoffDate to 'completedDaysRange' days ago
                    cutoffDate.setDate(now.getDate() - completedDaysRange);
                    cutoffDate.setHours(0, 0, 0, 0); // Start of that day
                    
                    const completedDate = new Date(task.completedAt);
                    
                    // Show tasks completed on or after the cutoff date
                    return completedDate >= cutoffDate;
                }
            });

            // Sort tasks
            if (currentTab === 'active') {
                // Sort by 'order' property
                filteredTasks.sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            } else {
                // Sort completed tasks by completion time, newest first
                filteredTasks.sort(([, a], [, b]) => new Date(b.completedAt) - new Date(a.completedAt));
            }
            
            if (filteredTasks.length === 0) {
                const message = currentTab === 'active' ? 'No active tasks. Add one below!' : 'No tasks completed today.';
                taskListEl.innerHTML = `<li class="empty-state">${message}</li>`;
            } else {
                filteredTasks.forEach(([id, task]) => {
                    const taskItem = renderTaskElement(id, task);
                    taskListEl.appendChild(taskItem);
                });
            }
            
            updateStats();
            updateTimeStats();
            timestampEl.textContent = `Updated: ${new Date().toLocaleString()}`;
            
            // Initialize conveyor if needed
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            }
        }
        
        // --- Reporting Function ---
        function renderReports() {
            // Show guest message if in guest mode
            if (isGuest) {
                guestReportingMessage.style.display = 'block';
                authenticatedReportingContent.style.display = 'none';
                return;
            } else {
                guestReportingMessage.style.display = 'none';
                authenticatedReportingContent.style.display = 'block';
            }
            
            // Update streak data from current tasks
            updateStreakData();
            
            // Render the streak calendar
            renderStreakCalendar();
            
            const allTasks = Object.values(tasks);
            const completedTasks = allTasks.filter(t => t.completed && t.completedAt);
            
            // --- 1. Calculate Stats ---
            
            // Total Completed
            const totalCompleted = completedTasks.length;
            document.getElementById('report-total-completed').textContent = totalCompleted;

            // Total Hours
            const totalSeconds = calculateLifetimeTotal();
            const totalHours = (totalSeconds / 3600).toFixed(1);
            document.getElementById('report-total-hours').textContent = totalHours;

            // Streak Calculations (already done in calculateStreakStats)
            
            
            // --- 2. Calculate Cumulative Data for Line Charts ---
            const dataByDay = {};
            
            // Sort completed tasks by date, oldest first
            const sortedCompletedTasks = completedTasks.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
            
            // Aggregate data by day
            sortedCompletedTasks.forEach(task => {
                const dateKey = formatDateKey(new Date(task.completedAt));
                if (!dataByDay[dateKey]) {
                    dataByDay[dateKey] = { tasks: 0, time: 0 };
                }
                dataByDay[dateKey].tasks += 1;
                dataByDay[dateKey].time += (task.timeSpent || 0);
            });

            // Get sorted list of all dates from the data
            const sortedDates = Object.keys(dataByDay).sort();
            
            const chartLabels = [];
            const cumulativeTasksData = [];
            const cumulativeTimeData = [];
            
            let cumulativeTasks = 0;
            let cumulativeTime = 0;

            // Create cumulative data points
            sortedDates.forEach(dateKey => {
                cumulativeTasks += dataByDay[dateKey].tasks;
                cumulativeTime += dataByDay[dateKey].time;
                
                chartLabels.push(dateKey);
                cumulativeTasksData.push(cumulativeTasks);
                cumulativeTimeData.push((cumulativeTime / 3600).toFixed(2)); // Convert to hours
            });

            // --- 3. Render Cumulative Tasks Chart ---
            const ctxCumulativeTasks = document.getElementById('cumulative-tasks-chart').getContext('2d');
            if (cumulativeTasksChart) {
                cumulativeTasksChart.destroy();
            }
            cumulativeTasksChart = new Chart(ctxCumulativeTasks, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Total Tasks Completed',
                        data: cumulativeTasksData,
                        backgroundColor: 'rgba(162, 155, 254, 0.2)',
                        borderColor: 'var(--primary-light)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#dfe6e9' }, // FIXED: Hardcoded color
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED: Hardcoded color
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } } // FIXED: Legend text
                    }
                }
            });

            // --- 4. Render Cumulative Time Chart ---
            const ctxCumulativeTime = document.getElementById('cumulative-time-chart').getContext('2d');
            if (cumulativeTimeChart) {
                cumulativeTimeChart.destroy();
            }
            cumulativeTimeChart = new Chart(ctxCumulativeTime, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Total Time Spent (Hours)',
                        data: cumulativeTimeData,
                        backgroundColor: 'rgba(0, 184, 148, 0.2)',
                        borderColor: 'var(--secondary)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: '#dfe6e9', // FIXED
                                callback: (val) => val + 'h' 
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } }, // FIXED
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' hours';
                                }
                            }
                        }
                    }
                }
            });

            // --- 5. Time Spent Per Keyword Chart (UPDATED) ---
            const timePerKeyword = {};
            completedTasks.forEach(task => {
                const time = task.timeSpent || 0;
                if (time > 0) {
                    if (task.keywords && task.keywords.length > 0) {
                        task.keywords.forEach(kw => {
                            timePerKeyword[kw] = (timePerKeyword[kw] || 0) + time;
                        });
                    } else {
                        timePerKeyword['Uncategorized'] = (timePerKeyword['Uncategorized'] || 0) + time;
                    }
                }
            });

            const pieLabels = Object.keys(timePerKeyword);
            const pieData = Object.values(timePerKeyword).map(time => (time / 60).toFixed(2)); 
            
            // Pie chart background colors
            const pieColors = [
                '#6c5ce7', '#a29bfe', '#00b894', '#fd79a8', '#fdcb6e', '#e17055',
                '#0984e3', '#00cec9', '#fab1a0', '#ffeaa7'
            ];
            const backgroundColors = pieLabels.map((_, i) => pieColors[i % pieColors.length]);

            const ctxKeywords = document.getElementById('time-per-keyword-chart').getContext('2d');
            if (timePerKeywordChart) {
                timePerKeywordChart.destroy();
            }
            
            timePerKeywordChart = new Chart(ctxKeywords, {
                type: 'doughnut', // Changed to 'doughnut' for a more modern look (optional, change back to 'pie' if you prefer)
                data: {
                    labels: pieLabels,
                    datasets: [{
                        label: 'Time Spent (in minutes)',
                        data: pieData,
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(0,0,0,0.5)', // Dark border to blend with background
                        borderWidth: 2,
                        hoverOffset: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allows it to fit the container height
                    layout: {
                        padding: 20
                    },
                    plugins: {
                        legend: {
                            position: 'right', // Moves indicators to the right side (Vertical List)
                            align: 'center',   // Centers them vertically
                            labels: {
                                color: 'rgb(223, 230, 233)', // var(--text)
                                padding: 20,      // Adds spacing between rows
                                boxWidth: 15,     // Makes the color boxes smaller and neater
                                font: {
                                    size: 12,
                                    family: "'Segoe UI', sans-serif"
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed + ' minutes';
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            updateDailyProgressChart()
        }




        // --- Daily Progress Chart Function ---
        function updateDailyProgressChart() {
            // Get filter values from radio buttons
            const metric = document.querySelector('input[name="daily-progress-metric"]:checked').value;
            const rangeValue = document.querySelector('input[name="daily-progress-range"]:checked').value;

            // --- 1. Aggregate Data by Day ---
            const dataByDay = {};
            const allCompletedTasks = Object.values(tasks)
                .filter(t => t.completed && t.completedAt);

            allCompletedTasks.forEach(task => {
                const dateKey = formatDateKey(new Date(task.completedAt));
                if (!dataByDay[dateKey]) {
                    dataByDay[dateKey] = { tasks: 0, time: 0 };
                }
                dataByDay[dateKey].tasks += 1;
                dataByDay[dateKey].time += (task.timeSpent || 0);
            });

            // --- 2. Determine Date Range and Labels ---
            const chartLabels = [];
            const chartData = [];
            const today = new Date();
            let startDate;

            if (rangeValue === 'lifetime') {
                // Find the earliest date in the data
                const sortedDates = Object.keys(dataByDay).sort();
                if (sortedDates.length === 0) {
                    // No data, show empty chart for today
                    startDate = new Date(today);
                } else {
                    startDate = new Date(sortedDates[0]);
                }
            } else {
                startDate = new Date(today);
                startDate.setDate(today.getDate() - parseInt(rangeValue) + 1);
            }

            // Set time to beginning of the day for accurate comparison
            startDate.setHours(0, 0, 0, 0);

            // --- 3. Populate Chart Data (Looping from Start Date to Today) ---
            let currentDate = new Date(startDate);
            while (currentDate <= today) {
                const dateKey = formatDateKey(currentDate);

                // Format label 
                const label = currentDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                chartLabels.push(label);

                const dayData = dataByDay[dateKey];

                if (dayData) {
                    if (metric === 'time') {
                        chartData.push((dayData.time / 3600).toFixed(2)); // Time in hours
                    } else {
                        chartData.push(dayData.tasks); // Number of tasks
                    }
                } else {
                    // If no data for this day, push 0
                    chartData.push(0);
                }

                // Move to the next day
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // --- 4. Render the Chart ---
            const ctx = document.getElementById('daily-progress-chart').getContext('2d');
            if (dailyProgressChart) {
                dailyProgressChart.destroy();
            }

            const datasetLabel = metric === 'time' ? 'Time Spent (Hours)' : 'Tasks Completed';
            const yAxisLabel = metric === 'time' ? 'h' : '';
            const tooltipLabel = metric === 'time' ? ' hours' : ' tasks';

            dailyProgressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: datasetLabel,
                        data: chartData,
                        backgroundColor: 'rgba(253, 121, 168, 0.2)',
                        borderColor: 'var(--accent)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: '#dfe6e9', // FIXED
                                callback: (val) => val + yAxisLabel
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } }, // FIXED
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + tooltipLabel;
                                }
                            }
                        }
                    }
                }
            });
        }


        // function for accurate current time display
    function updateTaskDisplay(taskId) {
        const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
        if (taskItem) {
            const task = tasks[taskId];
            
            // Calculate precise time
            let currentTotalSeconds = task.timeSpent || 0;
            if (task.timerStartTime && timerIntervals[taskId]) {
                const elapsed = (Date.now() - task.timerStartTime) / 1000;
                currentTotalSeconds += elapsed;
            }
            
            // 1. Update the Time Text
            const timerEl = taskItem.querySelector(`#timer-${taskId}`);
            if (timerEl) {
                // Check if we are active to avoid unnecessary DOM writes
                if (timerEl.textContent !== formatTime(currentTotalSeconds)) {
                    timerEl.textContent = formatTime(currentTotalSeconds);
                }
            }
        }
    }
        
        function updateStats() {
            const allTasks = Object.values(tasks);
            const activeTasks = allTasks.filter(task => !task.completed);
            const completedTasks = allTasks.filter(task => task.completed && isToday(task.completedAt));
            
            // Count ALL incomplete tasks (not just today's) and today's completed tasks
            const totalIncomplete = activeTasks.length;
            const completedToday = completedTasks.length;
            
            // Progress = completed today / (completed today + total incomplete)
            const totalRelevant = completedToday + totalIncomplete;
            
            let percent = 0;
            if (totalRelevant > 0) {
                percent = Math.round((completedToday / totalRelevant) * 100);
            }
            
            progressFill.style.width = `${percent}%`;
            progressPercent.textContent = `${percent}%`;
            completedCount.textContent = `${completedToday} completed today`;
            remainingCount.textContent = `${totalIncomplete} tasks remaining`;
        }
        
        function escapeHtml(str) {
            return (str || '').replace(/[&<>"']/g, match => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[match]));
        }

        // Task operations
        function addTask() {
            const text = inputEl.value.trim();
            if (text) {
                const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `task-${Date.now()}`;
                const activeTasks = Object.values(tasks).filter(t => !t.completed);
                
                const newTask = {
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    order: activeTasks.length,
                    timeSpent: 0,
                    timerStartTime: null,
                    lastUpdated: new Date().toISOString(),
                    keywords: []
                };
                
                if (useFirebase && !isGuest) {
                    dbRef.child(newTaskId).set(newTask);
                } else {
                    tasks[newTaskId] = newTask;
                    saveAllTasks();
                    renderTasks();
                }
                
                inputEl.value = '';
            }
            
            // Prevent default form submission behavior
            return false;
        }

        function toggleTask(taskId) {
            const task = tasks[taskId];
            task.completed = !task.completed;
            
            if (task.completed) {
                task.completedAt = new Date().toISOString();
                // Stop timer when completing
                stopTimer(taskId);
                // Update streak data when a task is completed
                updateStreakData();
            } else {
                task.completedAt = null;
                // Update streak data when a task is uncompleted
                updateStreakData();
            }
            
            updateTaskInStorage(taskId);
            
            // Re-render all tasks to update stats and lists
            renderTasks();
        }

        // Storage functions
        function updateTaskInStorage(taskId) {
            tasks[taskId].lastUpdated = new Date().toISOString();
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).update(tasks[taskId]);
            } else {
                saveAllTasks();
            }
        }

        function saveAllTasks() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/tasks').set(tasks);
                return;
            }
            if (!useFirebase || isGuest) {
                localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
            }
        }
        // Helper to detect if we really need to re-render the DOM
        function hasStructuralChanges(oldTasks, newTasks) {
            const oldKeys = Object.keys(oldTasks || {});
            const newKeys = Object.keys(newTasks || {});

            // 1. Different number of tasks?
            if (oldKeys.length !== newKeys.length) return true;

            // 2. Check content of each task
            for (let key of newKeys) {
                const oldT = oldTasks[key];
                const newT = newTasks[key];

                // If task didn't exist before
                if (!oldT) return true; 

                // Check properties that affect the VISUAL layout (Order, Text, Completion, Keywords)
                if (oldT.text !== newT.text) return true;
                if (oldT.completed !== newT.completed) return true;
                if (oldT.order !== newT.order) return true;
                
                // Check keywords array comparison
                const oldK = JSON.stringify(oldT.keywords || []);
                const newK = JSON.stringify(newT.keywords || []);
                if (oldK !== newK) return true;
            }

            // If we get here, only 'timeSpent', 'lastUpdated', or 'timerStartTime' changed.
            // These don't require a full DOM destroy/rebuild.
            return false;
        }

        

        function loadTasks() {
            if (useFirebase && currentUserId && !isGuest) {
                // --- NEW: Start listening for mode changes immediately ---
                setupModeListeners(); 

                dbRef = firebase.database().ref('users/' + currentUserId + '/tasks');
                dbRef.on('value', snap => {
                    const newTasks = snap.val() || {};
                    
                    // --- SMART RENDER CHECK (Prevents Conveyor Jumps) ---
                    // If we are using a conveyor belt, check if the update is just a timer tick
                    if (displayMode !== 'static' && !hasStructuralChanges(tasks, newTasks)) {
                        // Update data in memory so timers flow correctly
                        tasks = newTasks;
                        // Update streak data silently
                        updateStreakData();
                        // STOP HERE: Do not re-render the DOM, do not reset conveyor position
                        return; 
                    }
                    // ----------------------------------------------------

                    tasks = newTasks;
                    
                    // Initialize app state
                    loadStreakData(() => {
                        // We only load displayMode ONCE locally for initial setup
                        // The 'setupModeListeners' function handles real-time updates now
                        loadDisplayMode(() => {
                            renderTasks();
                            updateStreakData();
                        });
                    });
                });
            } else {
                // LocalStorage / Guest Logic (Unchanged)
                const storedTasks = localStorage.getItem('obs_todo_tasks');
                tasks = storedTasks ? JSON.parse(storedTasks) : {};
                
                // Cleanup guest tasks
                if (isGuest) {
                    const today = new Date().toDateString();
                    let hasChanges = false;
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.completed && task.completedAt) {
                            if (new Date(task.completedAt).toDateString() !== today) {
                                delete tasks[taskId];
                                hasChanges = true;
                            }
                        }
                    });
                    if (hasChanges) saveAllTasks();
                }
                
                loadStreakData(() => {
                    loadDisplayMode(() => {
                        renderTasks();
                        updateStreakData();
                    });
                });
            }
        }



        // Display Mode Functions - CONVEYOR BELT IMPLEMENTATION
        function handleDisplayModeChange() {
            const selectedMode = document.querySelector('input[name="display-mode"]:checked').value;
            displayMode = selectedMode;
            
            // Save the display mode
            saveDisplayMode();
            
            // Update mode description
            updateModeDescription();
            
            // Stop any existing conveyor and clean up
            stopConveyor();
            
            // Reset conveyor state
            conveyorTasks = [];
            conveyorPosition = 0;
            isConveyorPaused = false;
            
            // Apply the selected mode
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            } else {
                // Reset to normal rendering for static mode
                conveyorContainer.classList.remove('conveyor-container');
                conveyorTrack.style.transform = 'translateY(0)';
                renderTasks();
            }

            // Trigger OBS Refresh by changing the URL hash
            triggerObsRefresh(); 
        }

        function updateModeDescription() {
            const descriptionEl = document.getElementById('mode-description');
            let description = '';
            
            switch(displayMode) {
                case 'static':
                    description = 'Current tasks are displayed in a static list.';
                    break;
                case 'loop-incompleted':
                    description = 'Incompleted tasks will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'loop-all':
                    description = 'All tasks (including completed today) will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'rotate-incompleted':
                    description = 'Incompleted tasks (except the top one) will rotate positions periodically.';
                    break;
            }
            
            descriptionEl.textContent = description;
        }

        
    function initConveyor() {
        // ... (Keep your existing filtering logic for conveyorTasks) ... 
        // Copy the first part of your existing initConveyor function regarding filtering tasks
        // UNTIL you reach the "startConveyor()" line.
        
        // [PASTE YOUR EXISTING FILTERING LOGIC HERE]
        // ...
        conveyorTasks = Object.entries(tasks)
            .filter(([id, task]) => {
                if (displayMode === 'loop-incompleted' || displayMode === 'rotate-incompleted') {
                    return !task.completed;
                } else if (displayMode === 'loop-all') {
                    return !task.completed || (task.completed && isToday(task.completedAt));
                }
                return false;
            })
            .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

        if (conveyorTasks.length === 0) {
            renderTasks();
            return;
        }
        
        conveyorPosition = 0;
        isConveyorPaused = false;
        
        conveyorContainer.classList.add('conveyor-container');
        conveyorTrack.style.transform = 'translateY(0)';
        
        renderConveyorTasks();
        
        // HERE IS THE CHANGE:
        startMasterLoop(); 
    }

    function startConveyor() {
        // Deprecated - logic moved to startMasterLoop
        startMasterLoop();
    }

    function stopConveyor() {
        // Only stop master loop if no timers are running
        if (Object.keys(timerIntervals).length === 0 && pomoState !== 'WORK' && pomoState !== 'BREAK') {
            stopMasterLoop();
        }
        
        // Clean up static container if it exists
        const staticContainer = document.getElementById('static-top-task');
        if (staticContainer) {
            staticContainer.remove();
        }
        
        // Reset container
        taskListEl.innerHTML = '';
        conveyorContainer.classList.remove('conveyor-container');
        conveyorTrack.style.transform = 'translateY(0)';
    }


        function renderConveyorTasks() {
            // Find or create the static container for the fixed top task
            const tasksContainer = document.getElementById('tasks-container');
            const staticTaskContainerId = 'static-top-task';
            let staticContainer = document.getElementById(staticTaskContainerId);

            // Clean up static container if we're NOT in rotate-incompleted mode
            if (displayMode !== 'rotate-incompleted' && staticContainer) {
                staticContainer.remove();
                staticContainer = null;
            }

            // 1. Mode: Rotate Incompleted (Static Top + Moving Conveyor)
            if (displayMode === 'rotate-incompleted' && conveyorTasks.length > 0) {
                
                // Ensure the static container exists
                if (!staticContainer) {
                    staticContainer = document.createElement('div');
                    staticContainer.id = staticTaskContainerId;
                    staticContainer.style.marginBottom = '8px'; // Space between static and moving parts
                    // Insert it before the conveyor-container
                    tasksContainer.insertBefore(staticContainer, conveyorContainer);
                }
                
                // Render the static task (first task in the list)
                const [staticTaskId, staticTask] = conveyorTasks[0];
                const staticTaskItem = renderTaskElement(staticTaskId, staticTask);
                
                // Apply visual cue and remove list margin
                staticTaskItem.style.marginBottom = '0';
                staticTaskItem.style.backgroundColor = 'rgba(255,255,255,.12)';
                
                staticContainer.innerHTML = '';
                staticContainer.appendChild(staticTaskItem);
                
                // Render the moving tasks (all subsequent tasks)
                const movingTasks = conveyorTasks.slice(1);
                taskListEl.innerHTML = '';
                
                if (movingTasks.length === 0) {
                    taskListEl.innerHTML = `<li class="empty-state" style="padding-top:0; padding-bottom:10px;">No other tasks to loop.</li>`;
                } else {
                    movingTasks.forEach(([taskId, task]) => {
                        const taskItem = renderTaskElement(taskId, task);
                        taskListEl.appendChild(taskItem);
                    });
                }
                
                // Ensure conveyor mode is active
                conveyorContainer.classList.add('conveyor-container');

            } else {
                // 2. Mode: Other Loops (Full Moving Conveyor) or Static (Render everything in one list)
                
                // Clean up static container if it exists (this is the key fix)
                if (staticContainer) {
                    staticContainer.remove();
                }

                taskListEl.innerHTML = '';
                conveyorContainer.classList.add('conveyor-container');
                
                if (conveyorTasks.length === 0) {
                    taskListEl.innerHTML = `<li class="empty-state">No tasks to display.</li>`;
                    return;
                }
                
                // Render all tasks for the full conveyor loop
                conveyorTasks.forEach(([taskId, task]) => {
                    const taskItem = renderTaskElement(taskId, task);
                    taskListEl.appendChild(taskItem);
                });
            }
        }
        
    function moveConveyor(deltaTime = 16) { 
        if (conveyorTasks.length === 0) return;

        // Normalize speed: 50px per second
        // deltaTime is in ms. 
        const pixelsPerSecond = conveyorSpeed; 
        const movement = (pixelsPerSecond * deltaTime) / 1000;
        
        conveyorPosition -= movement;

        const trackHeight = conveyorTrack.scrollHeight;
        const containerHeight = conveyorContainer.clientHeight;

        if (Math.abs(conveyorPosition) >= containerHeight) {
            conveyorTrack.style.opacity = '0';
            conveyorTrack.style.transition = 'none';
            conveyorPosition = containerHeight; // Start from bottom
            conveyorTrack.style.transform = `translateY(${conveyorPosition}px)`;
            void conveyorTrack.offsetHeight; 
            setTimeout(() => {
                conveyorTrack.style.transition = '';
                conveyorTrack.style.opacity = '1';
            }, 50);
        } else {
            conveyorTrack.style.transform = `translateY(${conveyorPosition}px)`;
        }
    }

        function handleRotateIncompleted() {
            // For rotate-incompleted mode, we periodically rotate the tasks (except the first one)
            // Check if it's time to rotate (every 5 seconds)
            const now = Date.now();
            if (!window.lastRotateTime) window.lastRotateTime = now;
            
            if (now - window.lastRotateTime > 5000) { // 5 seconds
                window.lastRotateTime = now;
                
                // Get incomplete tasks except the first one
                const incompleteTasks = Object.entries(tasks)
                    .filter(([id, task]) => !task.completed)
                    .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
                
                if (incompleteTasks.length <= 2) return;
                
                // Keep the first task fixed, rotate the rest
                const fixedTask = incompleteTasks[0];
                const tasksToRotate = incompleteTasks.slice(1);
                
                // Rotate the tasks (move first to end)
                const rotatedTasks = [...tasksToRotate.slice(1), tasksToRotate[0]];
                
                // Update the order
                let order = 1; // Start from 1 because 0 is the fixed task
                rotatedTasks.forEach(([id, task]) => {
                    tasks[id].order = order++;
                });
                
                // Save and re-render
                saveAllTasks();
                renderTasks();
            }
        }

        function pauseConveyor() {
            isConveyorPaused = true;
        }

        function resumeConveyor() {
            isConveyorPaused = false;
        }

        // Initialize display mode on page load
        function initializeDisplayMode() {
            // Load display mode from storage (this will set displayMode variable and update radio button)
            loadDisplayMode(() => {
                // If no stored mode, default to 'loop-incompleted'
                if (!displayMode) {
                    displayMode = 'loop-incompleted';
                    document.getElementById('mode-loop-incompleted').checked = true;
                    saveDisplayMode(); // Save the default
                }
                
                // Stop any existing conveyor
                stopConveyor();
                
                // Initialize conveyor for the current mode
                if (currentTab === 'active' && displayMode !== 'static') {
                    initConveyor();
                }
                
                updateModeDescription();
            });
        }

        // --- Authentication Functions ---
        function showLogin() {
            loginContainer.style.display = 'block';
            dashboardWrapper.style.display = 'none';
            passwordResetContainer.style.display = 'none';
        }

        function showDashboard() {
            loginContainer.style.display = 'none';
            dashboardWrapper.style.display = 'block';
            passwordResetContainer.style.display = 'none';
            logoutBtn.style.display = 'inline-block';

            // Get the container of the user status elements
            const userStatusContainer = toggleUserStatusBtn.parentElement;
            
            // Update user status display
            if (isGuest) {
                userStatusEl.textContent = "Guest Mode - Completed tasks will be deleted tomorrow";
                
                
                // FOR GUEST: Make it visible by default
                userStatusEl.classList.remove('hidden-status');
                userStatusEl.classList.add('visible-status');
                userStatusEl.style.color = "#fd79a8"; 

                // Hide the toggle button
                toggleUserStatusBtn.style.display = 'none'; 
                
                // Remove the large margin from the container
                userStatusContainer.style.marginLeft = '0';
                // Center the text (since the button is gone)
                userStatusContainer.style.justifyContent = 'center';


            } else {
                userStatusEl.textContent = `Logged in as ${currentUser.email}`;
                
                // FOR LOGGED-IN USER: Keep the privacy (hidden) default
                userStatusEl.classList.add('hidden-status');
                userStatusEl.classList.remove('visible-status');
                toggleUserStatusBtn.textContent = 'ðŸ”’';

                // Show the button
                toggleUserStatusBtn.style.display = 'inline-block'; 
                
                // Restore the default styles for non-guest mode
                userStatusContainer.style.marginLeft = '100px';
                userStatusContainer.style.justifyContent = 'flex-start'; // Default alignment
            }
        }

        // --- Password Reset Functions ---
        function showPasswordReset() {
            loginContainer.style.display = 'none';
            dashboardWrapper.style.display = 'none';
            passwordResetContainer.style.display = 'block';
            resetMessage.textContent = '';
            resetMessage.className = 'reset-message';
        }

        function handlePasswordReset(e) {
            e.preventDefault();
            const email = resetEmail.value.trim();
            
            if (!email) {
                showResetMessage('Please enter your email address.', 'error');
                return;
            }
            
            if (useFirebase) {
                firebase.auth().sendPasswordResetEmail(email)
                    .then(() => {
                        showResetMessage('Password reset email sent! Check your inbox.', 'success');
                        resetEmail.value = '';
                    })
                    .catch((error) => {
                        let errorMessage = 'Error sending password reset email.';
                        if (error.code === 'auth/user-not-found') {
                            errorMessage = 'No account found with this email address.';
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = 'Invalid email address.';
                        }
                        showResetMessage(errorMessage, 'error');
                    });
            } else {
                // Mock password reset for localStorage mode
                showResetMessage('Password reset functionality requires Firebase authentication.', 'error');
            }
        }

        function showResetMessage(message, type) {
            resetMessage.textContent = message;
            resetMessage.className = `reset-message reset-${type}`;
        }

        function handleSignup(e) {
            e.preventDefault();
            const email = signupEmail.value;
            const password = signupPassword.value;
            
            if (useFirebase) {
                firebase.auth().createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        currentUserId = currentUser.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks(); // Load user-specific tasks
                    })
                    .catch((error) => {
                        const errorDiv = document.getElementById('auth-error-msg');
                        if(errorDiv) errorDiv.textContent = 'Signup error: ' + error.message;
                    });
            } else {
                // Mock authentication for localStorage mode
                currentUser = { email: email };
                currentUserId = 'local_user';
                isGuest = false;
                localStorage.setItem('obs_todo_mock_user', email);
                showDashboard();
                loadTasks();
            }
        }

        function handleLogin(e) {
            e.preventDefault();
            const email = loginEmail.value;
            const password = loginPassword.value;
            
            if (useFirebase) {
                firebase.auth().signInWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        currentUserId = currentUser.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks(); // Load user-specific tasks
                    })
                    .catch((error) => {
                        const errorDiv = document.getElementById('auth-error-msg');
                        if(errorDiv) errorDiv.textContent = 'Login error: ' + error.message;
                    });
            } else {
                // Mock authentication for localStorage mode
                currentUser = { email: email };
                currentUserId = 'local_user';
                isGuest = false;
                localStorage.setItem('obs_todo_mock_user', email);
                showDashboard();
                loadTasks();
            }
        }

        function handleGuestLogin() {
            currentUser = { email: 'guest@example.com' };
            currentUserId = 'guest_user';
            isGuest = true;
            showDashboard();
            loadTasks();
        }

        function handleLogout() {
            if (useFirebase) {
                firebase.auth().signOut();
            }

            listenersInitialized = false;
            
            currentUser = null;
            currentUserId = null;
            isGuest = false;
            localStorage.removeItem('obs_todo_mock_user');
            showLogin();
            // Clear form fields
            signupEmail.value = '';
            signupPassword.value = '';
            loginEmail.value = '';
            loginPassword.value = '';
        }

        function initializeAuth() {
            if (useFirebase) {
                firebase.auth().onAuthStateChanged((user) => {
                    if (user) {
                        currentUser = user;
                        currentUserId = user.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks();
                        loadKeywords(); 
                    } else {
                        showLogin();
                    }
                });
            } else {
                // For localStorage mode, check if we have a mock user
                const mockUser = localStorage.getItem('obs_todo_mock_user');
                if (mockUser) {
                    currentUser = { email: mockUser };
                    currentUserId = 'local_user';
                    isGuest = false;
                    showDashboard();
                    loadTasks();
                    loadKeywords();
                } else {
                    showLogin();
                }
            }
        }

        // --- Generate Insights Function ---
        function generateInsights() {
            const insightsBtn = document.getElementById('generate-insights-btn');
            const loadingDiv = document.getElementById('insights-loading');
            const resultDiv = document.getElementById('insights-result');
            
            // Show loading state
            insightsBtn.disabled = true;
            loadingDiv.style.display = 'block';
            resultDiv.innerHTML = '';
            
            try {
                // Initialize Firebase Functions
                const functions = firebase.functions();
                
                // Reference our function
                const callGenerateInsights = functions.httpsCallable('generateInsights');
                
                // Prepare completed tasks data
                const completedTasks = Object.values(tasks)
                    .filter(task => task.completed && task.completedAt)
                    .map(task => ({
                        text: task.text,
                        completedAt: task.completedAt,
                        timeSpent: task.timeSpent || 0,
                        keywords: task.keywords || []
                    }));
                
                // Prepare stats data
                const stats = {
                    currentStreak: document.getElementById('report-current-streak').textContent,
                    longestStreak: document.getElementById('report-longest-streak').textContent,
                    totalCompleted: document.getElementById('report-total-completed').textContent,
                    totalHours: document.getElementById('report-total-hours').textContent
                };
                
                // Call the function
                callGenerateInsights({ 
                    allCompletedTasks: completedTasks, 
                    stats: stats 
                })
                .then((result) => {
                    // Display the insights with basic formatting
                    resultDiv.innerHTML = marked.parse(result.data.insights);
                })
                .catch((error) => {
                    console.error('Error calling generateInsights:', error);
                    resultDiv.innerHTML = 'Error generating insights: ' + error.message;
                })
                .finally(() => {
                    // Hide loading state
                    insightsBtn.disabled = false;
                    loadingDiv.style.display = 'none';
                });
                
            } catch (error) {
                console.error('Error setting up insights generation:', error);
                resultDiv.innerHTML = 'Error setting up insights generation: ' + error.message;
                insightsBtn.disabled = false;
                loadingDiv.style.display = 'none';
            }
        }

        // --- Minimal Mode Functions ---
        function toggleMinimalMode() {
            const selectedMode = document.querySelector('input[name="minimal-mode"]:checked').value;
            minimalMode = selectedMode === 'minimal';
            
            // Save the minimal mode state
            saveMinimalMode();
            
            // Apply minimal mode
            applyMinimalMode();
        }

        function saveMinimalMode() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/minimalMode').set(minimalMode);
            } else {
                localStorage.setItem('obs_todo_minimalMode', minimalMode);
            }
        }

        function loadMinimalMode(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/minimalMode').once('value').then(snap => {
                    const storedMode = snap.val();
                    if (storedMode !== null) {
                        minimalMode = storedMode;
                        // Update the radio button
                        document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`).checked = true;
                        applyMinimalMode();
                    }
                    if (callback) callback();
                });
            } else {
                const storedMode = localStorage.getItem('obs_todo_minimalMode');
                if (storedMode !== null) {
                    minimalMode = storedMode === 'true';
                    // Update the radio button
                    document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`).checked = true;
                    applyMinimalMode();
                }
                if (callback) callback();
            }
        }

        function applyMinimalMode() {
            if (minimalMode) {
                document.body.classList.add('minimal-mode');
            } else {
                document.body.classList.remove('minimal-mode');
            }
            
            // Trigger OBS Refresh by changing the URL hash
            triggerObsRefresh();
        }

        // Event listeners
        addBtn.addEventListener('click', function(e) {
            e.preventDefault(); // Prevent any default behavior
            addTask();
        });
        inputEl.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Add this line to prevent form submission
                addTask();
            }
        });
        toggleUserStatusBtn.addEventListener('click', toggleUserStatus);

       // --- Tab switching logic ---
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                const selectedTab = tab.dataset.tab;
                editingTaskId = null;

                // Toggle visibility of input fields
                const activeInput = document.getElementById('active-task-input-container');
                const completedInput = document.getElementById('completed-task-input-container');

                if (selectedTab === 'active') {
                    activeInput.style.display = 'flex';
                    completedInput.style.display = 'none';
                } else if (selectedTab === 'completed') {
                    activeInput.style.display = 'none';
                    completedInput.style.display = 'flex';
                    populateOfflineKeywords(); // Fill the dropdown with your keywords
                } else {
                    activeInput.style.display = 'none';
                    completedInput.style.display = 'none';
                }

                // --- Existing Tab Logic ---
                loadMoreBtn.style.display = 'none';
                noMoreTasksMsg.style.display = 'none';

                if (selectedTab === 'active' || selectedTab === 'completed') {
                    taskContentWrapper.style.display = 'block';
                    reportingContentWrapper.style.display = 'none';
                    currentTab = selectedTab;
                    
                    if (currentTab === 'completed') {
                        completedDaysRange = 1; 
                        stopConveyor();
                        const cutoffDate = new Date();
                        cutoffDate.setHours(0, 0, 0, 0);
                        const hasMoreTasks = Object.values(tasks).some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            return new Date(task.completedAt) < cutoffDate;
                        });
                        if (hasMoreTasks) loadMoreBtn.style.display = 'block';
                    } else if (displayMode !== 'static') {
                        initConveyor();
                    }
                    renderTasks();
                } else if (selectedTab === 'reporting') {
                    taskContentWrapper.style.display = 'none';
                    reportingContentWrapper.style.display = 'block';
                    stopConveyor();
                    renderReports();
                }
            });
        });
        function loadMoreCompletedTasks() {
            // Add 30 more days to the range
            completedDaysRange += 30;
            
            // Re-render the task list
            renderTasks();
            
            // Check if there are any tasks *older* than our new range
            const now = new Date();
            const cutoffDate = new Date(now);
            cutoffDate.setDate(now.getDate() - completedDaysRange);
            cutoffDate.setHours(0, 0, 0, 0);

            const hasMoreTasks = Object.values(tasks).some(task => {
                if (!task.completed || !task.completedAt) return false;
                const completedDate = new Date(task.completedAt);
                return completedDate < cutoffDate; // Is there *any* task before the new cutoff?
            });

            // If no more tasks are found, hide the button and show the message
            if (!hasMoreTasks) {
                loadMoreBtn.style.display = 'none';
                noMoreTasksMsg.style.display = 'block';
            }
        }

        loadMoreBtn.addEventListener('click', loadMoreCompletedTasks);
        // --- END OF NEW CODE BLOCK ---

        // Keyword management listeners
        manageKeywordsBtn.addEventListener('click', showKeywordManagement);

        // Keyword management listeners
        manageKeywordsBtn.addEventListener('click', showKeywordManagement);
        closeKeywordManagement.addEventListener('click', hideKeywordManagement);
        addNewKeywordBtn.addEventListener('click', () => {
            const newKeyword = newKeywordInput.value.trim();
            if (newKeyword && !keywords.includes(newKeyword)) {
                keywords.push(newKeyword);
                saveKeywords();
                renderKeywordManager();
                renderTasks(); // Re-render tasks to show new keyword
                newKeywordInput.value = '';
            }
        });
        newKeywordInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                addNewKeywordBtn.click();
            }
        });


        
        // Display mode listeners
        document.addEventListener('DOMContentLoaded', function() {
            const modeRadios = document.querySelectorAll('input[name="display-mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', handleDisplayModeChange);
            });
            
            // Initialize mode description (will be updated by initializeDisplayMode)
            updateModeDescription();
        });

        // Pause conveyor when interacting with tasks
        document.addEventListener('mouseenter', function(e) {
            if (e.target.closest('.task-item') && displayMode !== 'static') {
                pauseConveyor();
            }
        });

        document.addEventListener('mouseleave', function(e) {
            if (e.target.closest('.task-item') && displayMode !== 'static') {
                // Small delay before resuming
                setTimeout(resumeConveyor, 1000);
            }
        });

        // --- Authentication Event Listeners ---
        signupForm.addEventListener('submit', handleSignup);
        loginForm.addEventListener('submit', handleLogin);
        guestBtn.addEventListener('click', handleGuestLogin);
        logoutBtn.addEventListener('click', handleLogout);
        
        // --- Password Reset Event Listeners ---
        forgotPasswordLink.addEventListener('click', showPasswordReset);
        passwordResetForm.addEventListener('submit', handlePasswordReset);
        backToLoginBtn.addEventListener('click', showLogin);
        
        // --- Streak Calendar Event Listeners ---
        prevMonthBtn.addEventListener('click', prevMonth);
        nextMonthBtn.addEventListener('click', nextMonth);

        // --- Event listener for generate insights button ---
        document.addEventListener('DOMContentLoaded', function() {
            const generateInsightsBtn = document.getElementById('generate-insights-btn');
            if (generateInsightsBtn) {
                generateInsightsBtn.addEventListener('click', generateInsights);
            }
            
        });

        // --- Minimal Mode Event Listeners ---
        document.addEventListener('DOMContentLoaded', function() {
            const minimalModeRadios = document.querySelectorAll('input[name="minimal-mode"]');
            minimalModeRadios.forEach(radio => {
                radio.addEventListener('change', toggleMinimalMode);
            });
            
            // Load minimal mode state
            loadMinimalMode();
        });

        // --- Event listeners for Daily Progress Chart filters ---
        document.addEventListener('DOMContentLoaded', () => {
            const progressFilters = document.querySelectorAll('input[name="daily-progress-metric"], input[name="daily-progress-range"]');
            progressFilters.forEach(radio => {
                radio.addEventListener('change', () => {
                    // Only update if the reporting tab is active
                    if (document.querySelector('.tab[data-tab="reporting"]').classList.contains('active')) {
                        updateDailyProgressChart();
                    }
                });
            });
        });

        // Save data when the user closes the window or refreshes
        window.addEventListener('beforeunload', () => {
            // Loop through all running timers and save them
            Object.keys(timerIntervals).forEach(taskId => {
                if (tasks[taskId]) {
                    // Ensure the latest time is captured
                    updateTaskInStorage(taskId);
                }
            });
        });
            

        
        // Initial load
        initializeAuth(); // Initialize authentication instead of directly loading tasks

        // Populates the dropdown menu with your "Managed Keywords"
        function populateOfflineKeywords() {
            const dropdown = document.getElementById('offline-task-keyword');
            const currentValue = dropdown.value;
            dropdown.innerHTML = '<option value="">Select Keyword (Optional)</option>';
            keywords.forEach(kw => {
                const option = document.createElement('option');
                option.value = kw;
                option.textContent = kw;
                dropdown.appendChild(option);
            });
            dropdown.value = currentValue;
        }

        // Converts "1h 30m" or "45m" into total seconds
        function parseTimeString(str) {
            let totalSeconds = 0;
            const hours = str.match(/(\d+)\s*h/);
            const mins = str.match(/(\d+)\s*m/);
            const secs = str.match(/(\d+)\s*s/);
            if (hours) totalSeconds += parseInt(hours[1]) * 3600;
            if (mins) totalSeconds += parseInt(mins[1]) * 60;
            if (secs) totalSeconds += parseInt(secs[1]);
            
            // If user just types a number, assume it's minutes
            if (!hours && !mins && !secs && !isNaN(str) && str !== "") {
                totalSeconds = parseInt(str) * 60;
            }
            return totalSeconds;
        }

        // Saves the offline data to Firebase/LocalStorage
        function addOfflineTask() {
            const textEl = document.getElementById('offline-task-text');
            const timeEl = document.getElementById('offline-task-time');
            const kwEl = document.getElementById('offline-task-keyword');
            
            const text = textEl.value.trim();
            if (!text) return;

            const seconds = parseTimeString(timeEl.value.trim());
            const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `offline-${Date.now()}`;

            const newTask = {
                text: text,
                completed: true,
                completedAt: new Date().toISOString(),
                createdAt: new Date().toISOString(),
                order: 0,
                timeSpent: seconds,
                timerStartTime: null,
                lastUpdated: new Date().toISOString(),
                keywords: kwEl.value ? [kwEl.value] : []
            };

            if (useFirebase && !isGuest) {
                dbRef.child(newTaskId).set(newTask);
            } else {
                tasks[newTaskId] = newTask;
                saveAllTasks();
                renderTasks();
            }

            // Clear fields
            textEl.value = '';
            timeEl.value = '';
            kwEl.value = '';
            updateStreakData();
        }

        // Link the button click and Enter key
        document.getElementById('add-offline-btn').addEventListener('click', addOfflineTask);
        document.getElementById('offline-task-time').addEventListener('keypress', e => {
            if (e.key === 'Enter') addOfflineTask();
        });
    </script>
</body>
</html>
