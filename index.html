<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Task Dashboard (Timer + Reordering)</title>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-light: #a29bfe;
            --secondary: #00b894;
            --background: #2d3436;
            --card: #353b48;
            --text: #dfe6e9;
            --accent: #fd79a8;
            --warning: #fdcb6e;
            --danger: #e17055;
        }
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}
        body{background-color:var(--background);color:var(--text);padding:15px;max-width:900px;margin:0 auto}
        .dashboard{display:flex;flex-direction:column;gap:20px}
        .header{text-align:center;margin-bottom:5px}
        .header h1{color:var(--primary);font-size:1.8rem;margin-bottom:3px}
        .header p{color:var(--primary-light);font-size:0.95rem}
        .focus-section{background-color:var(--card);border-radius:10px;padding:20px;box-shadow:0 4px 15px rgba(0,0,0,.2)}
        .section-header{display:flex;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary)}
        .section-header h2{font-size:1.4rem;margin-left:10px}
        .tabs-container{display:flex;border-bottom:2px solid var(--primary);margin-bottom:15px}
        .tab{flex:1;text-align:center;padding:10px 0;cursor:pointer;transition:all 0.3s;border-bottom:2px solid transparent}
        .tab.active{color:var(--primary);border-bottom-color:var(--primary);font-weight:bold}
        .tab:hover:not(.active){background-color:rgba(255,255,255,0.05)}
        .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;color:white;font-weight:bold;background-color:var(--accent)}
        .task-list{list-style-type:none;margin-bottom:20px}
        .task-item{display:flex;align-items:center;padding:12px 10px;margin-bottom:8px;background-color:rgba(255,255,255,.05);border-radius:8px;transition:all .3s;cursor:grab;}
        .task-item:hover{background-color:rgba(255,255,255,.1)}
        .task-item.dragging{opacity:0.5;background-color:rgba(255,255,255,.2);cursor:grabbing;}
        .task-checkbox{margin-right:12px;width:18px;height:18px;accent-color:var(--secondary);cursor:pointer}
        .task-text{flex-grow:1;font-size:1rem;margin-right:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .task-input{flex-grow:1;padding:5px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:1rem;margin-right:15px}
        .task-meta{display:flex;gap:10px;align-items:center;flex-shrink:0}
        .task-priority{padding:3px 8px;border-radius:12px;font-size:.75rem;font-weight:bold;white-space:nowrap}
        .priority-high{background-color:var(--danger)}
        .priority-medium{background-color:var(--warning);color:var(--background)}
        .priority-low{background-color:var(--primary-light);color:var(--background)}
        .task-time{font-size:.8rem;color:var(--primary-light);white-space:nowrap;min-width: 70px;text-align: center;}
        .timer-controls{display:flex;gap:5px;}
        .timer-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .timer-btn:hover{background-color:rgba(255,255,255,0.1);}
        .timer-btn:disabled{color:rgba(255,255,255,0.3);cursor:not-allowed;}
        .timer-btn.running{color:var(--secondary);}
        .completed{text-decoration:line-through;opacity:.7}
        .progress-container{margin-top:15px}
        .progress-header{display:flex;justify-content:space-between;margin-bottom:6px;font-size:.9rem}
        .progress-bar{height:8px;background-color:rgba(255,255,255,.1);border-radius:4px;overflow:hidden}
        .progress-fill{height:100%;background-color:var(--secondary);border-radius:4px;transition:width .5s}
        .stats{display:flex;justify-content:space-between;margin-top:10px;font-size:.85rem;color:var(--primary-light)}
        .footer{text-align:center;margin-top:15px;color:var(--primary-light);font-size:.85rem}
        .new-task{display:flex;margin-top:15px;gap:8px}
        .new-task-input{flex-grow:1;padding:10px 12px;border:none;border-radius:6px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:.9rem}
        .new-task-button{padding:10px 15px;border:none;border-radius:6px;background-color:var(--primary);color:white;font-weight:bold;font-size:.9rem;cursor:pointer;white-space:nowrap}
        .empty-state{text-align:center;padding:20px;color:var(--primary-light);font-size:.9rem}
        .drag-handle{cursor:grab;margin-right:10px;color:var(--primary-light);}
        .task-actions{display:flex;gap:5px;margin-left:5px;}
        .action-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;display:flex;align-items:center;justify-content:center;}
        .action-btn:hover{background-color:rgba(255,255,255,0.1);}
        @media (max-width:600px){.task-meta{flex-direction:column;gap:3px;align-items:flex-end}.task-priority,.task-time{font-size:.7rem}}
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>Enhanced Task Dashboard</h1>
            <p>Drag tasks to reorder ‚Ä¢ Timers track your time spent</p>
        </div>
        <div class="focus-section">
            <div class="tabs-container">
                <div class="tab active" data-tab="active">Current Focus</div>
                <div class="tab" data-tab="completed">Completed Tasks</div>
            </div>
            <ul class="task-list" id="task-list"></ul>
            <div class="new-task">
                <input type="text" class="new-task-input" placeholder="Add a new task..." id="new-task-input">
                <button class="new-task-button" id="add-task-btn">Add</button>
            </div>
            <div class="progress-container">
                <div class="progress-header">
                    <span>Progress</span>
                    <span id="progress-percent">0%</span>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
            </div>
            <div class="stats">
                <span id="completed-count">0 of 0 completed</span>
                <span id="remaining-count">0 tasks remaining</span>
            </div>
        </div>
        <div class="footer">
            <p id="timestamp">Updated: --</p>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDEEMO9MlcNsb_QLIRTDJM4rXqxGZuYJps",
            authDomain: "obs-todo-68da2.firebaseapp.com",
            databaseURL: "https://obs-todo-68da2-default-rtdb.firebaseio.com",
            projectId: "obs-todo-68da2",
            storageBucket: "obs-todo-68da2.firebasestorage.app",
            messagingSenderId: "594250582895",
            appId: "1:594250582895:web:62414c9f759b99904cb69a",
            measurementId: "G-N94MD8GRJQ"
        };

        let useFirebase = false;
        try {
            if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                firebase.initializeApp(firebaseConfig);
                useFirebase = true;
            }
        } catch (err) {
            console.warn('Firebase init failed, falling back to localStorage:', err);
            useFirebase = false;
        }

        // DOM elements
        const taskListEl = document.getElementById('task-list');
        const inputEl = document.getElementById('new-task-input');
        const addBtn = document.getElementById('add-task-btn');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const completedCount = document.getElementById('completed-count');
        const remainingCount = document.getElementById('remaining-count');
        const timestampEl = document.getElementById('timestamp');
        const tabs = document.querySelectorAll('.tab');

        // App state
        let tasks = {};
        let dbRef = null;
        let currentTab = 'active';
        let timerIntervals = {};
        let dragSrcEl = null;
        let editingTaskId = null;

        // Timer functions
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function startTimer(taskId) {
            if (timerIntervals[taskId]) return; // Timer already running
            
            const task = tasks[taskId];
            if (!task.timerStartTime) {
                task.timerStartTime = Date.now();
            }
            
            timerIntervals[taskId] = setInterval(() => {
                const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                task.timeSpent = (task.timeSpent || 0) + elapsed;
                task.timerStartTime = Date.now();
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
            }, 1000);
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        function pauseTimer(taskId) {
            if (timerIntervals[taskId]) {
                clearInterval(timerIntervals[taskId]);
                delete timerIntervals[taskId];
                
                const task = tasks[taskId];
                if (task.timerStartTime) {
                    const elapsed = Math.floor((Date.now() - task.timerStartTime) / 1000);
                    task.timeSpent = (task.timeSpent || 0) + elapsed;
                    task.timerStartTime = null;
                }
                
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId);
            }
        }

        function stopTimer(taskId) {
            pauseTimer(taskId);
            
            const task = tasks[taskId];
            task.timerStartTime = null;
            
            updateTaskInStorage(taskId);
            updateTaskDisplay(taskId);
        }

        // Drag and drop functions
        function handleDragStart(e) {
            if (currentTab !== 'active') return;
            
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (dragSrcEl !== this) {
                const taskItems = Array.from(taskListEl.querySelectorAll('.task-item'));
                const srcIndex = taskItems.indexOf(dragSrcEl);
                const destIndex = taskItems.indexOf(this);
                
                if (srcIndex !== -1 && destIndex !== -1) {
                    // Reorder tasks in the data structure
                    const taskKeys = Object.keys(tasks).filter(key => !tasks[key].completed);
                    const movedKey = taskKeys[srcIndex];
                    
                    // Remove from current position
                    taskKeys.splice(srcIndex, 1);
                    // Insert at new position
                    taskKeys.splice(destIndex, 0, movedKey);
                    
                    // Update order in tasks object
                    taskKeys.forEach((key, index) => {
                        tasks[key].order = index;
                    });
                    
                    // Save and re-render
                    saveAllTasks();
                    renderTasks();
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('over', 'dragging');
            });
        }

        // Task removal function
        function removeTask(taskId) {
            if (confirm('Are you sure you want to remove this task?')) {
                if (useFirebase) {
                    firebase.database().ref('tasks/' + taskId).remove();
                } else {
                    delete tasks[taskId];
                    saveAllTasks();
                    renderTasks();
                }
            }
        }

        // Task editing functions
        function startEditingTask(taskId) {
            editingTaskId = taskId;
            renderTasks();
            
            // Focus the input field after a short delay
            setTimeout(() => {
                const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveTaskEdit(taskId) {
            const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
            if (input) {
                const newText = input.value.trim();
                if (newText) {
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + taskId).update({ text: newText });
                    } else {
                        tasks[taskId].text = newText;
                        saveAllTasks();
                    }
                }
            }
            editingTaskId = null;
            renderTasks();
        }

        function cancelTaskEdit() {
            editingTaskId = null;
            renderTasks();
        }

        // Render functions
        function renderTasks() {
            taskListEl.innerHTML = '';
            const keys = Object.keys(tasks).sort((a, b) => {
                // Sort by order if available, otherwise by creation date
                const orderA = tasks[a].order !== undefined ? tasks[a].order : tasks[a].createdAt || 0;
                const orderB = tasks[b].order !== undefined ? tasks[b].order : tasks[b].createdAt || 0;
                return orderA - orderB;
            });
            
            // Filter tasks based on current tab
            const filteredTasks = keys.filter(key => {
                if (currentTab === 'active') return !tasks[key].completed;
                if (currentTab === 'completed') return tasks[key].completed;
                return true;
            });
            
            if (filteredTasks.length === 0) {
                const emptyMessage = currentTab === 'active' 
                    ? 'No active tasks ‚Äî add one!' 
                    : 'No completed tasks yet';
                taskListEl.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
            }
            
            filteredTasks.forEach(key => {
                const t = tasks[key];
                const li = document.createElement('li');
                li.className = 'task-item';
                li.draggable = currentTab === 'active' && editingTaskId !== key; // Only draggable in active tab and not editing
                li.dataset.id = key;
                
                // Drag and drop events for active tasks
                if (currentTab === 'active' && editingTaskId !== key) {
                    li.addEventListener('dragstart', handleDragStart, false);
                    li.addEventListener('dragenter', handleDragEnter, false);
                    li.addEventListener('dragover', handleDragOver, false);
                    li.addEventListener('dragleave', handleDragLeave, false);
                    li.addEventListener('drop', handleDrop, false);
                    li.addEventListener('dragend', handleDragEnd, false);
                }
                
                // Calculate display time
                let displayTime = '00:00:00';
                if (t.timeSpent) {
                    displayTime = formatTime(t.timeSpent);
                }
                
                // Check if timer is currently running
                const isTimerRunning = timerIntervals[key] !== undefined;
                
                // Check if this task is being edited
                const isEditing = editingTaskId === key;
                
                li.innerHTML = `
                    ${currentTab === 'active' && !isEditing ? '<div class="drag-handle">‚â°</div>' : ''}
                    <input type="checkbox" class="task-checkbox" ${t.completed ? 'checked' : ''}>
                    ${isEditing ? 
                        `<input type="text" class="task-input" value="${escapeHtml(t.text)}">` : 
                        `<span class="task-text ${t.completed ? 'completed' : ''}">${escapeHtml(t.text)}</span>`
                    }
                    <div class="task-meta">
                        <span class="task-priority ${priorityClass(t.priority)}">${capitalize(t.priority||'medium')}</span>
                        <span class="task-time">${displayTime}</span>
                        ${currentTab === 'active' && !t.completed && !isEditing ? 
                            `<div class="timer-controls">
                                <button class="timer-btn ${isTimerRunning ? 'running' : ''}" data-action="start" ${isTimerRunning ? 'disabled' : ''}>‚ñ∂</button>
                                <button class="timer-btn" data-action="pause" ${!isTimerRunning ? 'disabled' : ''}>‚è∏</button>
                                <button class="timer-btn" data-action="stop">‚èπ</button>
                            </div>` : ''}
                        <div class="task-actions">
                            ${isEditing ? 
                                `<button class="action-btn" data-action="save" title="Save">‚úì</button>
                                 <button class="action-btn" data-action="cancel" title="Cancel">‚úó</button>` :
                                `${currentTab === 'active' && !t.completed ? 
                                    `<button class="action-btn" data-action="edit" title="Edit">‚úèÔ∏è</button>` : ''}
                                 <button class="action-btn" data-action="remove" title="Remove">üóëÔ∏è</button>`
                            }
                        </div>
                    </div>
                `;
                
                // Checkbox handler
                li.querySelector('.task-checkbox').addEventListener('change', function() {
                    const checked = this.checked;
                    if (checked) {
                        // Stop timer when task is completed
                        stopTimer(key);
                    }
                    
                    if (useFirebase) {
                        firebase.database().ref('tasks/' + key).update({ 
                            completed: checked,
                            timeSpent: tasks[key].timeSpent || 0
                        });
                    } else {
                        tasks[key].completed = checked;
                        saveAllTasks();
                        renderTasks();
                    }
                });
                
                // Timer button handlers
                if (currentTab === 'active' && !t.completed && !isEditing) {
                    const timerBtns = li.querySelectorAll('.timer-btn');
                    timerBtns.forEach(btn => {
                        btn.addEventListener('click', function() {
                            const action = this.dataset.action;
                            
                            switch(action) {
                                case 'start':
                                    startTimer(key);
                                    break;
                                case 'pause':
                                    pauseTimer(key);
                                    break;
                                case 'stop':
                                    stopTimer(key);
                                    break;
                            }
                            
                            renderTasks(); // Re-render to update button states
                        });
                    });
                }
                
                // Action button handlers
                const actionBtns = li.querySelectorAll('.action-btn');
                actionBtns.forEach(btn => {
                    btn.addEventListener('click', function() {
                        const action = this.dataset.action;
                        
                        switch(action) {
                            case 'remove':
                                removeTask(key);
                                break;
                            case 'edit':
                                startEditingTask(key);
                                break;
                            case 'save':
                                saveTaskEdit(key);
                                break;
                            case 'cancel':
                                cancelTaskEdit();
                                break;
                        }
                    });
                });
                
                // Input handlers for editing
                if (isEditing) {
                    const input = li.querySelector('.task-input');
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            saveTaskEdit(key);
                        }
                    });
                    input.addEventListener('blur', function() {
                        // Use setTimeout to allow click events to register before blur
                        setTimeout(() => {
                            if (editingTaskId === key) {
                                saveTaskEdit(key);
                            }
                        }, 150);
                    });
                }
                
                taskListEl.appendChild(li);
            });
            
            updateProgressUI();
        }

        function updateTaskDisplay(taskId) {
            const taskEl = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (taskEl) {
                const task = tasks[taskId];
                const timeEl = taskEl.querySelector('.task-time');
                if (timeEl) {
                    timeEl.textContent = formatTime(task.timeSpent || 0);
                }
            }
        }

        function updateProgressUI() {
            const arr = Object.values(tasks);
            const total = arr.length;
            const done = arr.filter(t=>t.completed).length;
            const pct = total > 0 ? Math.round((done/total)*100) : 0;
            progressFill.style.width = pct + '%';
            progressPercent.textContent = pct + '%';
            completedCount.textContent = `${done} of ${total} completed`;
            remainingCount.textContent = `${total - done} tasks remaining`;
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
            timestampEl.textContent = `Updated: ${now.toLocaleDateString()} at ${timeString}`;
        }

        // Tab handling
        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                tabs.forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                currentTab = this.dataset.tab;
                renderTasks();
            });
        });

        // Add task
        addBtn.addEventListener('click', addNewTask);
        inputEl.addEventListener('keypress', function(e){ if (e.key === 'Enter') addNewTask(); });

        function addNewTask() {
            const text = inputEl.value.trim();
            if (!text) return;
            
            // Calculate next order value
            const activeTasks = Object.values(tasks).filter(t => !t.completed);
            const nextOrder = activeTasks.length > 0 ? 
                Math.max(...activeTasks.map(t => t.order || 0)) + 1 : 0;
            
            const payload = { 
                text, 
                priority: 'medium', 
                completed: false, 
                createdAt: Date.now(),
                order: nextOrder,
                timeSpent: 0
            };
            
            if (useFirebase) {
                const newRef = firebase.database().ref('tasks').push();
                newRef.set(payload);
            } else {
                const key = 'local_' + Date.now();
                tasks[key] = payload;
                saveAllTasks();
                renderTasks();
            }
            inputEl.value = '';
        }

        // Storage functions
        function updateTaskInStorage(taskId) {
            if (useFirebase) {
                firebase.database().ref('tasks/' + taskId).update({
                    timeSpent: tasks[taskId].timeSpent || 0,
                    timerStartTime: tasks[taskId].timerStartTime || null
                });
            } else {
                saveAllTasks();
            }
        }

        function saveAllTasks() {
            if (!useFirebase) {
                localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
            }
        }

        // Firebase sync
        if (useFirebase) {
            dbRef = firebase.database().ref('tasks');
            dbRef.on('value', snap => {
                const val = snap.val() || {};
                tasks = Object.keys(val).reduce((acc,k)=>{ 
                    acc[k] = val[k]; 
                    // Ensure all tasks have required properties
                    if (!acc[k].hasOwnProperty('timeSpent')) acc[k].timeSpent = 0;
                    if (!acc[k].hasOwnProperty('order')) acc[k].order = 0;
                    return acc; 
                }, {});
                
                // Restart any running timers
                Object.keys(tasks).forEach(key => {
                    if (tasks[key].timerStartTime && !tasks[key].completed) {
                        startTimer(key);
                    }
                });
                
                renderTasks();
            });
        } else {
            // Load from localStorage
            const raw = localStorage.getItem('obs_todo_tasks');
            tasks = raw ? JSON.parse(raw) : {};
            
            // Ensure all tasks have required properties
            Object.keys(tasks).forEach(key => {
                if (!tasks[key].hasOwnProperty('timeSpent')) tasks[key].timeSpent = 0;
                if (!tasks[key].hasOwnProperty('order')) tasks[key].order = 0;
            });
            
            renderTasks();
        }

        // Utility functions
        function escapeHtml(str){ return (str+'').replace(/[&<>"']/g, function(s){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s]; }); }
        function priorityClass(p){ return p === 'high' ? 'priority-high' : (p === 'low' ? 'priority-low' : 'priority-medium'); }
        function capitalize(s){ return (s||'').charAt(0).toUpperCase() + (s||'').slice(1); }

        // Manual refresh for OBS
        window.refreshTasks = function(){ 
            if (useFirebase) { 
                firebase.database().ref('tasks').once('value').then(snap=>{ 
                    tasks = snap.val()||{}; 
                    renderTasks(); 
                }); 
            } else { 
                const raw = localStorage.getItem('obs_todo_tasks'); 
                tasks = raw?JSON.parse(raw):{}; 
                renderTasks(); 
            } 
        }
    </script>
</body>
</html>