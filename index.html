<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>OBS Todo | Free Streamer Task List & Pomodoro Overlay for OBS</title>

    <meta name="description" content="Timed to-do list with auto-scrolling and a Pomodoro timer — designed for streamers using OBS or Streamlabs on Twitch or Kick. No installation needed. Includes task rotation, timed tasks, task history, and detailed reporting.">

    <meta name="keywords" content="looping to-do list, rotating to-do list, moving to-do list, auto-scrolling task list, cycling tasks app, task loop dashboard, pomodoro timer, pomodoro to-do app, free to-do list app, free productivity tool, co-working productivity app, coworking focus timer, co working task list, streamer to-do list, to-do list for streamers, streamer task overlay, OBS to-do overlay, Streamlabs task overlay, twitch stream to-do list, kick stream overlay tasks, rotating reminders, continuous task list, dynamic task dashboard">

    <meta name="author" content="Construct.exe">
    <meta name="robots" content="index, follow">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yassfix.github.io/obs-todo/">
    <meta property="og:title" content="OBS Todo — The Ultimate Task Dashboard for Streamers">
    <meta property="og:description" content="Add a powerful task manager to your OBS setup in seconds. Features a Pomodoro timer, streak tracking, and rotating task display mode. No download needed.">
    <meta property="og:image" content="https://yassfix.github.io/obs-todo/img/social-preview.png">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://yassfix.github.io/obs-todo/">
    <meta property="twitter:title" content="OBS Todo — Free Streamer Task List Overlay">
    <meta property="twitter:description" content="Boost your stream productivity with a browser-based to-do list and timer built for OBS docks.">
    <meta property="twitter:image" content="https://yassfix.github.io/obs-todo/img/social-preview.png">

    <link rel="icon" type="image/png" href="img/ObstodoIcon.png">
    <link rel="canonical" href="https://yassfix.github.io/obs-todo/">

    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "OBS Todo",
        "url": "https://yassfix.github.io/obs-todo/",
        "description": "A to-do list and Pomodoro timer for OBS users and Twitch / Kick streamers.",
        "applicationCategory": "ProductivityApplication",
        "operatingSystem": "Any (Web Browser)",
        "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
        },
        "author": {
        "@type": "Person",
        "name": "Construct.exe"
        }
    }
    </script>
    </head>

    </script>

    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> <style></style>
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-light: oklch(73.588% 0.14122 285.603);
            --secondary: #00b894;
            --background: #000000;
            --card: #000000ec;
            --text: #dfe6e9;
            --accent: #fd79a8;
            --warning: #fdcb6e;
            --danger: #e17055;
        }
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}
        body{background-color:var(--background);color:var(--text);padding:15px;max-width:900px;margin:0 auto}
        .dashboard{display:flex;flex-direction:column;gap:20px}
        .header{text-align:center;margin-bottom:5px}
        .header h1{color:var(--primary);font-size:1.5rem;margin-bottom:3px}
        .header p{color:var(--primary-light);font-size:0.95rem}
        .focus-section{background-color:var(--card);border-radius:10px;padding:20px;box-shadow:0 4px 15px rgba(0,0,0,.2);position:relative;overflow:hidden;}
        .section-header{display:flex;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary)}
        .section-header h2{font-size:1.4rem;margin-left:10px}
        .tabs-container{display:flex;border-bottom:2px solid var(--primary);margin-bottom:15px}
        .tab{flex:1;text-align:center;padding:10px 0;cursor:pointer;transition:all 0.3s;border-bottom:2px solid transparent}
        .tab.active{color:var(--primary);border-bottom-color:var(--primary);font-weight:bold}
        .tab:hover:not(.active){background-color:rgba(255,255,255,0.05)}
        .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;color:white;font-weight:bold;background-color:var(--accent)}
        .task-list{list-style-type:none;margin-bottom:20px;position:relative;}
        .task-item{display:flex;align-items:center;padding:12px 10px;margin-bottom:8px;background-color:rgba(255,255,255,.05);border-radius:8px;transition:all .3s;cursor:grab;}
        .task-item:hover{background-color:rgba(255,255,255,.1)}
        .task-item.dragging{opacity:0.5;background-color:rgba(255,255,255,.2);cursor:grabbing;}
        
        .task-checkbox{margin-right:20px;width:18px;height:18px;accent-color:var(--secondary);cursor:pointer}
        
        .task-text{flex-grow:1;font-size:1.1rem;font-family: 'Times New Roman', Times, serif;margin-right:15px;margin-left:10px;word-wrap:break-word;overflow-wrap:break-word;white-space:normal}
        
        .task-input{flex-grow:1;padding:5px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:1rem;margin-right:15px}
        .task-meta{display:flex;gap:10px;align-items:center;flex-shrink:0}
        .task-time{font-size:.8rem;color:var(--primary-light);white-space:nowrap;min-width: 70px;text-align: center;}
        .timer-controls{display:flex;gap:5px;}
        .timer-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .timer-btn:hover:not(:disabled){background-color:rgba(255,255,255,0.1);}
        .timer-btn:disabled{color:rgba(255,255,255,0.3);cursor:not-allowed;}
        .timer-btn.running{color:var(--secondary);}
        .completed{text-decoration:line-through;opacity:.7}
        .progress-container{margin-top:15px}
        .progress-header{display:flex;justify-content:space-between;margin-bottom:6px;font-size:.9rem}
        .progress-bar{height:8px;background-color:rgba(255,255,255,.1);border-radius:4px;overflow:hidden}
        .progress-fill{height:100%;background-color:var(--secondary);border-radius:4px;transition:width .5s}
        .stats{display:flex;justify-content:space-between;margin-top:10px;font-size:.85rem;color:var(--primary-light)}
        .time-stats{display:flex;justify-content:space-between;margin-top:15px;padding:10px;background-color:rgba(255,255,255,.05);border-radius:8px;}
        .time-stat{display:flex;flex-direction:column;align-items:center;flex:1;}
        .time-stat-value{font-size:1.2rem;font-weight:bold;color:var(--secondary);}
        .time-stat-label{font-size:0.75rem;color:var(--primary-light);margin-top:5px;}
        .footer{text-align:center;margin-top:15px;color:var(--primary-light);font-size:.85rem}
        .new-task{display:flex;margin-top:15px;gap:8px}
        .new-task-input{flex-grow:1;padding:10px 12px;border:none;border-radius:6px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:.9rem}
        .new-task-button{padding:10px 15px;border:none;border-radius:6px;background-color:var(--primary);color:white;font-weight:bold;font-size:.9rem;cursor:pointer;white-space:nowrap}
        .empty-state{text-align:center;padding:20px;color:var(--primary-light);font-size:.9rem}
        .drag-handle{cursor:grab;margin-right:10px;color:var(--primary-light);}
        .task-actions{display:flex;gap:5px;margin-left:5px;}
        .action-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;display:flex;align-items:center;justify-content:center;}
        .action-btn:hover{background-color:rgba(255,255,255,0.1);}
        .completion-date{font-size:0.7rem;color:var(--primary-light);margin-top:2px;font-style:italic;}
        .task-content{flex-grow:1;display:flex;flex-direction:column;margin-right:15px;overflow:hidden;min-width:0} /* Added min-width:0 for proper flexbox wrapping */
        
        /* Keyword/Tag Styles */
        .keywords-container{display:none;flex-wrap:wrap;gap:5px;margin-bottom:8px;align-items:center;}
        .keywords-container.visible{display:flex;}
        .keyword-tag{display:inline-flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:2px 8px;border-radius:12px;font-size:0.7rem;cursor:pointer;margin:2px;}
        .keyword-tag:hover{background-color:var(--primary);}
        .keyword-tag.selected{background-color:var(--secondary);}
        .keyword-remove{background:none;border:none;color:var(--background);cursor:pointer;margin-left:4px;font-size:0.7rem;font-weight:bold;padding:0;width:14px;height:14px;display:flex;align-items:center;justify-content:center;}
        .add-keyword-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.8rem;padding:2px 5px;border-radius:3px;}
        .add-keyword-btn:hover{background-color:rgba(255,255,255,0.1);}
        .keyword-input-container{display:flex;gap:5px;margin-top:5px;}
        .keyword-input{flex-grow:1;padding:4px 8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);font-size:0.8rem;}
        .add-keyword-confirm{background-color:var(--secondary);color:white;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:0.8rem;}
        
        /* Keyword Management Styles */
        .keyword-management{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;justify-content:center;align-items:center;}
        .keyword-management.visible{display:flex;}
        .keyword-management-content{background-color:var(--card);padding:20px;border-radius:10px;width:90%;max-width:500px;max-height:80vh;overflow-y:auto;}
        .keyword-management-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:1px solid var(--primary);padding-bottom:10px;}
        .keyword-management-header h3{color:var(--primary);}
        .close-keyword-management{background:none;border:none;color:var(--primary-light);font-size:1.5rem;cursor:pointer;}
        .keyword-list{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:15px;}
        .keyword-item{display:flex;align-items:center;background-color:var(--primary-light);color:var(--background);padding:5px 10px;border-radius:15px;}
        .keyword-item input{background:none;border:none;color:var(--background);font-size:0.8rem;width:100px;}
        .keyword-item input:focus{outline:none;}
        .keyword-item-actions{display:flex;gap:5px;margin-left:5px;}
        .keyword-item-btn{background:none;border:none;color:var(--background);cursor:pointer;font-size:0.8rem;padding:2px 5px;}
        .new-keyword-input{display:flex;gap:8px;margin-top:10px;}
        .new-keyword-input input{flex-grow:1;padding:8px;border:none;border-radius:4px;background-color:rgba(255,255,255,.1);color:var(--text);}
        .new-keyword-input button{padding:8px 15px;border:none;border-radius:4px;background-color:var(--primary);color:white;cursor:pointer;}
        .show-keywords-btn{background:none;border:none;color:var(--primary-light);cursor:pointer;font-size:0.7rem;padding:2px 5px;border-radius:3px;margin-bottom:5px;}
        .show-keywords-btn:hover{background-color:rgba(255,255,255,0.1);}
        .manage-keywords-btn{background-color:var(--primary);color:white;border:none;padding:8px 15px;border-radius:6px;cursor:pointer;margin-top:10px;font-size:0.9rem;}
        
        /*  STYLES FOR THE LAYOUT CHANGES */
        .time-stats-container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            position: relative;
            z-index: 2;
        }
        .timers-section {
            display: flex;
            gap: 15px;
            flex: 1;
            align-items: center; 
        justify-content: space-around; 
        }
        .progress-section {
            width: 50%;
        }
        .progress-section .progress-container {
            margin-top: 0;
        }
        .progress-section .progress-bar {
            width: 100%;
        }
        
        /* STYLES FOR DROPDOWN FUNCTIONALITY */
        .task-main-content {
            display: flex;
            align-items: center;
            width: 100%;
        }
        .dropdown-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            transition: transform 0.3s;
        }
        .dropdown-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .dropdown-btn.rotated {
            transform: rotate(180deg);
        }
        .task-details {
            display: none;
            width: 100%;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 8px;
        }
        .task-details.visible {
            display: flex;
            flex-direction: column;
        }
        .task-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        /* --- NEW DISPLAY MODE STYLING --- */

        /* Container Layout */
        .display-mode-section {
            background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(0,0,0,0.4) 100%);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        /* Add a subtle top border accent */
        .display-mode-section::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        .display-mode-section h3 {
            text-align: center;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--primary-light);
            margin-bottom: 20px;
            opacity: 0.8;
        }

        /* Grid for the cards */
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        /* The Card Option Wrapper */
        .mode-option {
            display: inherit !important;
            position: relative;
            margin: 0; /* Reset */
        }

        /* Hide the default radio button completely */
        .mode-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* The visual card label */
        .mode-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            height: 100%;
            min-height: 90px;
            color: var(--text);
            font-size: 0.85rem;
            font-weight: 500;
        }

        /* Icon styling inside label (We will add spans to HTML) */
        .mode-option label span.icon {
            font-size: 1.5rem;
            margin-bottom: 8px;
            background: none;
            width: auto;
            height: auto;
            color: var(--primary-light);
            transition: transform 0.3s ease;
        }

        /* HOVER STATE */
        .mode-option label:hover {
            background-color: rgba(255, 255, 255, 0.08);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }

        /* CHECKED/ACTIVE STATE */
        .mode-option input[type="radio"]:checked + label {
            background-color: rgba(108, 92, 231, 0.15); /* Primary with opacity */
            border-color: var(--secondary);
            box-shadow: 0 0 15px rgba(0, 184, 148, 0.2); /* Secondary glow */
            color: white;
        }

        .mode-option input[type="radio"]:checked + label span.icon {
            color: var(--secondary);
            transform: scale(1.2);
        }

        /* The Description Box */
        .mode-description {
            background-color: rgba(0,0,0,0.3);
            border-left: 3px solid var(--secondary);
            padding: 12px 15px;
            border-radius: 0 6px 6px 0;
            font-family: 'Segoe UI Mono', monospace;
            font-size: 0.8rem;
            color: var(--primary-light);
            line-height: 1.4;
            min-height: 45px;
            display: flex;
            align-items: center;
        }

        /* --- MINIMAL MODE TOGGLE (SWITCH STYLE) --- */
        .minimal-mode-toggle {
            background-color: transparent !important;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 0;
        }

        .minimal-mode-toggle h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text);
        }

        /* Custom Switch Container */
        .switch-container {
            display: flex;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Hide radios in switch */
        .switch-container input {
            display: none;
        }

        .switch-container label {
            padding: 6px 16px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            color: var(--primary-light);
        }

        .switch-container input:checked + label {
            background-color: var(--primary);
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* CONVEYOR BELT ANIMATION STYLES */
        .conveyor-container {
            position: relative;
            overflow: hidden;
            height: auto;
            min-height: 100px;
        }

        .conveyor-track {
            position: relative;
            transition: transform 0.1s linear;
        }

        .conveyor-task {
            transition: opacity 0.5s ease;
            margin-bottom: 8px;
        }

        .task-entering {
            opacity: 0;
            transform: translateY(20px);
        }

        .task-visible {
            opacity: 1;
            transform: translateY(0);
        }

        .task-exiting {
            opacity: 0;
            transform: translateY(-20px);
        }

        /*  STYLES FOR LIMITED VISIBLE AREA AND SCROLLING */
        .tasks-container {
            max-height: 272px; 
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-light) rgba(255,255,255,0.1);
            margin-bottom: 15px;
            border-radius: 8px;
            padding-right: 5px;
            
            /* ADD THIS LINE for smooth resizing: */
            transition: height 0.3s ease-out, max-height 0.3s ease-out;
        }
        .tasks-container::-webkit-scrollbar {
            width: 8px;
        }

        .tasks-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-light);
            border-radius: 4px;
        }

        .tasks-container::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary);
        }
        
        /*   STYLES FOR ORDER BUTTONS */
        .task-order-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-right: 8px;
            align-self: stretch; 
        }
        .order-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.7rem;
            line-height: 1;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .order-btn:hover:not(:disabled) {
            background-color: rgba(255,255,255,0.1);
        }
        .order-btn:disabled {
            color: rgba(255,255,255,0.2);
            cursor: not-allowed;
        }
        .task-order-controls + .task-checkbox {
            margin-right: 0;
        }


        /* For mobile responsiveness */
        @media (max-width:600px){
            .task-meta{flex-direction:column;gap:3px;align-items:flex-end}
            .task-time{font-size:.7rem}
            .time-stats-container {
                flex-direction: column;
                gap: 15px;
            }
            .timers-section {
                width: 100%;
            }
            .progress-section {
                width: 100%;
            }
            .task-details-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .mode-selector {
                flex-direction: column;
                gap: 10px;
            }
            .reporting-stats {
                flex-direction: column;
            }
        }
        
        @media (max-width: 768px) {
            .reporting-flex-container {
                flex-direction: column;
            }
        }

        /* smooth bottom entrance */
        .conveyor-reset {
            animation: slideFromBottom 0.5s ease-out;
        }

        @keyframes slideFromBottom {
            0% {
                transform: translateY(100%);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* REPORTING STYLES  */
        #reporting-content-wrapper {
            padding-top: 15px;
        }
        .reporting-stats {
            display: flex;
            gap: 15px;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .stat-card {
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            padding: 15px;
            flex: 1;
            text-align: center;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--secondary);
        }
        .stat-label {
            font-size: 0.85rem;
            color: var(--primary-light);
            margin-top: 5px;
        }
        
        .chart-container {
            margin-top: 20px;
            height: 250px; 
            position: relative;
        }
        
        .chart-container h3 {
            text-align: center;
            color: var(--primary-light);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        /*   Reporting Flex Layout  */
        .reporting-flex-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 20px;
        }

        .reporting-flex-container > div {
            flex: 1; 
            min-width: 0; 
            margin-top: 0 !important;
        }

        /*  LOGIN STYLES  */
        #login-container {
            display: none;
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            margin: 50px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }
        #login-container .header h1 {
            margin-bottom: 20px;
        }
        #login-container form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #login-container input {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background-color: rgba(255,255,255,.1);
            color: var(--text);
        }
        #login-container button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        #signup-btn {
            background-color: var(--primary);
        }
        #login-btn {
            background-color: var(--secondary);
        }
        #guest-btn {
            background-color: var(--accent);
            margin-top: 10px;
        }
        #logout-btn {
            background: none;
            border: 1px solid var(--primary-light);
            color: var(--primary-light);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.7rem;
        }
        
        /* : PASSWORD RESET STYLES  */
        .forgot-password-link {
            color: var(--primary-light);
            text-decoration: none;
            font-size: 0.8rem;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
        }
        .forgot-password-link:hover {
            color: var(--primary);
            text-decoration: underline;
        }
        .password-reset-container {
            display: none;
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            margin: 50px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }
        .password-reset-container h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }
        .password-reset-container p {
            color: var(--primary-light);
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        .password-reset-container input {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background-color: rgba(255,255,255,.1);
            color: var(--text);
            width: 100%;
            margin-bottom: 15px;
        }
        .password-reset-container button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
        }
        #reset-password-btn {
            background-color: var(--primary);
            margin-bottom: 10px;
        }
        #back-to-login-btn {
            background-color: var(--accent);
        }
        .reset-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9rem;
        }
        .reset-success {
            background-color: rgba(0, 184, 148, 0.2);
            color: var(--secondary);
        }
        .reset-error {
            background-color: rgba(225, 112, 85, 0.2);
            color: var(--danger);
        }

        /*  STREAK CALENDAR STYLES */
        .streak-calendar-container {
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }

        .streak-calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 10px;
        }

        .streak-calendar-header h3 {
            color: var(--primary);
            font-size: 1.2rem;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .calendar-nav-btn {
            background: none;
            border: none;
            color: var(--primary-light);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .calendar-nav-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .current-month {
            font-weight: bold;
            color: var(--text);
            min-width: 150px;
            text-align: center;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }

        .calendar-day-header {
            text-align: center;
            font-size: 0.8rem;
            color: var(--primary-light);
            padding: 5px 0;
            font-weight: bold;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 0.8rem;
            background-color: rgba(255,255,255,0.05);
            transition: all 0.2s;
            position: relative;
        }

        .calendar-day.empty {
            background-color: transparent;
        }

        .calendar-day.today {
            border: 2px solid var(--primary);
        }

        .calendar-day.has-streak {
            background-color: var(--secondary);
            color: var(--background);
            font-weight: bold;
        }

        .calendar-day.has-streak::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 6px;
            border: 2px solid var(--secondary);
            animation: pulse 2s infinite;
        }

        /*  Style for frozen streak days */
        .calendar-day.has-frozen-streak {
            background-color: #6c5ce730;
            color: rgb(255, 255, 255);
        }

        .calendar-day.weekend {
            background-color: rgba(255,255,255,0.02);
        }
        /*  Override for frozen weekend days */
        .calendar-day.weekend.has-frozen-streak {
            background-color: #6c5ce730;
        }

        .calendar-day.weekend.has-streak {
            background-color: var(--secondary);
        }

        .streak-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .streak-stat {
            text-align: center;
        }

        .streak-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary);
        }

        .streak-label {
            font-size: 0.8rem;
            color: var(--primary-light);
            margin-top: 5px;
        }

        .streak-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-streak {
            background-color: var(--secondary);
        }

        /*  Style for the frozen legend item */
        .legend-frozen {
            background-color: #6c5ce730;
        }

        .legend-today {
            border: 2px solid var(--primary);
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7;
            }
        }

        /* For mobile responsiveness */
        @media (max-width: 600px) {
            .calendar-grid {
                gap: 3px;
            }
            
            .calendar-day {
                font-size: 0.7rem;
            }
            
            .streak-stats {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        /* Total hours display */
        .total-hours-display {
            font-size: 0.9rem;
            color: var(--primary-light);
            text-align: center;
            margin-top: 10px;
        }

        /*  Insights section styles */
        .insights-section {
            background-color: var(--card);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,.2);
        }

        .insights-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        #generate-insights-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        #generate-insights-btn:hover {
            background-color: var(--primary-light);
        }

        #generate-insights-btn:disabled {
            background-color: var(--primary-light);
            cursor: not-allowed;
            opacity: 0.7;
        }

        #insights-loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: var(--primary-light);
        }

        #insights-result {
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            padding: 35px;
            margin-top: 15px;
            white-space: normal;
            line-height: 1.5;
        }
        
        /*  Guest Mode Reporting Message  */
        .guest-reporting-message {
            text-align: center;
            padding: 40px 20px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .guest-reporting-message h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }
        
        .guest-reporting-message p {
            color: var(--primary-light);
            margin-bottom: 20px;
        }

        /* UPDATED: Minimal Mode Styles  */
        .minimal-mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255,255,255,.05);
            border-radius: 8px;
        }
        
        .minimal-mode-toggle label {
            font-size: 0.9rem;
            color: var(--text);
            cursor: pointer;
        }
        
        .minimal-mode-toggle input[type="radio"] {
            margin-right: 5px;
            accent-color: var(--primary);
        }
        
        .mode-option {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        /* Minimal Mode Styles */
        .minimal-mode .header,
        .minimal-mode .app-navbar,
        .minimal-mode .tabs-container,
        .minimal-mode .footer,
        .minimal-mode .display-mode-section,
        .minimal-mode .manage-keywords-btn,
        .minimal-mode .stats,
        .minimal-mode .new-task,
        .minimal-mode .pomo-toggle-section {
         
            display: none !important;
        }
        
        .minimal-mode .focus-section {
            padding: 10px;
            box-shadow: none;
            border-radius: 0;
            margin-top: 0;
        }
        
        .minimal-mode .time-stats-container {
            margin-top: 0;
            padding: 5px;
            background-color: transparent;
        }
        
        .minimal-mode .tasks-container {
            max-height: 300px;
        }
        
        .minimal-mode .minimal-mode-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: var(--card);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            margin-top: 0;
        }
        
        .minimal-mode body {
            padding: 5px;
        }
        
        .minimal-mode .dashboard {
            gap: 5px;
        }
        
        .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        min-height: 40px;
    }

    /* Media Query for Small Screens (e.g., phones) */
    @media (max-width: 680px) {


        button#toggle-user-status-btn {
            margin-left: -70px !important;
            
        }

        /* Target the container for stacking */
        .header-controls {
            /* Change the direction to stack items vertically */
            flex-direction: column; 
            
            /* Center the items when stacked */
            align-items: center; 
            
            /* Add some space between the stacked items */
            gap: 10px; 
            
            /* Adjust width/padding if needed for the container itself */
            padding: 10px 0; 
        }
        
        /* Center the user status text */
        #user-status {
            text-align: center;
            /* Ensure it takes full width for better centering */
            width: 100%; 
            margin-left:0px !important;
        }

        /* Adjust the Buy Me A Coffee container for better fit and centering */
        .bmc-container {
            /* Remove the scale/margin overrides which were likely for horizontal alignment */
            margin-right: 0 !important;
            
            /* Center the button itself (if needed) and ensure it doesn't shrink */
            width: auto !important;
            flex-shrink: 0;
            
            /* You might want to adjust the button size back to normal/larger */
            /* If you still want it small, keep the original inline styles, but centering is better */
        }
    }

    /* New Style for Privacy Toggle */
    .hidden-status {
        /* Hide the text by default using a color transition for effect */
        color: transparent !important; 
        transition: color 0.5s ease;
        /* Optional: Keep the space for the text */
        min-width: 150px; 
    }
    .visible-status {
        /* Make the text visible */
        color: var(--primary-light) !important;
    }



        /* task timer styling */
        /* LAYOUT: Timer under name, Button on right */
    .task-content {
        display: flex;
        flex-direction: column; /* Stacks name and timer vertically */
        justify-content: center;
        margin-right: auto; /* Pushes everything else to the right */
        padding-right: 10px;
    }

    .task-timer-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 2px;
    }

    .timer-display-small {
        font-family: 'Segoe UI Mono', monospace;
        font-size: 0.8rem;
        color: var(--primary-light);
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.5px;
        padding-left: 8px;
    }

    .right-play-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2rem; /* Larger, easy to hit button */
        color: var(--primary-light);
        padding: 5px 12px;
        margin-right: 5px;
        border-radius: 50%;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 36px;
        width: 36px;
    }

    .right-play-btn:hover {
        background-color: rgba(255,255,255,0.1);
        color: var(--primary);
    }

    .right-play-btn.running {
        color: var(--secondary); /* Green when running */
        background-color: rgba(0, 184, 148, 0.1);
        box-shadow: 0 0 10px rgba(0, 184, 148, 0.2);
    }

    .right-play-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

        /* --- POMODORO STYLES --- */

    /* Container for the Swap */
    .timers-section {
        position: relative;
    }

    /* Pomodoro UI Styling */
    #pomodoro-container {
    display: none; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(108, 92, 231, 0.1);
    border: 1px solid var(--primary);
    border-radius: 8px;
    padding: 5px 15px; /* Increased side padding slightly for look */
    min-width: 120px; /* Fixed width to prevent jumping */
    margin: 0; /* Ensure no margins push it down */
    }

    #pomo-timer-display {
        font-family: 'Segoe UI Mono', monospace;
        font-size: 1.4rem;
        font-weight: bold;
        color: var(--accent);
        font-variant-numeric: tabular-nums;
    }

    .pomo-controls {
        display: flex;
        gap: 5px;
        margin-top: 5px;
    }

    .pomo-btn {
        background: rgba(255,255,255,0.1);
        border: none;
        color: var(--text);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        transition: background 0.2s;
    }

    .pomo-btn:hover {
        background: var(--primary);
    }

    .pomo-btn.active-opt {
        background: var(--secondary);
        color: white;
    }

    .pomo-btn.control {
        font-weight: bold;
        color: var(--secondary);
        font-size: 0.9rem;
    }

    #pomo-status-label {
        font-size: 0.7rem; 
        margin-top: 2px;
        color: var(--primary-light);
    }

    /* Mode Toggle Section (Bottom) */
    .pomo-toggle-section {
        background-color: var(--card);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(0,0,0,.2);
        margin-top: 20px;
    }

    .pomo-toggle-section h3 {
        color: var(--accent); /* Different color to distinguish */
        margin-bottom: 15px;
        font-size: 1.2rem;
    }

    /* Completion Animation */
    @keyframes flash-screen {
        0% { background-color: var(--background); }
        50% { background-color: rgba(0, 184, 148, 0.3); } /* Green flash */
        100% { background-color: var(--background); }
    }

    .pomo-finished-anim {
        animation: flash-screen 0.5s ease-in-out 4; /* Flash 4 times */
    }

        /* --- FIX CHART SPACING & STYLING --- */

/* 1. Spacing: Push the linear charts down so they aren't crammed against the calendar */
    .reporting-flex-container {
        margin-bottom: 50px !important; 
    }

    /* 2. Card Style: Give each linear chart a distinct box */
    .chart-container {
        background-color: var(--card); /* Dark background */
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        padding: 25px; 
        margin-top: 30px !important; /* More space between stacked charts */
        height: 400px; /* Fixed height for the chart area */
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
    }

    /* Ensure canvas fills the remaining height after title/controls */
    

    /* --- 3. BUTTON FIX: Override big cards to look like simple buttons --- */

    /* Force the container to be a simple row, not a grid */
    .chart-container .mode-selector {
        display: flex !important; 
        flex-direction: row !important;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-bottom: 15px !important;
        border: none;
        background: transparent;
        padding: 0;
    }

    /* Reset the card wrapper */
    .chart-container .mode-option {
        margin: 0 !important;
        width: auto !important;
        display: block !important;
    }

    /* Reset the label styling to be a small "pill" button */
    .chart-container .mode-option label {
        display: inline-flex !important;
        align-items: center;
        justify-content: center;
        min-height: unset !important; /* Remove the big 90px height */
        height: 32px !important;      /* Fixed small height */
        padding: 0 20px !important;   /* Horizontal padding */
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;          /* Rounded pill shape */
        font-size: 0.85rem !important;
        font-weight: normal;
        color: var(--primary-light);
        box-shadow: none !important;  /* Remove the glow */
        transform: none !important;   /* Remove default hover movement */
    }

    /* Active State for Chart Buttons */
    .chart-container .mode-option input[type="radio"]:checked + label {
        background-color: var(--primary);
        border-color: var(--primary);
        color: white;
    }

    /* Hover State for Chart Buttons */
    .chart-container .mode-option label:hover {
        background-color: rgba(255, 255, 255, 0.15);
        border-color: var(--primary-light);
    }

    .chart-container canvas {
        flex-grow: 1;
        /* Removed fixed width/height allows Chart.js to handle the aspect ratio */
        min-height: 0; 
        max-width: 100%;
    }
        

    /* Navbar Container */
    .app-navbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 25px;
        background: rgba(255, 255, 255, 0.03); /* Subtle glass effect */
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        margin-bottom: 25px;
        backdrop-filter: blur(10px);
    }

    /* Brand Styling */
    .brand-container {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .nav-logo {
        width: 45px; /* Slightly smaller looks more premium */
        height: auto;
        filter: drop-shadow(0 0 8px rgba(108, 92, 231, 0.4)); /* Glow effect matching your primary color */
    }

    .brand-text h1 {
        font-size: 1.6rem;
        font-weight: 700;
        color: var(--text);
        margin: 0;
        line-height: 1;
        letter-spacing: -0.5px;
    }

    .brand-text .highlight {
        color: var(--primary); /* Makes 'Todo' purple */
    }

    .version-tag {
        font-size: 0.65rem;
        background: rgba(255,255,255,0.1);
        padding: 2px 6px;
        border-radius: 4px;
        color: var(--primary-light);
        vertical-align: middle;
        margin-left: 5px;
    }

    /* Right Side Controls */
    .nav-controls {
        display: flex;
        align-items: center;
        gap: 15px;
    }

        /* Update: Logout Button (Made smaller and added margin) */
    .nav-logout {
        background: transparent;
        border: 1px solid var(--danger);
        color: var(--danger);
        padding: 4px 10px;        /* Smaller padding */
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.75rem;       /* Smaller font to fit next to title */
        font-weight: 600;
        margin-left: 15px;        /* Space between Title and Button */
        transition: all 0.3s ease;
        white-space: nowrap;      /* Prevents text wrapping */
    }

    .nav-logout:hover {
        background: var(--danger);
        color: white;
    }

    /* Update: BMC Wrapper (Way smaller) */
    .bmc-wrapper {
        transform: scale(0.6);        /* shrunk to 60% size */
        transform-origin: right center; /* Anchors it to the right so it doesn't float away */
        display: flex;
        align-items: center;
        margin-left: -20px;           /* Pulls it closer to the other controls since scaling creates empty space */
    }

    /* Ensure the Left side container aligns items correctly */
    .brand-container {
        display: flex;
        align-items: center;
        gap: 10px; /* Space between logo and text */
    }

    /* --- UPDATED FOOTER STYLES --- */
.footer {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-top: 30px;
    margin-bottom: 10px;
    gap: 8px;
    color: var(--primary-light);
    font-size: 0.85rem;
}

.footer-status-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    padding: 5px 12px;
    border-radius: 20px;
    transition: all 0.3s ease;
}

.footer-status-wrapper:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: var(--primary-light);
}

#user-status {
    font-size: 0.8rem;
    font-family: 'Segoe UI Mono', monospace;
    letter-spacing: 0.5px;
    transition: color 0.3s ease;
}

/* Privacy button styling inside footer */
#toggle-user-status-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    font-size: 0.9rem;
    line-height: 1;
    display: flex; /* Centers the emoji */
    align-items: center;
    justify-content: center;
    opacity: 0.7;
    transition: opacity 0.2s;
}

#toggle-user-status-btn:hover {
    opacity: 1;
    transform: scale(1.1);
}

/* Ensure the navbar controls align correctly now that status is gone */
.nav-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: flex-end;
}


/* --- PAUSE STATE STYLES --- */
.tasks-container {
    position: relative; /* Needed for the 'Paused' label positioning */
    transition: border-color 0.3s, box-shadow 0.3s;
    border: 1px solid transparent; /* Prevent layout jump */
}

/* When the JavaScript adds this class */
.tasks-container.is-paused {
    border-color: var(--secondary);
    box-shadow: 0 0 15px rgba(0, 184, 148, 0.15);
    cursor: grab; /* Shows a 'hand' indicating you've stopped the list */
}

/* The 'PAUSED' Label Animation */
.tasks-container.is-paused::after {
    content: "⏸ PAUSED";
    position: absolute;
    top: 5px;
    right: 10px;
    background: var(--secondary);
    color: #000;
    font-size: 0.7rem;
    font-weight: 400;
    padding: 3px 5px;
    border-radius: 4px;
    pointer-events: none; /* Let clicks pass through to tasks */
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    animation: fadeInPulse 0.5s ease-out forwards;
    z-index: 10;
}

@keyframes fadeInPulse {
    0% { opacity: 0; transform: scale(0.8); }
    50% { transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
}

/* Add this to your style section */
.task-text {
    cursor: text; /* Indicates editable text */
}
.task-text:hover {
    color: #96cbc1fa; /* Optional: Highlights text on hover */
}

/* --- LONG PRESS ANIMATION --- */

/* The state when user is holding the mouse down */
.task-item.holding-active {
    position: relative;
    overflow: hidden; /* Ensures the fill stays inside rounded corners */
}

/* Create a pseudo-element for the filling effect */
.task-item.holding-active::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0%; /* Start empty */
    background-color: rgba(108, 92, 231, 0.3); /* Primary color, semi-transparent */
    z-index: 0; /* Behind the text */
    pointer-events: none;
    
    /* Animate width from 0% to 100% over 2 seconds */
    animation: longPressFill 0.962s linear forwards;
}

@keyframes longPressFill {
    to { width: 100%; }
}

/* Success Flash (Optional) */
.flash-success {
    animation: flashGreen 0.5s ease-out;
}
@keyframes flashGreen {
    0% { background-color: var(--secondary); }
    100% { background-color: rgba(255,255,255,.05); }
}

/* Ensure content sits above the background animation */
.task-main-content, .task-details {
    position: relative;
    z-index: 1;
}


/* --- COMPLETION CONFETTI ANIMATION --- */
.confetti-particle {
    position: absolute;
    width: 6px;
    height: 6px;
    background-color: var(--secondary);
    border-radius: 50%;
    pointer-events: none; /* Let clicks pass through */
    z-index: 100;
}

@keyframes explode-dist {
    0% { transform: translate(0, 0) scale(1); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
}

/* Optional: Flash the task row green briefly */
.task-item.completion-flash {
    animation: flashGreenRow 0.5s ease-out;
}
@keyframes flashGreenRow {
    0% { background-color: rgba(0, 184, 148, 0.4); transform: scale(1.02); }
    100% { background-color: rgba(255,255,255,.05); transform: scale(1); }
}




/* --- RPG LEVEL UP ANIMATION --- */

/* The floating text style */
.rpg-floating-text {
    position: fixed; /* Fixed ensures it floats above everything */
    color: #fdcb6e;  /* Gold color */
    font-weight: 800;
    font-family: 'Segoe UI', sans-serif;
    font-size: 1rem;
    pointer-events: none;
    z-index: 9999;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8); /* Strong shadow for readability */
    animation: floatUpXP 1s ease-out forwards;
}

/* The background burst style */
.task-item.rpg-glow-active {
    position: relative; 
}

/* Create the burst using a pseudo-element */
.task-item.rpg-glow-active::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 100%; height: 100%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(253, 203, 110, 0.6) 0%, transparent 70%);
    z-index: 0; /* Behind text */
    pointer-events: none;
    border-radius: 8px;
    animation: glowBurst 0.6s ease-out forwards;
}

/* Animations */
@keyframes floatUpXP {
    0% { opacity: 0; transform: translateY(0) scale(0.5); }
    20% { opacity: 1; transform: translateY(-10px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-50px) scale(1); }
}

@keyframes glowBurst {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
}

/* --- FIRE STORM ANIMATION --- */

/* --- FIRE STORM ANIMATION (INTENSE) --- */
.fire-particle {
    position: absolute;
    bottom: -10px; /* Start slightly lower */
    width: 14px;   /* Bigger flames (was 8px) */
    height: 14px;
    border-radius: 50%;
    background-color: #ff9f43;
    pointer-events: none;
    z-index: 100; /* Ensure it's on top */
    mix-blend-mode: screen; /* Makes overlapping flames brighter */
    opacity: 0;
    box-shadow: 0 0 15px #ff9f43, 0 0 5px #fff; /* Intense Glow */
}

/* The actual burning movement */
@keyframes burnUp {
    0% { 
        transform: translateY(0) scale(1); 
        opacity: 1; 
        background-color: #fff; /* Start White Hot */
    }
    30% {
        background-color: #feca57; /* Yellow */
    }
    60% { 
        background-color: #ff9f43; /* Orange */
        opacity: 0.9;
    }
    100% { 
        transform: translateY(var(--rise-height)) scale(0.2); 
        opacity: 0; 
        background-color: #ee5253; /* Red tip */
    }
}

/* Optional: Slight rumble/shake of the task row while burning */
.task-item.fire-rumble {
    animation: rumble 0.5s ease-in-out;
}
@keyframes rumble {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px); }
    75% { transform: translateX(2px); }
}

/* --- RPG LEVEL UP ANIMATION (Stronger) --- */
.rpg-floating-text {
    position: fixed;
    color: #ffd700; /* Bright Gold */
    font-weight: 900;
    font-size: 1.2rem;
    pointer-events: none;
    z-index: 9999;
    text-shadow: 0 2px 10px rgba(0,0,0,1);
    animation: floatUpXP 1s ease-out forwards;
}

.task-item.rpg-glow-active::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 120%; height: 200%; /* Larger burst */
    transform: translate(-50%, -50%);
    /* Stronger Gradient */
    background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, transparent 70%);
    z-index: 0; 
    pointer-events: none;
    animation: glowBurst 0.6s ease-out forwards;
}

/* --- FIRE STORM ANIMATION (High Visibility) --- */
.fire-particle {
    position: absolute;
    bottom: 0;
    width: 8px; /* Bigger flames */
    height: 8px;
    border-radius: 50%;
    background-color: #ff9f43;
    pointer-events: none;
    z-index: 2; /* Move IN FRONT of text background, but using blend mode */
    mix-blend-mode: hard-light; /* Pops more on dark backgrounds */
    opacity: 0;
}

/* --- WEEKLY REPORT TABLE STYLES --- */
.table-responsive {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on mobile */
}

.weekly-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
    text-align: left;
}

.weekly-table th {
    color: var(--primary-light);
    border-bottom: 2px solid var(--primary);
    padding: 12px 10px;
    font-weight: 600;
    white-space: nowrap;
}

.weekly-table td {
    padding: 12px 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    color: var(--text);
    vertical-align: middle;
}

.weekly-table tr:last-child td {
    border-bottom: none;
}

.weekly-table tr:hover {
    background-color: rgba(255, 255, 255, 0.02);
}

/* Style for the keywords inside the table */
.table-keyword-pill {
    display: inline-block;
    background-color: rgba(108, 92, 231, 0.2); /* Primary low opacity */
    color: #a29bfe;
    border: 1px solid rgba(108, 92, 231, 0.3);
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    margin-right: 4px;
    margin-bottom: 2px;
}

/* --- REWARD SECTION STYLES --- */
.reward-section {
    background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.3) 100%);
    border: 1px solid rgba(255,215,0,0.2); /* Subtle Gold Border */
    border-radius: 12px;
    padding: 30px;
    margin-top: 30px;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.reward-header {
    margin-bottom: 20px;
}

.reward-header h3 {
    color: #fdcb6e; /* Gold color */
    text-transform: uppercase;
    letter-spacing: 1px;
    font-size: 0.9rem;
}

.character-stage {
    position: relative;
    height: 250px;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    margin-bottom: 20px;
}

/* The Speech Bubble */
.reward-bubble {
    position: absolute;
    top: 0;
    background-color: #fff;
    color: #2d3436;
    padding: 15px;
    border-radius: 15px;
    font-size: 0.9rem;
    max-width: 280px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 10;
    cursor: text;
    border: 2px solid #fdcb6e;
    transition: transform 0.2s;
}

.reward-bubble:hover {
    transform: scale(1.05);
}

/* Speech bubble tail */
.reward-bubble::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 10px 10px 0;
    border-style: solid;
    border-color: #fff transparent transparent transparent;
}

.reward-inputs {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.reward-input-line {
    border: none;
    border-bottom: 1px solid #dfe6e9;
    padding: 2px;
    font-family: 'Segoe UI', sans-serif;
    width: 100%;
    text-align: center;
    outline: none;
    color: #2d3436;
    font-weight: bold;
}

/* The Coin Character */
.coin-character-img {
    width: 140px;
    height: auto;
    filter: drop-shadow(0 0 10px rgba(253, 203, 110, 0.4));
    transition: all 0.5s ease;
    cursor: pointer;
    animation: floatChar 3s ease-in-out infinite;
}

.coin-character-img:hover {
    filter: drop-shadow(0 0 20px rgba(253, 203, 110, 0.8));
}

@keyframes floatChar {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

/* Progress Bar Specifics */
.reward-progress-track {
    background-color: rgba(255,255,255,0.1);
    height: 20px;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
}

.reward-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #fdcb6e, #fab1a0);
    width: 0%;
    transition: width 1s ease-out;
    position: relative;
}

/* Shine effect on bar */
.reward-progress-fill::after {
    content: '';
    position: absolute;
    top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(
        45deg, 
        rgba(255,255,255,0) 25%, 
        rgba(255,255,255,0.2) 50%, 
        rgba(255,255,255,0) 75%
    );
    background-size: 20px 20px;
    opacity: 0.5;
}

.reward-stats-text {
    margin-top: 8px;
    font-size: 0.8rem;
    color: #fdcb6e;
    font-family: 'Segoe UI Mono', monospace;
}

/* WIN STATE STYLES */
.golden-text {
    font-size: 2rem;
    font-weight: 900;
    background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    margin-bottom: 20px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    animation: shine 3s linear infinite;
    background-size: 200%;
}

@keyframes shine {
    to { background-position: 200% center; }
}

.vanish-animation {
    animation: vanishPop 0.8s forwards;
}

@keyframes vanishPop {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.8; }
    100% { transform: scale(0); opacity: 0; }
}

.restart-btn {
    background: linear-gradient(45deg, #fdcb6e, #e17055);
    border: none;
    padding: 12px 25px;
    border-radius: 25px;
    color: white;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(225, 112, 85, 0.4);
    transition: transform 0.2s;
}

.restart-btn:hover {
    transform: scale(1.05);
}

/* Collection Gallery */
.reward-collection {
    margin-top: 30px;
    border-top: 1px solid rgba(255,255,255,0.1);
    padding-top: 20px;
    display: none; /* Hidden if empty */
}

.collection-grid {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 15px;
}

.collected-item {
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.05);
    border-radius: 50%;
    padding: 10px;
    border: 2px solid #fdcb6e;
    opacity: 0.7;
    transition: all 0.2s;
}

.collected-item:hover {
    opacity: 1;
    transform: scale(1.1);
}

.collected-item img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#toggle-collection-btn:hover {
    background-color: rgba(255,255,255,0.1) !important;
    border-color: var(--secondary) !important;
    color: var(--secondary) !important;
}




    </style>
<header id="marketing-hero" style="text-align:center; margin:10px auto 20px; padding-bottom:20px; border-bottom:1px solid rgba(255,255,255,0.05);">
    
    <h1 style="margin:0 0 8px; font-size:1.3rem; color:var(--primary); letter-spacing:0.5px;">
        OBS Todo - Timed To-Do list & Pomodoro Overlay for Streamers
    </h1>

    <p style="margin:0 auto 15px; max-width:700px; color:#c3bbff8c; font-size:0.9rem; line-height:1.3;">
        A free To-do list that auto-scrolls tasks, great for streamers using OBS or Streamlabs. Includes a Pomodoro timer, task looping, individual task timers, and completed tasks history & stats — Completely Browser-based as an overlay with no installation required
    </p>

    <p style="margin:0; font-size:0.85rem;">
        <a href="https://docs.obs-todo.com/" target="_blank" style="
            display: inline-block;
            color: var(--secondary); 
            text-decoration: none; 
            padding: 5px 15px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            background: rgba(255,255,255,0.03);
            transition: all 0.2s ease;
        "
        onmouseover="this.style.borderColor='var(--secondary)'; this.style.background='rgba(255,255,255,0.08)'"
        onmouseout="this.style.borderColor='rgba(255,255,255,0.1)'; this.style.background='rgba(255,255,255,0.03)'">
             Setup Guide: How to integrate with OBS & Streamlabs
        </a>
    </p>

</header>

</header>

    <!--  Login Container -->
    <div id="login-container">
        
        <div class="header">
            <div class="brand-container" style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 25px;">
                <img src="img/ObstodoIcon.png" alt="Logo" class="nav-logo" style="display: block;">
                <div class="brand-text" style="display: flex; align-items: center; height: 100%;">
                    <h1 style="margin: 0; line-height: 1.2; display: flex; align-items: center;">
                        Obs<span class="highlight">Todo</span>
                    </h1>
                </div>
            </div>
        </div>
        
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: var(--primary); margin-bottom: 15px;">Sign Up</h3>
            <form id="signup-form">
                <input type="email" id="signup-email" placeholder="Email">
                <input type="password" id="signup-password" placeholder="Password">
                <button type="submit" id="signup-btn">Sign Up</button>
            </form>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: var(--primary); margin-bottom: 15px;">Login</h3>
            <form id="login-form">
                <input type="email" id="login-email" placeholder="Email">
                <input type="password" id="login-password" placeholder="Password">
                <button type="submit" id="login-btn">Login</button>
                <a class="forgot-password-link" id="forgot-password-link">Forgot Password?</a>
            </form>
        </div>
        
        <div>
            <div id="auth-error-msg" style="color: #e17055; text-align: center; margin-bottom: 15px; font-size: 0.9rem;"></div>
            <h3 style="color: var(--primary); margin-bottom: 15px;">Guest Mode</h3>
            <p style="color: var(--primary-light); font-size: 0.9rem; margin-bottom: 15px;">
                Use the app without an account. Your completed tasks will be deleted the next day.
            </p>
            <button type="button" id="guest-btn">Continue as Guest</button>
        </div>
    </div>

    <!--  Password Reset Container -->
    <div id="password-reset-container" class="password-reset-container">
        <div class="header">
            <h1>Reset Password</h1>
        </div>
        
        <h3>Forgot your password?</h3>
        <p>Enter your email address and we'll send you a link to reset your password.</p>
        
        <form id="password-reset-form">
            <input type="email" id="reset-email" placeholder="Email" required>
            <button type="submit" id="reset-password-btn">Send Reset Link</button>
        </form>
        
        <button type="button" id="back-to-login-btn">Back to Login</button>
        
        <div id="reset-message" class="reset-message"></div>
    </div>

    <!--  Dashboard wrapper with id -->
    <div class="dashboard" id="dashboard-wrapper" style="display: none;">
        <!--  Header with logout button -->

    
    <nav class="app-navbar">
        <div class="brand-container">
            <img src="img/ObstodoIcon.png" alt="Logo" class="nav-logo">
            <div class="brand-text">
                <h1>Obs<span class="highlight">Todo</span></h1>
            </div>
            <button id="logout-btn" class="nav-logout">Logout</button>
        </div>

        <div class="nav-controls">
           
            
            <div class="bmc-wrapper">
                <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="Construct.exe" data-color="#FFDD00" data-emoji="" data-font="Cookie" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" ></script>
            </div>
        </div>
    </nav>
        

        <div class="focus-section">
            <div class="tabs-container">
                <div class="tab active" data-tab="active">Current Focus</div>
                <div class="tab" data-tab="completed">Completed Tasks</div>
                <div class="tab" data-tab="reporting">Reporting</div>
            </div>
            
            <div class="time-stats-container">
                <div class="timers-section">
                    <div class="time-stat" id="normal-timer-container">
                        <div class="time-stat-value" id="daily-total">00:00:00</div>
                        <div class="time-stat-label">Today</div>
                    </div>

                    <div class="time-stat" id="pomodoro-container">
                        <div id="pomo-timer-display">25:00</div>
                        <div class="pomo-controls">
                            <button class="pomo-btn active-opt" id="btn-25" onclick="selectPomoDuration(25)">25+5</button>
                            <button class="pomo-btn" id="btn-50" onclick="selectPomoDuration(50)">50+10</button>
                            <button class="pomo-btn control" id="pomo-action-btn" onclick="togglePomodoroAction()">▶</button>
                            <button class="pomo-btn control" onclick="resetPomodoro()">↺</button>
                        </div>
                        <div class="time-stat-label" id="pomo-status-label">Ready to Focus</div>
                    </div>

                    <div class="time-stat">
                        <div class="time-stat-value" id="total-hours">0 hours</div>
                        <div class="time-stat-label">Total Hours</div>
                    </div>
                </div>

                <audio id="pomo-alarm" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>
                <audio id="completion-sound" src="sounds/win-notification-2018.wav" preload="auto"></audio>
                <div class="progress-section">
                    <div class="progress-container">
                        <div class="progress-header">
                            <span>Today's Progress</span>
                            <span id="progress-percent">0%</span>
                        </div>
                        <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
                    </div>
                </div>
                

            </div>
            
            <div id="task-content-wrapper">
                <div class="tasks-container" id="tasks-container">
                    <div class="conveyor-container" id="conveyor-container">
                        <div class="conveyor-track" id="conveyor-track">
                            <ul class="task-list" id="task-list"></ul>
                        </div>
                    </div>
                </div>
                
                <button id="load-more-btn" style="display: none; width: 100%; margin: 10px 0;" class="new-task-button">Load Past 30 Days</button>
                <p id="no-more-tasks-msg" style="display: none; text-align: center; color: var(--primary-light); margin-top: 10px;">No more completed tasks found.</p>

            <div id="active-task-form" class="new-task" style="flex-direction: column; gap: 10px;">
                <div style="display: flex; gap: 8px; width: 100%;">
                    <input type="text" class="new-task-input" placeholder="Add a new task..." id="new-task-input">
                    <button class="new-task-button" id="add-task-btn">Add</button>
                </div>
                <button class="manage-keywords-btn global-manage-btn" style="width: 100%; margin-top: 5px; background-color: var(--primary-light); color: var(--background);">
                    Manage Keywords
                </button>
            </div>

            <div id="completed-task-form" class="new-task" style="display: none; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                <h4 style="color: var(--secondary); font-size: 0.9rem;">Log Offline Completed Task</h4>
                <div style="display: flex; gap: 8px;">
                    <input type="text" class="new-task-input" placeholder="What did you finish?" id="offline-task-text">
                    <input type="number" class="new-task-input" style="max-width: 100px;" placeholder="Mins" id="offline-task-mins">
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <select id="offline-task-keyword" class="new-task-input" style="background-color: #2d3436; flex-grow: 1;">
                        <option value="">No Keyword</option>
                    </select>
                    <button class="new-task-button" style="background-color: var(--secondary);" onclick="addOfflineTask()">Log Task</button>
                </div>
                <button class="manage-keywords-btn global-manage-btn" style="width: 100%; margin-top: 5px; background-color: var(--primary-light); color: var(--background);">
                    Manage Keywords
                </button>
            </div>

            <div class="pomo-toggle-section">
                <h3>Timer Mode</h3>
                <div class="mode-selector">
                    <div class="mode-option">
                        <input type="radio" id="timer-mode-normal" name="timer-mode" value="normal" onchange="handleTimerModeChange()">
                        <label for="timer-mode-normal">Standard (Count Up)</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="timer-mode-pomodoro" name="timer-mode" value="pomodoro" checked onchange="handleTimerModeChange()">
                        <label for="timer-mode-pomodoro">Pomodoro (Count Down)</label>
                    </div>
                </div>
                <div class="mode-description">
                    Switch between standard daily tracking or Pomodoro sessions
                </div>
                </div>

                <!-- Minimal Mode Toggle -->
                
                <div class="display-mode-section">
                    <h3><span style="opacity:0.6">///</span> Task Flow Control</h3>
                    
                    <div class="mode-selector">
                        <div class="mode-option">
                            <input type="radio" id="mode-static" name="display-mode" value="static" onchange="handleDisplayModeChange()">
                            <label for="mode-static">
                                <span class="icon">📄</span>
                                Static List
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-loop-incompleted" name="display-mode" value="loop-incompleted"  onchange="handleDisplayModeChange()">
                            <label for="mode-loop-incompleted">
                                <span class="icon">⚡</span>
                                Loop Active
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-loop-all" name="display-mode" value="loop-all" onchange="handleDisplayModeChange()">
                            <label for="mode-loop-all">
                                <span class="icon">🔄</span>
                                Loop All
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-bounce" name="display-mode" value="bounce" onchange="handleDisplayModeChange()">
                            <label for="mode-bounce">
                                <span class="icon">↕️</span>
                                 Auto-scroll Mode 
                            </label>
                        </div>

                        <div class="mode-option">
                            <input type="radio" id="mode-rotate-incompleted" name="display-mode" value="rotate-incompleted" checked onchange="handleDisplayModeChange()">
                            <label for="mode-rotate-incompleted">
                                <span class="icon">📌</span>
                                Pinned Top <br> + looped
                            </label>
                        </div>
                    </div>

                    <div class="mode-description" id="mode-description">
                        Current tasks are displayed in a static list.
                    </div>
                </div> <div class="minimal-mode-toggle">
                    <h3>Minimal View</h3>
                    <div class="switch-container">
                        <div>
                            <input type="radio" id="mode-normal" name="minimal-mode" value="normal" checked>
                            <label for="mode-normal">Normal</label>
                        </div>
                        <div>
                            <input type="radio" id="mode-minimal" name="minimal-mode" value="minimal">
                            <label for="mode-minimal">Minimal</label>
                        </div>
                    </div>
                </div>
                            


            </div> 
            
        
            <div id="reporting-content-wrapper" style="display: none;">
                <!-- Guest mode reporting message -->
                <div id="guest-reporting-message" class="guest-reporting-message" style="display: none;">
                    <h3>Reporting Features</h3>
                    <p>Please sign in to access reporting features.</p>
                    <p>Guest mode only allows task management. Sign up or log in to view statistics, streaks, and insights.</p>
                </div>
                
                <!-- Regular reporting content (hidden for guests) -->
                <div id="authenticated-reporting-content">
                    <div class="section-header">
                        <h2>Your Statistics</h2>
                    </div>
                    
                    <div class="reporting-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="report-current-streak">0</div>
                            <div class="stat-label">Current Streak</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="report-longest-streak">0</div>
                            <div class="stat-label">Longest Streak</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="report-total-completed">0</div>
                            <div class="stat-label">Total Tasks Completed</div>
                        </div>
                        <!-- Total Hours in Reporting -->
                        <div class="stat-card">
                            <div class="stat-value" id="report-total-hours">0</div>
                            <div class="stat-label">Total Hours</div>
                        </div>
                    </div>

                    <div class="reward-section" id="reward-section">
                        <div class="reward-header">
                            <h3 id="reward-quest-title">Current Quest: The 1000 Hour Journey</h3>
                        </div>

                        <div id="reward-active-state">
                            <div class="character-stage">
                                <div class="reward-bubble">
                                    <div class="reward-inputs">
                                        <input type="text" class="reward-input-line" id="reward-input-1" placeholder="Reward 1 (e.g. New Monitor)" onchange="saveRewardData()">
                                        <input type="text" class="reward-input-line" id="reward-input-2" placeholder="Reward 2 (e.g. Vacation)" onchange="saveRewardData()">
                                    </div>
                                </div>
                                <img src="img/gift.png" 
                                    alt="Reward Character" 
                                    class="coin-character-img" 
                                    id="active-character-img"
                                    onclick="pokeCharacter()">
                            </div>

                            <div class="reward-progress-container">
                                <div class="reward-progress-track">
                                    <div class="reward-progress-fill" id="reward-progress-bar" style="width: 0%"></div>
                                </div>
                                <div class="reward-stats-text" id="reward-progress-text">
                                    0 / 1000 Hours
                                </div>
                            </div>
                        </div>

                        <div id="reward-win-state" style="display: none; padding: 40px 0;">
                            <h2 class="golden-text">Congratulations!</h2>
                            <p style="color: var(--primary-light); margin-bottom: 20px; font-size: 1.1rem;">
                                You have unlocked your rewards!
                                <br>
                                <span id="won-rewards-text" style="color: #fdcb6e; font-weight: bold;"></span>
                            </p>
                            <button class="restart-btn" id="claim-reward-btn" onclick="resetRewardJourney(event)">Start Next Level</button>
                        </div>

                        <button id="toggle-collection-btn" onclick="toggleCollection()" style="display:none; margin: 20px auto 0; background:none; border:1px solid var(--primary-light); color:var(--primary-light); padding: 5px 15px; border-radius: 15px; cursor: pointer; font-size: 0.8rem;">
                            View Reward Collection 📦
                        </button>

                        <div class="reward-collection" id="reward-collection-section" style="display: none;">
                            <h4 style="color: var(--primary-light); font-size: 0.8rem;">Past Victories</h4>
                            <div class="collection-grid" id="collection-grid">
                                </div>
                        </div>
                    </div>




                    <!--  Insights Section -->
                    <div class="insights-section">
                        <h3>AI Insights</h3>
                        <button id="generate-insights-btn">Generate AI Insights</button>
                        <div id="insights-loading">
                            <p>Generating insights... This may take a few moments.</p>
                        </div>
                        <div id="insights-result"></div>
                    </div>

                    <!--  Flex container for Calendar and Keyword Chart -->
                    <div class="reporting-flex-container">
                        
                        <!--  Streak Calendar -->
                        <div class="streak-calendar-container">
                            <div class="streak-calendar-header">
                                <h3>Streak Calendar</h3>
                                <div class="calendar-nav">
                                    <button class="calendar-nav-btn" id="prev-month-btn">&lt;</button>
                                    <span class="current-month" id="current-month-display">January 2023</span>
                                    <button class="calendar-nav-btn" id="next-month-btn">&gt;</button>
                                </div>
                            </div>
                            
                            <div class="calendar-grid" id="calendar-days-header">
                                <div class="calendar-day-header">Sun</div>
                                <div class="calendar-day-header">Mon</div>
                                <div class="calendar-day-header">Tue</div>
                                <div class="calendar-day-header">Wed</div>
                                <div class="calendar-day-header">Thu</div>
                                <div class="calendar-day-header">Fri</div>
                                <div class="calendar-day-header">Sat</div>
                            </div>
                            
                            <div class="calendar-grid" id="calendar-days"></div>
                            
                            <div class="streak-stats">
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-current">0 days</div>
                                    <div class="streak-label">Current Streak</div>
                                </div>
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-longest">0 days</div>
                                    <div class="streak-label">Longest Streak</div>
                                </div>
                                <div class="streak-stat">
                                    <div class="streak-value" id="streak-total">0 days</div>
                                    <div class="streak-label">Total Streak Days</div>
                                </div>
                            </div>
                        
                            <div class="streak-legend">
                                <div class="legend-item">
                                    <div class="legend-color legend-streak"></div>
                                    <span>Task Completed</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color legend-frozen"></div>
                                    <span>Streak Frozen</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color legend-today"></div>
                                    <span>Today</span>
                                </div>
                            </div>
                        </div>

                        <!--  Time Spent Per Keyword Chart -->
                        <div class="chart-container" style="margin-top: 60px !important;">
                            <h3>Time Spent Per Keyword (Completed Tasks)</h3> 
                            <div style="position: relative; flex: 1; min-height: 0; width: 100%;">
                                <canvas id="time-per-keyword-chart"></canvas>
                            </div>
                        </div>
                    </div>


                    <!-- Daily Progress Chart -->
                    <div class="chart-container" style="margin-top: 20px; margin-bottom: 80px;">
                        <h3>Daily Progress</h3>
                        
                        <div class="mode-selector" style="margin-bottom: 10px; justify-content: center;">
                            <div class="mode-option">
                                <input type="radio" id="metric-time" name="daily-progress-metric" value="time" >
                                <label for="metric-time">Time Spent</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="metric-tasks" name="daily-progress-metric" value="tasks" checked>>
                                <label for="metric-tasks">Tasks Completed</label>
                            </div>
                        </div>

                        <div class="mode-selector" style="margin-bottom: 15px; justify-content: center; font-size: 0.8rem;">
                            <div class="mode-option">
                                <input type="radio" id="range-7" name="daily-progress-range" value="7" checked>
                                <label for="range-7">7 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-30" name="daily-progress-range" value="30">
                                <label for="range-30">30 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-90" name="daily-progress-range" value="90">
                                <label for="range-90">90 Days</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-365" name="daily-progress-range" value="365">
                                <label for="range-365">1 Year</label>
                            </div>
                            <div class="mode-option">
                                <input type="radio" id="range-lifetime" name="daily-progress-range" value="lifetime">
                                <label for="range-lifetime">Lifetime</label>
                            </div>
                        </div>

                        <canvas id="daily-progress-chart"></canvas>
                    </div>    
        
                    <!-- Cumulative Tasks Chart -->
                    <div class="chart-container" style="margin-top: 20px;">
                        <h3>Cumulative Tasks Completed Over Time</h3>
                        <canvas id="cumulative-tasks-chart"></canvas>
                    </div>
                    
                    <div class="chart-container" style="margin-top: 20px;">
                        <h3>Cumulative Time Spent Over Time (Hours)</h3>
                        <canvas id="cumulative-time-chart"></canvas>
                    </div>

                    <div class="chart-container" style="height: auto; min-height: 200px; margin-top: 20px;">
                        <h3>Weekly Progress Log</h3>
                        <div class="table-responsive">
                            <table class="weekly-table">
                                <thead>
                                    <tr>
                                        <th>Week Of</th>
                                        <th>Hours</th>
                                        <th>Top Focus (Keywords)</th>
                                    </tr>
                                </thead>
                                <tbody id="weekly-progress-body">
                                    </tbody>
                            </table>
                        </div>
                    </div>
                    
                </div>
            </div> 
   
        </div> 
    </div>








        
     <div class="footer">
            <div class="footer-status-wrapper">
                <button id="toggle-user-status-btn" title="Show/Hide User Status">🔒</button>
                <span id="user-status" class="hidden-status"></span>
            </div>

            <a id="footer-setup-guide" href="https://docs.obs-todo.com/" target="_blank" style="
                display: none; /* Hidden by default */
                color: var(--primary-light); 
                background: transparent;
                border: none;
                border-radius: 0;
                border-bottom: 1px solid var(--primary-light); /* The line below */
                text-decoration: none; 
                padding: 0;
                padding-bottom: 2px; /* Slight gap for the underline */
                font-size: 0.8rem;
                margin-top: 10px;
                opacity: 0.7;
                cursor: pointer;
                transition: all 0.2s ease;
            "
            onmouseover="this.style.opacity='1'; this.style.color='var(--secondary)'; this.style.borderBottomColor='var(--secondary)'"
            onmouseout="this.style.opacity='0.7'; this.style.color='var(--primary-light)'; this.style.borderBottomColor='var(--primary-light)'">
                Setup Guide
            </a>
            
            <p id="timestamp">Updated: --</p>
        </div>

        
    </div>

    <div class="keyword-management" id="keyword-management">
        <div class="keyword-management-content">
            <div class="keyword-management-header">
                <h3>Manage Keywords</h3>
                <button class="close-keyword-management" id="close-keyword-management">&times;</button>
            </div>
            <div class="keyword-list" id="keyword-list-manager"></div>
            <div class="new-keyword-input">
                <input type="text" id="new-keyword-input" placeholder="Add a new keyword...">
                <button id="add-new-keyword-btn">Add</button>
            </div>
        </div>
    </div>

    <!-- Firebase Functions Script -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-functions-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDEEMO9MlcNsb_QLIRTDJM4rXqxGZuYJps",
            authDomain: "obs-todo-68da2.firebaseapp.com",
            databaseURL: "https://obs-todo-68da2-default-rtdb.firebaseio.com",
            projectId: "obs-todo-68da2",
            storageBucket: "obs-todo-68da2.firebasestorage.app",
            messagingSenderId: "594250582895",
            appId: "1:594250582895:web:62414c9f759b99904cb69a",
            measurementId: "G-N94MD8GRJQ"
        };

        let useFirebase = false;
        try {
            if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                firebase.initializeApp(firebaseConfig);
                useFirebase = true;
            }
        } catch (err) {
            console.warn('Firebase init failed, falling back to localStorage:', err);
            useFirebase = false;
        }

        


        // DOM elements
        const taskListEl = document.getElementById('task-list');
        const tasksContainer = document.getElementById('tasks-container');
        const conveyorContainer = document.getElementById('conveyor-container');
        const conveyorTrack = document.getElementById('conveyor-track');
        const inputEl = document.getElementById('new-task-input');
        const addBtn = document.getElementById('add-task-btn');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const completedCount = document.getElementById('completed-count');
        const remainingCount = document.getElementById('remaining-count');
        const timestampEl = document.getElementById('timestamp');
        const tabs = document.querySelectorAll('.tab');
        const dailyTotalEl = document.getElementById('daily-total');
        const lifetimeTotalEl = document.getElementById('lifetime-total');
        const manageKeywordsBtn = document.getElementById('manage-keywords-btn');
        const keywordManagement = document.getElementById('keyword-management');
        const closeKeywordManagement = document.getElementById('close-keyword-management');
        const keywordListManager = document.getElementById('keyword-list-manager');
        const newKeywordInput = document.getElementById('new-keyword-input');
        const addNewKeywordBtn = document.getElementById('add-new-keyword-btn');

        //  Authentication DOM elements
        const loginContainer = document.getElementById('login-container');
        const dashboardWrapper = document.getElementById('dashboard-wrapper');
        const logoutBtn = document.getElementById('logout-btn');
        const signupForm = document.getElementById('signup-form');
        const loginForm = document.getElementById('login-form');
        const signupEmail = document.getElementById('signup-email');
        const signupPassword = document.getElementById('signup-password');
        const loginEmail = document.getElementById('login-email');
        const loginPassword = document.getElementById('login-password');
        const guestBtn = document.getElementById('guest-btn');
        const userStatusEl = document.getElementById('user-status');
        const toggleUserStatusBtn = document.getElementById('toggle-user-status-btn');

        // Password Reset DOM elements
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const passwordResetContainer = document.getElementById('password-reset-container');
        const passwordResetForm = document.getElementById('password-reset-form');
        const resetEmail = document.getElementById('reset-email');
        const resetPasswordBtn = document.getElementById('reset-password-btn');
        const backToLoginBtn = document.getElementById('back-to-login-btn');
        const resetMessage = document.getElementById('reset-message');

        // Content wrapper DOM elements
        const taskContentWrapper = document.getElementById('task-content-wrapper');
        const reportingContentWrapper = document.getElementById('reporting-content-wrapper');

        const loadMoreBtn = document.getElementById('load-more-btn');
        const noMoreTasksMsg = document.getElementById('no-more-tasks-msg');

        const guestReportingMessage = document.getElementById('guest-reporting-message');
        const authenticatedReportingContent = document.getElementById('authenticated-reporting-content');

        // Streak Calendar DOM elements
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const currentMonthDisplayEl = document.getElementById('current-month-display');
        const calendarDaysEl = document.getElementById('calendar-days');
        const streakCurrentEl = document.getElementById('streak-current');
        const streakLongestEl = document.getElementById('streak-longest');
        const streakTotalEl = document.getElementById('streak-total');

        // Total Hours DOM elements
        const totalHoursEl = document.getElementById('total-hours');
        const reportTotalHoursEl = document.getElementById('report-total-hours');

        // Insights DOM elements
        const generateInsightsBtn = document.getElementById('generate-insights-btn');
        const insightsLoading = document.getElementById('insights-loading');
        const insightsResult = document.getElementById('insights-result');

        // App state
        let tasks = {};
        let dbRef = null;
        let currentTab = 'active'; 
        let completedDaysRange = 1; 
        let timerIntervals = {};
        let dragSrcEl = null;
        let editingTaskId = null;
        let editingKeywordIndex = null;
        let expandedTasks = {}; 
        let taskInactivityTimers = {};
        // Add this variable with your other app state variables
        let masterAnimationFrame = null;
        let lastFrameTime = 0;

        // Display mode variables
        let displayMode = 'static';
        let conveyorInterval = null;
        let conveyorTasks = [];
        let conveyorPosition = 0;
        let isConveyorPaused = false;
        let conveyorSpeed = 30; 
        let bounceDirection = 1;
        let bouncePauseTimer = 0;
        let isAnimatingCompletion = false; // <--- ADD THIS

        // Default keywords
        let keywords = ['Work', 'Personal', 'Urgent', 'Important', 'Shopping'];

        // Chart variables
        let timePerKeywordChart = null;
        let cumulativeTasksChart = null; 
        let cumulativeTimeChart = null; 
        let dailyProgressChart = null; 


        // Authentication state
        let currentUser = null;
        let currentUserId = null;
        let isGuest = false;

        // Minimal mode state
        let minimalMode = false;

        // --- STREAK CALENDAR VARIABLES ---
        let currentCalendarDate = new Date();
        let streakData = {}; 
        let frozenStreakDays = {}; 

        // --- POMODORO STATE ---
        let isPomodoroMode = false;
        let pomoState = 'IDLE'; // 'IDLE', 'WORK', 'BREAK', 'PAUSED'
        let pomoDurationMins = 25;
        let pomoBreakMins = 5;
        let pomoTimeLeft = 25 * 60 * 1000; // ms
        let pomoAccumulatedContribution = 0; // Seconds tracked for stats
        let lastPomoTick = 0;
        let pomoEndTime = null;
        let lastUiUpdate = 0;

        let timerIntervals = {};
        let pendingPauses = new Set(); // <--- ADD THIS LINE
        let dragSrcEl = null;



        const alarmSound = document.getElementById('pomo-alarm');

        function clearTaskTimer(taskId) {
            if (taskInactivityTimers[taskId]) {
                clearTimeout(taskInactivityTimers[taskId]);
                delete taskInactivityTimers[taskId];
            }
        }
        function startTaskTimer(taskId) {
            clearTaskTimer(taskId); // Ensure no duplicate timers
            taskInactivityTimers[taskId] = setTimeout(() => {
                if (expandedTasks[taskId]) {
                    expandedTasks[taskId] = false;
                    renderTasks(); // Re-render to update UI
                }
            }, 4000);
        }
        // --- NEW HELPER: Generate Default Tasks ---
        function generateDefaultTasks() {
            const defaultTasks = {};
            const texts = [
                "My 1st Task",
                "My 2nd Task",
                "My 3rd Task",
                "My 4th Task",
                "My 5th Task"
            ];

            texts.forEach((text, index) => {
                const id = `default-${Date.now()}-${index}`;
                defaultTasks[id] = {
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    order: index,
                    timeSpent: 0,
                    timerStartTime: null,
                    lastUpdated: new Date().toISOString(),
                    keywords: []
                };
            });
            return defaultTasks;
        }



        function setupModeListeners() {
            if (!useFirebase || !currentUserId || isGuest) return;

            // 1. Listen for Display Mode Changes (Static, Loop, etc.)
            firebase.database().ref('users/' + currentUserId + '/displayMode').on('value', snap => {
                const newMode = snap.val();
                // Only act if the mode is actually different from what we have
                if (newMode && newMode !== displayMode) {
                    console.log("Remote display mode change detected:", newMode);
                    displayMode = newMode;
                    
                    // Update the Radio Button UI
                    const radio = document.getElementById(`mode-${displayMode}`);
                    if (radio) radio.checked = true;
                    
                    // Update Text Description
                    updateModeDescription();
                    
                    // Reset/Restart Conveyor Logic
                    stopConveyor();
                    
                    // Reset conveyor logic based on new mode
                    if (displayMode !== 'static' && currentTab === 'active') {
                        initConveyor();
                    } else {
                        conveyorContainer.classList.remove('conveyor-container');
                        conveyorTrack.style.transform = 'translateY(0)';
                        renderTasks();
                    }
                    
                    // Trigger OBS refresh
                    triggerObsRefresh();
                }
            });

            // 2. Listen for Minimal Mode Changes
            firebase.database().ref('users/' + currentUserId + '/minimalMode').on('value', snap => {
                const newMinimal = snap.val();
                // Only act if changed
                if (newMinimal !== null && newMinimal !== minimalMode) {
                    console.log("Remote minimal mode change detected:", newMinimal);
                    minimalMode = newMinimal;
                    
                    // Update UI
                    const radio = document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`);
                    if (radio) radio.checked = true;
                    
                    applyMinimalMode();
                }
            });
        }










        // --- POMODORO LOGIC ---

        function handleTimerModeChange() {
            const mode = document.querySelector('input[name="timer-mode"]:checked').value;
            isPomodoroMode = (mode === 'pomodoro');

            const normalContainer = document.getElementById('normal-timer-container');
            const pomoContainer = document.getElementById('pomodoro-container');

            if (isPomodoroMode) {
                normalContainer.style.display = 'none';
                pomoContainer.style.display = 'flex';
            } else {
                normalContainer.style.display = 'flex';
                pomoContainer.style.display = 'none';
                // Optional: Pause pomodoro if switching away
                if (pomoState === 'WORK' || pomoState === 'BREAK') {
                    togglePomodoroAction(); 
                }
            }
        }

        function selectPomoDuration(mins) {
            if (pomoState === 'WORK' || pomoState === 'BREAK') return; // Lock while running

            pomoDurationMins = mins;
            pomoBreakMins = (mins === 25) ? 5 : 10;
            
            // Visual update for buttons
            document.getElementById('btn-25').classList.toggle('active-opt', mins === 25);
            document.getElementById('btn-50').classList.toggle('active-opt', mins === 50);
            
            resetPomodoro();
        }

        function resetPomodoro() {
            pomoState = 'IDLE';
            pomoTimeLeft = pomoDurationMins * 60 * 1000;
            pomoAccumulatedContribution = 0;
            
            updatePomoDisplay();
            document.getElementById('pomo-action-btn').textContent = '▶';
            document.getElementById('pomo-status-label').textContent = 'Ready to Focus';
            document.getElementById('pomo-timer-display').style.color = 'var(--accent)';
        }

        function togglePomodoroAction() {
            const btn = document.getElementById('pomo-action-btn');
            const label = document.getElementById('pomo-status-label');
            
            if (pomoState === 'IDLE' || pomoState === 'PAUSED') {
                // START or RESUME
                if (pomoState === 'IDLE') {
                    // Starting fresh work session
                    pomoState = 'WORK';
                    pomoTimeLeft = pomoDurationMins * 60 * 1000;
                    pomoAccumulatedContribution = 0;
                } else {
                    // Resuming
                    if (label.textContent.includes('Break')) {
                        pomoState = 'BREAK';
                    } else {
                        pomoState = 'WORK';
                    }
                }
                
                // --- NEW: Set the absolute End Time based on current time + remaining time ---
                pomoEndTime = Date.now() + pomoTimeLeft; 

                btn.textContent = '❚❚';
                label.textContent = (pomoState === 'WORK') ? 'Focusing...' : 'Break Time';
                
                // Ensure Loop is running
                if (!masterAnimationFrame) startMasterLoop();
                
            } else {
                // PAUSE
                pomoState = 'PAUSED';
                
                // --- NEW: Clear the End Time so we don't keep counting while paused ---
                pomoEndTime = null;

                btn.textContent = '▶';
                label.textContent = (label.textContent.includes('Break')) ? 'Break Paused' : 'Work Paused';
                
                // Optional: We can try to stop the loop here if no other timers are running to save resources
                // But leaving it running is safer to prevent bugs.
            }
}

       function updatePomodoro(deltaTime) {
            if (!isPomodoroMode) return;
            if (pomoState !== 'WORK' && pomoState !== 'BREAK') return;

            // --- NEW: Calculate time based on absolute timestamp ---
            if (pomoEndTime) {
                const now = Date.now();
                pomoTimeLeft = pomoEndTime - now;
            } else {
                // Fallback (shouldn't usually happen if toggle sets endTime correctly)
                pomoTimeLeft -= deltaTime; 
            }

            // --- SMART TIME TRACKING LOGIC ---
            // Only accumulate "Pomo Time" if NO other tasks are running
            // And only during WORK phase
            if (pomoState === 'WORK') {
                if (Object.keys(timerIntervals).length === 0) {
                    // Convert ms to seconds for accumulation
                    pomoAccumulatedContribution += (deltaTime / 1000);
                }
            }
            
            // Check for completion
            if (pomoTimeLeft <= 0) {
                pomoTimeLeft = 0;
                pomoEndTime = null; // Clear the target time
                completePomodoroPhase();
            }

            updatePomoDisplay();
            // Force update global stats so "Today" timer updates in real-time with Pomo contribution
            updateTimeStats(); 
        }


        function updatePomoDisplay() {
            const totalSeconds = Math.ceil(pomoTimeLeft / 1000);
            const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            document.getElementById('pomo-timer-display').textContent = `${m}:${s}`;
        }

        function playThreeTimes(audio) {
            let count = 0;
            
            // Reset audio to start (just in case)
            audio.currentTime = 0;
            
            // 1. Define what happens when audio ends
            audio.onended = () => {
                count++;
                if (count < 3) {
                    audio.currentTime = 0;
                    audio.play().catch(() => {});
                } else {
                    // IMPORTANT: Clean up! Remove the listener so it doesn't 
                    // interfere if you click the button again later.
                    audio.onended = null; 
                }
            };

    // 2. Start the first play
    audio.play().catch(() => {});
}

        function completePomodoroPhase() {
            // 1. Audio & Visuals
            playThreeTimes(alarmSound);
            document.body.classList.add('pomo-finished-anim');
            setTimeout(() => document.body.classList.remove('pomo-finished-anim'), 2000);

            const btn = document.getElementById('pomo-action-btn');
            const label = document.getElementById('pomo-status-label');
            const display = document.getElementById('pomo-timer-display');

            if (pomoState === 'WORK') {
                // --- WORK FINISHED ---
                
                // 1. Save the Task
                savePomodoroTask();
                
                // 2. Switch to Break
                pomoState = 'BREAK';
                pomoTimeLeft = pomoBreakMins * 60 * 1000;
                
                label.textContent = 'Break Time!';
                display.style.color = 'var(--secondary)'; // Green for break
                
            } else {
                // --- BREAK FINISHED ---
                pomoState = 'IDLE';
                btn.textContent = '▶';
                label.textContent = 'Session Complete';
                display.style.color = 'var(--accent)';
                resetPomodoro();
            }
        }

        function savePomodoroTask() {
            // Create a completed task with the accumulated time
            const timeSpent = Math.floor(pomoAccumulatedContribution);
            
            // If 0 time was contributed (because user ran other tasks the whole time),
            // we still save it as a record, but timeSpent is 0.
            
            const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `pomo-${Date.now()}`;
            
            const newTask = {
                text: `Pomodoro Session (${pomoDurationMins} min)`,
                completed: true,
                completedAt: new Date().toISOString(),
                createdAt: new Date().toISOString(),
                order: 0,
                timeSpent: timeSpent, 
                timerStartTime: null,
                lastUpdated: new Date().toISOString(),
                keywords: ['Pomodoro'] 
            };
            
            if (useFirebase && !isGuest) {
                dbRef.child(newTaskId).set(newTask);
            } else {
                tasks[newTaskId] = newTask;
                saveAllTasks();
                renderTasks(); // Update list
            }
            
            // Reset accumulation so we don't double count visually until next session
            pomoAccumulatedContribution = 0;
        }




           // Add this variable outside the function to track UI updates

        function startMasterLoop() {
            if (masterAnimationFrame) cancelAnimationFrame(masterAnimationFrame);
            lastFrameTime = performance.now();
            
            function loop(timestamp) {
                const deltaTime = timestamp - lastFrameTime;
                lastFrameTime = timestamp;

                // 1. Conveyor Logic (KEEPS RUNNING EVERY FRAME = SMOOTH)
                if (displayMode !== 'static' && !isConveyorPaused && conveyorTasks.length > 0) {
                    moveConveyor(deltaTime); 
                }

                // 2. Update Logic (Math calculations run every frame)
                updatePomodoro(deltaTime);

                // 3. UI UPDATES (THROTTLED)
                // Only update the text on screen if 1 second has passed
                if (timestamp - lastUiUpdate >= 1000) {
                    
                    // Update Normal Task Timers
                    Object.keys(timerIntervals).forEach(taskId => {
                        updateTaskDisplay(taskId);
                    });

                    // Update Pomodoro Display text (if needed)
                    if (isPomodoroMode) {
                        updatePomoDisplay();
                    }

                    lastUiUpdate = timestamp;
                }

                masterAnimationFrame = requestAnimationFrame(loop);
            }
            
            masterAnimationFrame = requestAnimationFrame(loop);
        }
                    


        

        function stopMasterLoop() {
            if (masterAnimationFrame) {
                cancelAnimationFrame(masterAnimationFrame);
                masterAnimationFrame = null;
            }
        }
        
        // --- New Function to Toggle User Status Visibility ---
        function toggleUserStatus() {
            // Check if it currently has the hidden-status class
            const isHidden = userStatusEl.classList.contains('hidden-status');
            
            if (isHidden) {
                // SHOW: Remove hidden class and add visible class
                userStatusEl.classList.remove('hidden-status');
                userStatusEl.classList.add('visible-status');
                // Change icon to 'unlocked/open eye'
                toggleUserStatusBtn.textContent = '👁️'; 
                toggleUserStatusBtn.title = 'Hide User Status';
                
                // Ensure the correct text color is set for visibility
                if (isGuest) {
                    userStatusEl.style.color = "var(--accent)";
                } else {
                    userStatusEl.style.color = "var(--primary-light)";
                }
                
            } else {
                // HIDE: Remove visible class and add hidden class
                userStatusEl.classList.remove('visible-status');
                userStatusEl.classList.add('hidden-status');
                // Change icon to 'locked/closed eye'
                toggleUserStatusBtn.textContent = '🔒'; 
                toggleUserStatusBtn.title = 'Show User Status';
                
                // The CSS handles changing the color to transparent
            }
        }
        // Utility function to check if a date is today
        function isToday(date) {
            const today = new Date();
            const checkDate = new Date(date);
            return checkDate.getDate() === today.getDate() &&
                   checkDate.getMonth() === today.getMonth() &&
                   checkDate.getFullYear() === today.getFullYear();
        }

        // --- Reporting Helper Functions ---
        // Helper function to check if two dates are the same day
        function isSameDay(d1, d2) {
            const date1 = new Date(d1);
            const date2 = new Date(d2);
            return date1.getFullYear() === date2.getFullYear() &&
                    date1.getMonth() === date2.getMonth() &&
                    date1.getDate() === date2.getDate();
        }

        // Helper function to add days to a date
        function addDays(date, days) {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        }

        // Function to trigger OBS refresh
        function triggerObsRefresh() {
            const now = new Date().getTime();
            window.location.hash = `refresh=${now}`;
        }
        
        // Format date for display
        function formatDate(date) {
            const d = new Date(date);
            const now = new Date();
            const diffTime = now.getTime() - d.getTime();
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return `Today at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else if (diffDays === 1) {
                return `Yesterday at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else {
                return `${d.toLocaleDateString()} at ${d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            }
        }

        // Timer functions
        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Format time in hours
        function formatTimeInHours(seconds) {
            const hours = (seconds / 3600).toFixed(1);
            return `${hours} hours`;
        }



        function restoreRunningTimers() {
            Object.keys(tasks).forEach(taskId => {
                const task = tasks[taskId];

                // If the DB says it's paused (null), we can stop ignoring it
                if (!task.timerStartTime) {
                    pendingPauses.delete(taskId);
                }

                // If we are waiting for a pause to sync, DO NOT restart this timer
                if (pendingPauses.has(taskId)) {
                    // Force local state to remain paused despite what the old DB snapshot says
                    task.timerStartTime = null; 
                    return;
                }

                // Normal restore logic
                if (task.timerStartTime && !task.completed && !timerIntervals[taskId]) {
                    startTimer(taskId); 
                }
            });
        }

        function startTimer(taskId) {
            if (timerIntervals[taskId]) return; // Timer already running
            
            // Check if task exists
            if (!tasks[taskId]) return;

            // --- FIX: Remove from ignore list if user manually starts it ---
            // This allows the user to manually override a pause state
            if (typeof pendingPauses !== 'undefined') {
                pendingPauses.delete(taskId);
            }

            // Ensure valid start time locally
            if (!tasks[taskId].timerStartTime) {
                tasks[taskId].timerStartTime = Date.now();
            }
            
            // We use the ID as a flag that the timer is running
            timerIntervals[taskId] = {
                // Only save to storage every 10 seconds to prevent lag/stutter
                storageInterval: setInterval(() => {
                    // --- FIX: Always fetch the LATEST task object from the global list ---
                    const currentTask = tasks[taskId];

                    // --- FIX: Safety Check ---
                    // If the task was deleted OR if the database says it's paused (timerStartTime is null),
                    // we must STOP this local timer immediately.
                    if (!currentTask || !currentTask.timerStartTime) {
                        clearInterval(timerIntervals[taskId].storageInterval);
                        delete timerIntervals[taskId];
                        
                        // Update UI button to show 'Paused' state
                        const btn = document.getElementById(`quick-btn-${taskId}`);
                        if(btn) {
                            btn.classList.remove('running');
                            btn.innerHTML = '▶';
                            btn.title = 'Start Timer';
                            btn.setAttribute('onclick', `event.stopPropagation(); startTimer('${taskId}')`);
                        }
                        return; 
                    }

                    // Calculate time using the FRESH task object
                    const elapsed = Math.floor((Date.now() - currentTask.timerStartTime) / 1000);
                    if (elapsed > 0) {
                        // Update local object
                        currentTask.timeSpent = (currentTask.timeSpent || 0) + elapsed;
                        currentTask.timerStartTime = Date.now();
                        
                        // Save silently
                        if (useFirebase && !isGuest) {
                            dbRef.child(taskId).child('timeSpent').set(currentTask.timeSpent);
                            dbRef.child(taskId).child('timerStartTime').set(currentTask.timerStartTime);
                        } else {
                            localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
                        }
                    }
                }, 10000) // Save every 10 seconds
            };
            
            // Visual update immediately
            const btn = document.getElementById(`quick-btn-${taskId}`);
            if(btn) {
                btn.classList.add('running');
                btn.innerHTML = '❚❚';
                btn.title = 'Pause Timer';
                btn.setAttribute('onclick', `event.stopPropagation(); pauseTimer('${taskId}')`);
            }
            
            // Ensure master loop is running
            if (!masterAnimationFrame) startMasterLoop();
        }

        function pauseTimer(taskId) {
            if (timerIntervals[taskId]) {
                // Add to pending pauses so the database listener doesn't "resurrect" it
                pendingPauses.add(taskId); // <--- ADD THIS LINE

                // Clear the storage saver
                clearInterval(timerIntervals[taskId].storageInterval);
                delete timerIntervals[taskId];
                
                const task = tasks[taskId];
                if (task.timerStartTime) {
                    // Calculate final elapsed time
                    const elapsed = (Date.now() - task.timerStartTime) / 1000;
                    task.timeSpent = (task.timeSpent || 0) + elapsed;
                    task.timerStartTime = null;
                }
                
                // Force a save immediately upon pausing
                updateTaskInStorage(taskId);
                updateTaskDisplay(taskId); // Final visual update
                updateTimeStats();
                
                // Visual update
                const btn = document.getElementById(`quick-btn-${taskId}`);
                if(btn) {
                    btn.classList.remove('running');
                    btn.innerHTML = '▶';
                    btn.title = 'Start Timer';
                    btn.setAttribute('onclick', `event.stopPropagation(); startTimer('${taskId}')`);
                }
            }
        }
        // Add this missing function so buttons don't crash
        function stopTimer(taskId) {
            pauseTimer(taskId);
        }

        // function to calculate current display time accurately
        function getCurrentDisplayTime(task) {
            if (task.timerStartTime && timerIntervals[task.id]) {
                const elapsedSeconds = (Date.now() - task.timerStartTime) / 1000;
                return (task.timeSpent || 0) + elapsedSeconds;
            } else {
                return task.timeSpent || 0;
            }
        }

        // Time statistics functions
       
        // --- DEBUG VERSION: calculateDailyTotal ---
        function calculateDailyTotal() {
            const today = new Date().toDateString();
            let totalSeconds = 0;
            
            console.group("🔍 DEBUG: calculateDailyTotal");
            console.log("📅 Target 'Today' Date:", today);
            console.log("📦 Total Tasks to check:", Object.keys(tasks).length);

            Object.entries(tasks).forEach(([taskId, task]) => {
                // Calculate the time to add for this specific task
                const timeToUse = getCurrentDisplayTime({ ...task, id: taskId });
                let added = false;

                // Check 1: Is it completed today?
                if (task.completedAt) {
                    const completedDate = new Date(task.completedAt).toDateString();
                    if (completedDate === today) {
                        totalSeconds += timeToUse;
                        added = true;
                        console.log(`   ✅ Task [${task.text}] (Completed): Added ${timeToUse}s`);
                    }
                } 
                // Check 2: Was it updated/worked on today (even if active)?
                else if (task.timeSpent && task.lastUpdated) {
                    const lastUpdatedDate = new Date(task.lastUpdated).toDateString();
                    if (lastUpdatedDate === today) {
                        totalSeconds += timeToUse;
                        added = true;
                        console.log(`   ✅ Task [${task.text}] (Active/Updated): Added ${timeToUse}s`);
                    } else {
                        console.log(`   ❌ Task [${task.text}] (Active): Skipped. Last updated: ${lastUpdatedDate} vs Today: ${today}`);
                    }
                } 
                // Check 3: Is it currently running?
                else if (timerIntervals[taskId]) { 
                    totalSeconds += timeToUse;
                    added = true;
                    console.log(`   ⏱️ Task [${task.text}] (Running): Added ${timeToUse}s`);
                }
            });
            
            // Add Pomodoro time if active
            if (isPomodoroMode && (pomoState === 'WORK' || pomoState === 'PAUSED')) {
                totalSeconds += Math.floor(pomoAccumulatedContribution);
                console.log(`   🍅 Pomodoro active: Added ${Math.floor(pomoAccumulatedContribution)}s`);
            }
            
            console.log("🏁 Final Daily Total Seconds:", totalSeconds);
            console.groupEnd();
            return totalSeconds;
        }

        // --- DEBUG VERSION: updateTimeStats ---
        function updateTimeStats() {
            console.log("🔄 updateTimeStats CALLED");
            
            const dailyTotalSeconds = calculateDailyTotal();
            const lifetimeTotalSeconds = calculateLifetimeTotal();
            const totalHours = (lifetimeTotalSeconds / 3600).toFixed(1);
            
            console.log(`📊 Updating DOM with: Daily=${formatTime(dailyTotalSeconds)}, Total=${totalHours}h`);

            if (dailyTotalEl) dailyTotalEl.textContent = formatTime(dailyTotalSeconds);
            if (totalHoursEl) totalHoursEl.textContent = `${totalHours} hours`;
            if (reportTotalHoursEl) reportTotalHoursEl.textContent = totalHours;
        }


        function calculateLifetimeTotal() {
            let totalSeconds = 0;
            
            Object.entries(tasks).forEach(([taskId, task]) => {
                if (task.completed) {
                    const timeToUse = getCurrentDisplayTime({ ...task, id: taskId });
                    totalSeconds += timeToUse;
                }
            });
            
            return totalSeconds;
        }

  

        // Drag and drop functions
        function handleDragStart(e) {
            if (currentTab !== 'active') return;
            
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (dragSrcEl !== this) {
                const taskItems = Array.from(taskListEl.querySelectorAll('.task-item'));
                const srcIndex = taskItems.indexOf(dragSrcEl);
                const destIndex = taskItems.indexOf(this);
                
                if (srcIndex !== -1 && destIndex !== -1) {
                    const taskKeys = Object.keys(tasks).filter(key => !tasks[key].completed);
                    const movedKey = taskKeys[srcIndex];
                    
                    taskKeys.splice(srcIndex, 1);
                    taskKeys.splice(destIndex, 0, movedKey);
                    
                    taskKeys.forEach((key, index) => {
                        tasks[key].order = index;
                    });
                    
                    saveAllTasks();
                    renderTasks();
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('over', 'dragging');
            });
        }


        // Task removal function
        function removeTask(taskId) {
            // 1. SILENT KILL: Stop timer manually without calling pauseTimer()
            // This prevents the "Final Save" that resurrects the task
            if (timerIntervals[taskId]) {
                clearInterval(timerIntervals[taskId].storageInterval); // Stop the loop
                delete timerIntervals[taskId]; // Delete the reference
            }

            // 2. Remove from Database / Storage
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).remove();
            } else {
                delete tasks[taskId];
                saveAllTasks();
                renderTasks();
            }
            
            // 3. Update UI
            updateTimeStats();
            updateStats();
        }
        
        // --- Task Reordering Function ---
        function moveTask(taskId, direction) {
            if (currentTab !== 'active') return; 


            const activeTasks = Object.entries(tasks)
                .filter(([id, task]) => !task.completed)
                .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

            const taskKeys = activeTasks.map(([id]) => id);
            
            // Find the index of the task we're moving
            const currentIndex = taskKeys.indexOf(taskId);

            if (direction === 'up' && currentIndex > 0) {
                [taskKeys[currentIndex], taskKeys[currentIndex - 1]] = [taskKeys[currentIndex - 1], taskKeys[currentIndex]];
            } else if (direction === 'down' && currentIndex < taskKeys.length - 1) {
                [taskKeys[currentIndex], taskKeys[currentIndex + 1]] = [taskKeys[currentIndex + 1], taskKeys[currentIndex]];
            } else {
                return; 
            }

            taskKeys.forEach((key, index) => {
                tasks[key].order = index;
            });

            saveAllTasks();
            renderTasks();
        }
        // --- LONG PRESS LOGIC ---

        let longPressTimer = null;
        let visualTimer = null;
        const LONG_PRESS_DURATION = 1300; 
        const VISUAL_DELAY = 300;

        function startLongPress(taskId, element) {
            // 1. Start the Action Timer (The goal)
            longPressTimer = setTimeout(() => {
                moveTaskToTop(taskId);
                if (navigator.vibrate) navigator.vibrate(50);
                resetLongPress(element);
            }, LONG_PRESS_DURATION);

            // 2. Start the Visual Timer (Delays the animation start)
            visualTimer = setTimeout(() => {
                element.classList.add('holding-active');
            }, VISUAL_DELAY);
        }

        function cancelLongPress(element) {
            resetLongPress(element);
        }

        function resetLongPress(element) {
            // Clear Action Timer
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            
            // Clear Visual Timer (This prevents the animation on short clicks)
            if (visualTimer) {
                clearTimeout(visualTimer);
                visualTimer = null;
            }

            // Remove CSS class immediately
            if (element) {
                element.classList.remove('holding-active');
            }
        }
        function moveTaskToTop(taskId) {
            // 1. Get all active tasks sorted by current order
            const activeTasks = Object.entries(tasks)
                .filter(([id, task]) => !task.completed)
                .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

            // 2. Extract the task we want to move
            const taskIndex = activeTasks.findIndex(([id]) => id === taskId);
            if (taskIndex <= 0) return; // Already at top or not found

            const [movingId, movingTask] = activeTasks[taskIndex];
            
            // 3. Remove it from current position
            activeTasks.splice(taskIndex, 1);
            
            // 4. Add it to the very start (Index 0)
            activeTasks.unshift([movingId, movingTask]);

            // 5. Re-assign order numbers to everyone
            activeTasks.forEach(([id, task], index) => {
                tasks[id].order = index;
            });

            // 6. Save and Render
            saveAllTasks();
            renderTasks();
            
            // Optional: Flash the task to show it moved
            setTimeout(() => {
                const movedEl = document.querySelector(`.task-item[data-id="${taskId}"]`);
                if(movedEl) {
                    movedEl.classList.add('flash-success');
                    setTimeout(() => movedEl.classList.remove('flash-success'), 1000);
                }
            }, 50);
        }

        // Task editing functions
        function startEditingTask(taskId) {
            editingTaskId = taskId;
            renderTasks();
            
            // Focus the input field after a short delay
            setTimeout(() => {
                const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveTaskEdit(taskId) {
            const input = document.querySelector(`.task-item[data-id="${taskId}"] .task-input`);
            if (input) {
                const newText = input.value.trim();
                if (newText) {
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ text: newText });
                    } else {
                        tasks[taskId].text = newText;
                        saveAllTasks();
                    }
                }
            }
            editingTaskId = null;
            renderTasks();
        }

        function cancelTaskEdit() {
            editingTaskId = null;
            renderTasks();
        }

        // Keyword functions
        function toggleKeyword(taskId, keyword) {
            const task = tasks[taskId];
            if (!task.keywords) {
                task.keywords = [];
            }
            
            const index = task.keywords.indexOf(keyword);
            if (index === -1) {
                task.keywords.push(keyword);
            } else {
                task.keywords.splice(index, 1);
            }
            
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).update({ keywords: task.keywords });
            } else {
                saveAllTasks();
            }
            renderTasks();
        }

        function removeKeywordFromTask(taskId, keyword) {
            const task = tasks[taskId];
            if (task.keywords) {
                const index = task.keywords.indexOf(keyword);
                if (index !== -1) {
                    task.keywords.splice(index, 1);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                    renderTasks();
                }
            }
        }

        function addNewKeyword(taskId, keywordInputId) {
            const input = document.getElementById(keywordInputId);
            const newKeyword = input.value.trim();
            
            if (newKeyword) {
                if (!keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveKeywords();
                }
                
                const task = tasks[taskId];
                if (!task.keywords) {
                    task.keywords = [];
                }
                if (!task.keywords.includes(newKeyword)) {
                    task.keywords.push(newKeyword);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    } else {
                        saveAllTasks();
                    }
                }
                
                input.value = '';
                renderTasks();
            }
        }

        function saveKeywords() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/keywords').set(keywords);
            } else {
                localStorage.setItem('obs_todo_keywords', JSON.stringify(keywords));
            }
        }

        function loadKeywords() {
            // 1. Check if we have a user
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/keywords').once('value').then(snap => {
                    const storedKeywords = snap.val();
                    
                    // 2. If we found keywords in the database, use them
                    if (storedKeywords) {
                        keywords = storedKeywords;
                        
                        // 3. IMPORTANT: Force the UI to update immediately!
                        renderTasks();
                        // Also update the manager if it's open
                        if (document.getElementById('keyword-management').classList.contains('visible')) {
                            renderKeywordManager();
                        }
                    }
                });
            } else {
                // LocalStorage logic for Guest/Offline
                const stored = localStorage.getItem('obs_todo_keywords');
                if (stored) {
                    keywords = JSON.parse(stored);
                    renderTasks(); // Force update
                }
            }
        }

        // Display Mode Storage Functions
        function saveDisplayMode() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/displayMode').set(displayMode);
            } else {
                localStorage.setItem('obs_todo_displayMode', displayMode);
            }
        }

        function loadDisplayMode(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/displayMode').once('value').then(snap => {
                    const storedMode = snap.val();
                    if (storedMode) {
                        displayMode = storedMode;
                        document.getElementById(`mode-${displayMode}`).checked = true;
                        updateModeDescription();
                    }
                    if (callback) callback();
                });
            } else {
                const storedMode = localStorage.getItem('obs_todo_displayMode');
                if (storedMode) {
                    displayMode = storedMode;
                    document.getElementById(`mode-${displayMode}`).checked = true;
                    updateModeDescription();
                }
                if (callback) callback();
            }
        }

        // Keyword management functions
        function showKeywordManagement() {
            keywordManagement.classList.add('visible');
            renderKeywordManager();
        }

        function hideKeywordManagement() {
            keywordManagement.classList.remove('visible');
            editingKeywordIndex = null;
        }

        function renderKeywordManager() {
            keywordListManager.innerHTML = '';
            
            keywords.forEach((keyword, index) => {
                const keywordItem = document.createElement('div');
                keywordItem.className = 'keyword-item';
                
                if (editingKeywordIndex === index) {
                    keywordItem.innerHTML = `
                        <input type="text" value="${escapeHtml(keyword)}" id="edit-keyword-${index}">
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="saveKeywordEdit(${index})">✓</button>
                            <button class="keyword-item-btn" onclick="cancelKeywordEdit()">✗</button>
                        </div>
                    `;
                } else {
                    keywordItem.innerHTML = `
                        <span>${escapeHtml(keyword)}</span>
                        <div class="keyword-item-actions">
                            <button class="keyword-item-btn" onclick="startEditingKeyword(${index})">✏️</button>
                            <button class="keyword-item-btn" onclick="removeKeyword(${index})">🗑️</button>
                        </div>
                    `;
                }
                
                keywordListManager.appendChild(keywordItem);
            });
        }

        function startEditingKeyword(index) {
            editingKeywordIndex = index;
            renderKeywordManager();
            
            setTimeout(() => {
                const input = document.getElementById(`edit-keyword-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 10);
        }

        function saveKeywordEdit(index) {
            const input = document.getElementById(`edit-keyword-${index}`);
            if (input) {
                const newKeyword = input.value.trim();
                if (newKeyword) {
                    const oldKeyword = keywords[index];
                    keywords[index] = newKeyword;
                    
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.keywords && task.keywords.includes(oldKeyword)) {
                            const keywordIndex = task.keywords.indexOf(oldKeyword);
                            task.keywords[keywordIndex] = newKeyword;
                            
                            if (useFirebase && !isGuest) {
                                dbRef.child(taskId).update({ keywords: task.keywords });
                            }
                        }
                    });
                    
                    saveKeywords();
                    saveAllTasks();
                    editingKeywordIndex = null;
                    renderKeywordManager();
                    renderTasks();
                }
            }
        }

        function cancelKeywordEdit() {
            editingKeywordIndex = null;
            renderKeywordManager();
        }

        function removeKeyword(index) {
            const keywordToRemove = keywords[index];
            
            // OBS FIX: Removed the confirm() check because OBS blocks popups
            keywords.splice(index, 1);
            
            Object.keys(tasks).forEach(taskId => {
                const task = tasks[taskId];
                if (task.keywords && task.keywords.includes(keywordToRemove)) {
                    const keywordIndex = task.keywords.indexOf(keywordToRemove);
                    task.keywords.splice(keywordIndex, 1);
                    
                    if (useFirebase && !isGuest) {
                        dbRef.child(taskId).update({ keywords: task.keywords });
                    }
                }
            });
            
            saveKeywords();
            saveAllTasks();
            renderKeywordManager();
            renderTasks();
        }

        // Toggle task details visibility
        function toggleTaskDetails(taskId) {
            expandedTasks[taskId] = !expandedTasks[taskId];
            
            // [NEW] Logic to manage timers on toggle
            if (expandedTasks[taskId]) {
                startTaskTimer(taskId); // Start countdown immediately
            } else {
                clearTaskTimer(taskId); // Clean up if closed manually
            }
            
            renderTasks();
        }

        
        // Function to update streak data from tasks
        function updateStreakData() {
            streakData = {};
            const allTasks = Object.values(tasks);
            const completedTasks = allTasks.filter(t => t.completed && t.completedAt);
            
            completedTasks.forEach(task => {
                const completionDate = new Date(task.completedAt);
                const dateKey = formatDateKey(completionDate);
                streakData[dateKey] = true;
            });
            
            saveStreakData();
        }
        
        // Format date as YYYY-MM-DD for use as a key
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Save streak data to storage
        function saveStreakData() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/streakData').set(streakData);
            } else {
                localStorage.setItem('obs_todo_streakData', JSON.stringify(streakData));
            }
        }
        
        // Load streak data from storage
        function loadStreakData(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/streakData').once('value').then(snap => {
                    const storedStreakData = snap.val();
                    if (storedStreakData) {
                        streakData = storedStreakData;
                    }
                    if (callback) callback();
                });
            } else {
                const storedStreakData = localStorage.getItem('obs_todo_streakData');
                if (storedStreakData) {
                    streakData = JSON.parse(storedStreakData);
                }
                if (callback) callback();
            }
        }
        
        // Render the streak calendar
        function renderStreakCalendar() {
            const calendarDaysEl = document.getElementById('calendar-days');
            const currentMonthDisplayEl = document.getElementById('current-month-display');
            calculateStreakStats();            
            
            // Clear previous calendar
            calendarDaysEl.innerHTML = '';
            
            // Set current month display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ];
            currentMonthDisplayEl.textContent = `${monthNames[currentCalendarDate.getMonth()]} ${currentCalendarDate.getFullYear()}`;
            
            const firstDay = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), 1);
            const lastDay = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth() + 1, 0);
            
            const firstDayOfWeek = firstDay.getDay();
            
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day empty';
                calendarDaysEl.appendChild(emptyDay);
            }
            

            const today = new Date();
            const todayKey = formatDateKey(today);
            
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day';
                dayEl.textContent = day;
                
                const dateKey = formatDateKey(new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), day));
                
                if (dateKey === todayKey) {
                    dayEl.classList.add('today');
                }
                
                const dayOfWeek = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), day).getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    dayEl.classList.add('weekend');
                }
                
                if (streakData[dateKey]) {
                    dayEl.classList.add('has-streak');
                } else if (frozenStreakDays[dateKey]) { 
                    dayEl.classList.add('has-frozen-streak'); 
                }
                
                calendarDaysEl.appendChild(dayEl);
            }
            
           
        }
        
        // Calculate streak statistics
        function calculateStreakStats() {
            frozenStreakDays = {}; 
            const today = new Date();
            const todayKey = formatDateKey(today);
            
            const streakDates = Object.keys(streakData)
                .map(key => new Date(key))
                .sort((a, b) => a - b);
            
           
            
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayKey = formatDateKey(yesterday);
            
            let currentStreakStartDate = null;
            
            if (streakData[todayKey]) {
                currentStreakStartDate = new Date(today);
            } else if (streakData[yesterdayKey]) {
                currentStreakStartDate = new Date(yesterday);
            } else {
                currentStreakStartDate = null;
            }

            let currentStreak = 0;
            
            if (currentStreakStartDate) {
                currentStreak = 1; 
                let dateToScan = new Date(currentStreakStartDate);
                dateToScan.setDate(dateToScan.getDate() - 1); 
                
                while (true) {
                    const scanKey = formatDateKey(dateToScan);
                    
                    if (streakData[scanKey]) {
                        currentStreak++;
                    } else {
                        const dayBeforeScan = new Date(dateToScan);
                        dayBeforeScan.setDate(dayBeforeScan.getDate() - 1);
                        const dayBeforeScanKey = formatDateKey(dayBeforeScan);
                        
                        if (streakData[dayBeforeScanKey]) {
                            frozenStreakDays[scanKey] = true; 
                            currentStreak++; 
                            dateToScan = new Date(dayBeforeScan); 
                        } else {
                          
                            break;
                        }
                    }
                    
                    dateToScan.setDate(dateToScan.getDate() - 1);

                    if (streakDates.length > 0 && dateToScan < streakDates[0]) {
                        break;
                    }
                    if ((new Date() - dateToScan) > (365 * 5 * 1000 * 60 * 60 * 24)) { // 5 years
                        break;
                    }
                }
            }
            
            
            // ---  Longest Streak Logic ---
            let longestStreak = 0;
            let tempStreak = 0;
            let prevDate = null;
            
            streakDates.forEach(date => {
                const currentDate = new Date(date);
                
                if (prevDate === null) {
                    // First day in the list
                    tempStreak = 1;
                } else {
                    // Check if dates are consecutive or have one day gap
                    const diffTime = currentDate - prevDate;
                    // Calculate difference in days, rounded to nearest whole number
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                    
                    if (diffDays === 1) {
                        // Consecutive day (e.g., Mon -> Tue)
                        tempStreak++;
                    } else if (diffDays === 2) {
                        // One missed day (e.g., Mon -> Wed). Streak continues.
                        const frozenDate = new Date(prevDate);
                        frozenDate.setDate(prevDate.getDate() + 1);
                        const frozenDateKey = formatDateKey(frozenDate);
                        frozenStreakDays[frozenDateKey] = true;
                        
                        tempStreak++;
                    } else {
                        // Two or more missed days (diffDays > 2). Streak resets.
                        longestStreak = Math.max(longestStreak, tempStreak);
                        tempStreak = 1; // Start new streak from 1
                    }
                }
                prevDate = currentDate; 
            });
            
            // Check the last streak after the loop
            longestStreak = Math.max(longestStreak, tempStreak);

            
            // Update streak display (this part is unchanged)
            document.getElementById('streak-current').textContent = `${currentStreak} day${currentStreak !== 1 ? 's' : ''}`;
            document.getElementById('streak-longest').textContent = `${longestStreak} day${longestStreak !== 1 ? 's' : ''}`;
            document.getElementById('streak-total').textContent = `${Object.keys(streakData).length} day${Object.keys(streakData).length !== 1 ? 's' : ''}`;
            
            // Also update the main reporting stats (this part is unchanged)
            document.getElementById('report-current-streak').textContent = currentStreak;
            document.getElementById('report-longest-streak').textContent = longestStreak;
        }
        
        // Navigate to previous month
        function prevMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderStreakCalendar();
        }
        
        // Navigate to next month
        function nextMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderStreakCalendar();
        }

        // Render functions
        function renderTaskElement(taskId, task) {
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item conveyor-task';
            taskItem.dataset.id = taskId;

            // --- NEW: Attach Long Press Listeners ---
            if (!task.completed) {
                // Mouse Events
                taskItem.onmousedown = () => startLongPress(taskId, taskItem);
                taskItem.onmouseup = () => cancelLongPress(taskItem);
                taskItem.onmouseleave = () => cancelLongPress(taskItem);
                
                // Touch Events (Mobile)
                taskItem.ontouchstart = () => startLongPress(taskId, taskItem);
                taskItem.ontouchend = () => cancelLongPress(taskItem);
                taskItem.ontouchcancel = () => cancelLongPress(taskItem);
                
                // Cancel if dragging starts (to prevent conflict)
                taskItem.ondragstart = () => cancelLongPress(taskItem); 
            }

            taskItem.draggable = currentTab === 'active' && displayMode === 'static';
            
            if (task.completed) {
                taskItem.classList.add('completed');
            }

            const isExpanded = expandedTasks[taskId];
            
            // --- Logic for order buttons ---
            let orderControlsHTML = '';
            if (currentTab === 'active') {
                // Get all active tasks, sorted by their current order
                const activeTasks = Object.entries(tasks)
                    .filter(([id, task]) => !task.completed)
                    .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
                
                // Find the index of the current task in the sorted list
                const currentIndex = activeTasks.findIndex(([id]) => id === taskId);
                
                // Determine if it's the first or last task
                const isFirst = currentIndex === 0;
                const isLast = currentIndex === activeTasks.length - 1;

                // Create the HTML for the buttons, disabling them if at the top or bottom
                orderControlsHTML = `
                    <div class="task-order-controls">
                        <button class="order-btn order-up" onclick="moveTask('${taskId}', 'up')" ${isFirst ? 'disabled' : ''}>▲</button>
                        <button class="order-btn order-down" onclick="moveTask('${taskId}', 'down')" ${isLast ? 'disabled' : ''}>▼</button>
                    </div>
                `;
            }

            // Keyword related elements
            const keywordsContainer = document.createElement('div');
            keywordsContainer.className = 'keywords-container';
            keywordsContainer.id = `keywords-${taskId}`;
            
            let assignedKeywordsHTML = '';
            if (task.keywords && task.keywords.length > 0) {
                assignedKeywordsHTML = task.keywords.map(k => `
                    <span class="keyword-tag selected">
                        ${escapeHtml(k)}
                        <button class="keyword-remove" onclick="removeKeywordFromTask('${taskId}', '${escapeHtml(k)}')">&times;</button>
                    </span>
                `).join('');
            }
            
            // Available keywords to add
            let availableKeywordsHTML = '';
            
            // We change the loop to include 'index'
            keywords.forEach((keyword, index) => {
                if (!task.keywords || !task.keywords.includes(keyword)) {
                    // We build a container with all 3 buttons
                    availableKeywordsHTML += `
                        <div class="keyword-tag" style="display:inline-flex; align-items:center; padding: 0; background-color: #4a505c;">
                            
                            <span style="padding: 2px 8px; cursor:pointer;" 
                                  title="Add '${escapeHtml(keyword)}' to task"
                                  onclick="toggleKeyword('${taskId}', '${escapeHtml(keyword)}')">
                                + ${escapeHtml(keyword)}
                            </span>
                            
                            <button class="keyword-item-btn" 
                                    title="Rename '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); startEditingKeyword(${index}); showKeywordManagement();">
                                ✏️
                            </button>
                            
                            <button class="keyword-item-btn" 
                                    title="Remove '${escapeHtml(keyword)}' globally"
                                    style="color: var(--text); padding: 2px 4px; font-size: 0.7rem;" 
                                    onclick="event.stopPropagation(); removeKeyword(${index});">
                                🗑️
                            </button>
                        </div>
                    `;
                }
            });

            // Add new keyword input
            const keywordInputId = `keyword-input-${taskId}`;
            const keywordInputHTML = `
                <div class="keyword-input-container">
                    <input type="text" class="keyword-input" id="${keywordInputId}" placeholder="Add new...">
                    <button class="add-keyword-confirm" onclick="addNewKeyword('${taskId}', '${keywordInputId}')">+</button>
                </div>
            `;
            
            keywordsContainer.innerHTML = assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML;
            
            // Updated to use accurate current display time
            const currentDisplayTime = getCurrentDisplayTime({...task, id: taskId});
            
            // Main task content
            let taskContentHTML;
            if (editingTaskId === taskId) {
                // Editing view
                taskContentHTML = `
                    <div class="task-main-content">
                        ${orderControlsHTML}
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        
                        <input type="text" class="task-input" value="${escapeHtml(task.text)}" 
                            onkeydown="if(event.key === 'Enter') saveTaskEdit('${taskId}'); if(event.key === 'Escape') cancelTaskEdit();">
                        
                        <div class="task-actions">
                            <button class="action-btn" onclick="saveTaskEdit('${taskId}')">✔️</button>
                            <button class="action-btn" onclick="cancelTaskEdit()">❌</button>
                        </div>
                    </div>
                `;
            } else {
                // Normal view logic
                const isTimerRunning = !!timerIntervals[taskId];
                
                
                taskContentHTML = `
                    <div class="task-main-content">
                        ${orderControlsHTML}
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTask('${taskId}')">
                        
                        <div class="task-content">
                            <span class="task-text" 
                                ondblclick="event.stopPropagation(); startEditingTask('${taskId}')" 
                                title="Double-click to edit">
                                ${escapeHtml(task.text)}
                            </span>
                            
                            <div class="task-timer-row">
                                <span class="timer-display-small" id="timer-${taskId}">
                                    ${formatTime(currentDisplayTime)}
                                </span>
                                ${task.completed && task.completedAt ? 
                                    `<span class="completion-date" style="font-size:0.7rem"> • ${formatDate(task.completedAt)}</span>` 
                                    : ''}
                            </div>
                        </div>

                        <button class="right-play-btn ${isTimerRunning ? 'running' : ''}" 
                                id="quick-btn-${taskId}"
                                title="${isTimerRunning ? 'Pause Timer' : 'Start Timer'}"
                                onclick="event.stopPropagation(); ${isTimerRunning ? `pauseTimer('${taskId}')` : `startTimer('${taskId}')`}" 
                                ${task.completed ? 'disabled' : ''}>
                            ${isTimerRunning ? '❚❚' : '▶'}
                        </button>

                        <button class="dropdown-btn ${isExpanded ? 'rotated' : ''}" onclick="toggleTaskDetails('${taskId}')">▼</button>
                    </div>
                    
                    <div class="task-details ${isExpanded ? 'visible' : ''}">
                        <div class="task-details-row">
                            <div class="task-actions">
                                <button class="action-btn" onclick="startEditingTask('${taskId}')">✏️ Edit</button>
                                <button class="action-btn" onclick="stopTimer('${taskId}')" ${task.completed ? 'disabled' : ''}>■ Pause </button>
                                <button class="action-btn" onclick="removeTask('${taskId}')">🗑️ Delete</button>
                            </div>
                        </div>
                        <div class="keywords-container ${isExpanded ? 'visible' : ''}">
                            ${assignedKeywordsHTML + availableKeywordsHTML + keywordInputHTML}
                        </div>
                    </div>
                `;
            }
            
            taskItem.innerHTML = taskContentHTML;
            
            // Add drag events only in static mode
            if (currentTab === 'active' && displayMode === 'static') {
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragenter', handleDragEnter);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('dragleave', handleDragLeave);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
            }

            if (expandedTasks[taskId]) {
                // If mouse enters or keys are typed, STOP the timer
                taskItem.addEventListener('mouseenter', () => clearTaskTimer(taskId));
                taskItem.addEventListener('focusin', () => clearTaskTimer(taskId));
                
                // If mouse leaves, RESTART the 4s timer
                taskItem.addEventListener('mouseleave', () => startTaskTimer(taskId));
                
                // If keyboard focus leaves, RESTART the timer
                taskItem.addEventListener('focusout', (e) => {
                    if (!taskItem.contains(e.relatedTarget)) {
                        startTaskTimer(taskId);
                    }
                });
            }

            return taskItem;
        }
        

        function renderTasks() {
            taskListEl.innerHTML = '';
            
            const taskEntries = Object.entries(tasks);
            
            // Filter tasks based on the current tab
            const filteredTasks = taskEntries.filter(([id, task]) => {
                if (currentTab === 'active') {
                    return !task.completed;
                } else {
                    // This is the 'completed' tab logic
                    if (!task.completed || !task.completedAt) return false;
                    
                    const now = new Date();
                    const cutoffDate = new Date(now);
                    // Set cutoffDate to 'completedDaysRange' days ago
                    cutoffDate.setDate(now.getDate() - completedDaysRange);
                    cutoffDate.setHours(0, 0, 0, 0); // Start of that day
                    
                    const completedDate = new Date(task.completedAt);
                    
                    // Show tasks completed on or after the cutoff date
                    return completedDate >= cutoffDate;
                }
            });

            // Sort tasks
            if (currentTab === 'active') {
                // Sort by 'order' property
                filteredTasks.sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
            } else {
                // Sort completed tasks by completion time, newest first
                filteredTasks.sort(([, a], [, b]) => new Date(b.completedAt) - new Date(a.completedAt));
            }
            
            if (filteredTasks.length === 0) {
                const message = currentTab === 'active' ? 'No active tasks. Add one below!' : 'No tasks completed today.';
                taskListEl.innerHTML = `<li class="empty-state">${message}</li>`;
            } else {
                filteredTasks.forEach(([id, task]) => {
                    const taskItem = renderTaskElement(id, task);
                    taskListEl.appendChild(taskItem);
                });
            }
            
            updateStats();
            updateTimeStats();
            timestampEl.textContent = `Updated: ${new Date().toLocaleString()}`;
            
            // Initialize conveyor if needed
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            }
        }
        
        // --- Reporting Function ---
        function renderReports() {
            // Show guest message if in guest mode
            if (isGuest) {
                guestReportingMessage.style.display = 'block';
                authenticatedReportingContent.style.display = 'none';
                return;
            } else {
                guestReportingMessage.style.display = 'none';
                authenticatedReportingContent.style.display = 'block';
            }
            
            // Update streak data from current tasks
            updateStreakData();
            
            // Render the streak calendar
            renderStreakCalendar();
            
            const allTasks = Object.values(tasks);
            const completedTasks = allTasks.filter(t => t.completed && t.completedAt);
            
            // --- 1. Calculate Stats ---
            
            // Total Completed
            const totalCompleted = completedTasks.length;
            document.getElementById('report-total-completed').textContent = totalCompleted;

            // Total Hours
            const totalSeconds = calculateLifetimeTotal();
            const totalHours = (totalSeconds / 3600).toFixed(1);
            document.getElementById('report-total-hours').textContent = totalHours;

            // Streak Calculations (already done in calculateStreakStats)
            
            loadRewardData();
            
            
            // --- 2. Calculate Cumulative Data for Line Charts ---
            const dataByDay = {};
            
            // Sort completed tasks by date, oldest first
            const sortedCompletedTasks = completedTasks.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
            
            // Aggregate data by day
            sortedCompletedTasks.forEach(task => {
                const dateKey = formatDateKey(new Date(task.completedAt));
                if (!dataByDay[dateKey]) {
                    dataByDay[dateKey] = { tasks: 0, time: 0 };
                }
                dataByDay[dateKey].tasks += 1;
                dataByDay[dateKey].time += (task.timeSpent || 0);
            });

            // Get sorted list of all dates from the data
            const sortedDates = Object.keys(dataByDay).sort();
            
            const chartLabels = [];
            const cumulativeTasksData = [];
            const cumulativeTimeData = [];
            
            let cumulativeTasks = 0;
            let cumulativeTime = 0;

            // Create cumulative data points
            sortedDates.forEach(dateKey => {
                cumulativeTasks += dataByDay[dateKey].tasks;
                cumulativeTime += dataByDay[dateKey].time;
                
                chartLabels.push(dateKey);
                cumulativeTasksData.push(cumulativeTasks);
                cumulativeTimeData.push((cumulativeTime / 3600).toFixed(2)); // Convert to hours
            });

            // --- 3. Render Cumulative Tasks Chart ---
            const ctxCumulativeTasks = document.getElementById('cumulative-tasks-chart').getContext('2d');
            if (cumulativeTasksChart) {
                cumulativeTasksChart.destroy();
            }
            cumulativeTasksChart = new Chart(ctxCumulativeTasks, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Total Tasks Completed',
                        data: cumulativeTasksData,
                        backgroundColor: 'rgba(162, 155, 254, 0.2)',
                        borderColor: 'var(--primary-light)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#dfe6e9' }, // FIXED: Hardcoded color
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED: Hardcoded color
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } } // FIXED: Legend text
                    }
                }
            });

            // --- 4. Render Cumulative Time Chart ---
            const ctxCumulativeTime = document.getElementById('cumulative-time-chart').getContext('2d');
            if (cumulativeTimeChart) {
                cumulativeTimeChart.destroy();
            }
            cumulativeTimeChart = new Chart(ctxCumulativeTime, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Total Time Spent (Hours)',
                        data: cumulativeTimeData,
                        backgroundColor: 'rgba(0, 184, 148, 0.2)',
                        borderColor: 'var(--secondary)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: '#dfe6e9', // FIXED
                                callback: (val) => val + 'h' 
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } }, // FIXED
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' hours';
                                }
                            }
                        }
                    }
                }
            });

            // --- 5. Time Spent Per Keyword Chart (UPDATED) ---
            const timePerKeyword = {};
            completedTasks.forEach(task => {
                const time = task.timeSpent || 0;
                if (time > 0) {
                    if (task.keywords && task.keywords.length > 0) {
                        task.keywords.forEach(kw => {
                            timePerKeyword[kw] = (timePerKeyword[kw] || 0) + time;
                        });
                    } else {
                        timePerKeyword['Uncategorized'] = (timePerKeyword['Uncategorized'] || 0) + time;
                    }
                }
            });

            const pieLabels = Object.keys(timePerKeyword);
            const pieData = Object.values(timePerKeyword).map(time => (time / 60).toFixed(2)); 
            
            // Pie chart background colors
            const pieColors = [
                '#6c5ce7', '#a29bfe', '#00b894', '#fd79a8', '#fdcb6e', '#e17055',
                '#0984e3', '#00cec9', '#fab1a0', '#ffeaa7'
            ];
            const backgroundColors = pieLabels.map((_, i) => pieColors[i % pieColors.length]);

            const ctxKeywords = document.getElementById('time-per-keyword-chart').getContext('2d');
            if (timePerKeywordChart) {
                timePerKeywordChart.destroy();
            }
            
            timePerKeywordChart = new Chart(ctxKeywords, {
                type: 'doughnut', // Changed to 'doughnut' for a more modern look (optional, change back to 'pie' if you prefer)
                data: {
                    labels: pieLabels,
                    datasets: [{
                        label: 'Time Spent (in minutes)',
                        data: pieData,
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(0,0,0,0.5)', // Dark border to blend with background
                        borderWidth: 2,
                        hoverOffset: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allows it to fit the container height
                    layout: {
                        padding: 20
                    },
                    plugins: {
                        legend: {
                            position: 'right', // Moves indicators to the right side (Vertical List)
                            align: 'center',   // Centers them vertically
                            labels: {
                                color: 'rgb(223, 230, 233)', // var(--text)
                                padding: 20,      // Adds spacing between rows
                                boxWidth: 15,     // Makes the color boxes smaller and neater
                                font: {
                                    size: 12,
                                    family: "'Segoe UI', sans-serif"
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed + ' minutes';
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            updateDailyProgressChart()
            renderWeeklyProgress();
        }




        // --- Daily Progress Chart Function ---
        function updateDailyProgressChart() {
            // Get filter values from radio buttons
            const metric = document.querySelector('input[name="daily-progress-metric"]:checked').value;
            const rangeValue = document.querySelector('input[name="daily-progress-range"]:checked').value;

            // --- 1. Aggregate Data by Day ---
            const dataByDay = {};
            const allCompletedTasks = Object.values(tasks)
                .filter(t => t.completed && t.completedAt);

            allCompletedTasks.forEach(task => {
                const dateKey = formatDateKey(new Date(task.completedAt));
                if (!dataByDay[dateKey]) {
                    dataByDay[dateKey] = { tasks: 0, time: 0 };
                }
                dataByDay[dateKey].tasks += 1;
                dataByDay[dateKey].time += (task.timeSpent || 0);
            });

            // --- 2. Determine Date Range and Labels ---
            const chartLabels = [];
            const chartData = [];
            const today = new Date();
            let startDate;

            if (rangeValue === 'lifetime') {
                // Find the earliest date in the data
                const sortedDates = Object.keys(dataByDay).sort();
                if (sortedDates.length === 0) {
                    // No data, show empty chart for today
                    startDate = new Date(today);
                } else {
                    startDate = new Date(sortedDates[0]);
                }
            } else {
                startDate = new Date(today);
                startDate.setDate(today.getDate() - parseInt(rangeValue) + 1);
            }

            // Set time to beginning of the day for accurate comparison
            startDate.setHours(0, 0, 0, 0);

            // --- 3. Populate Chart Data (Looping from Start Date to Today) ---
            let currentDate = new Date(startDate);
            while (currentDate <= today) {
                const dateKey = formatDateKey(currentDate);

                // Format label 
                const label = currentDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                chartLabels.push(label);

                const dayData = dataByDay[dateKey];

                if (dayData) {
                    if (metric === 'time') {
                        chartData.push((dayData.time / 3600).toFixed(2)); // Time in hours
                    } else {
                        chartData.push(dayData.tasks); // Number of tasks
                    }
                } else {
                    // If no data for this day, push 0
                    chartData.push(0);
                }

                // Move to the next day
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // --- 4. Render the Chart ---
            const ctx = document.getElementById('daily-progress-chart').getContext('2d');
            if (dailyProgressChart) {
                dailyProgressChart.destroy();
            }

            const datasetLabel = metric === 'time' ? 'Time Spent (Hours)' : 'Tasks Completed';
            const yAxisLabel = metric === 'time' ? 'h' : '';
            const tooltipLabel = metric === 'time' ? ' hours' : ' tasks';

            dailyProgressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: datasetLabel,
                        data: chartData,
                        backgroundColor: 'rgba(253, 121, 168, 0.2)',
                        borderColor: 'var(--accent)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: '#dfe6e9', // FIXED
                                callback: (val) => val + yAxisLabel
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#dfe6e9' }, // FIXED
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#dfe6e9' } }, // FIXED
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + tooltipLabel;
                                }
                            }
                        }
                    }
                }
            });
        }


        // function for accurate current time display
    function updateTaskDisplay(taskId) {
        const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
        if (taskItem) {
            const task = tasks[taskId];
            
            // Calculate precise time
            let currentTotalSeconds = task.timeSpent || 0;
            if (task.timerStartTime && timerIntervals[taskId]) {
                const elapsed = (Date.now() - task.timerStartTime) / 1000;
                currentTotalSeconds += elapsed;
            }
            
            // 1. Update the Time Text
            const timerEl = taskItem.querySelector(`#timer-${taskId}`);
            if (timerEl) {
                // Check if we are active to avoid unnecessary DOM writes
                if (timerEl.textContent !== formatTime(currentTotalSeconds)) {
                    timerEl.textContent = formatTime(currentTotalSeconds);
                }
            }
        }
    }
        
        function updateStats() {
            const allTasks = Object.values(tasks);
            // Filter active tasks
            const activeTasks = allTasks.filter(task => !task.completed);
            // Filter completed today
            const completedTasks = allTasks.filter(task => task.completed && isToday(task.completedAt));
            
            const totalIncomplete = activeTasks.length;
            const completedToday = completedTasks.length;
            
            // Calculate percentage
            const totalRelevant = completedToday + totalIncomplete;
            let percent = 0;
            if (totalRelevant > 0) {
                percent = Math.round((completedToday / totalRelevant) * 100);
            }
            
            // Safely update DOM elements
            if (progressFill) progressFill.style.width = `${percent}%`;
            if (progressPercent) progressPercent.textContent = `${percent}%`;
            
            // These checks prevent the crash if the elements are missing from HTML
            if (completedCount) completedCount.textContent = `${completedToday} completed today`;
            if (remainingCount) remainingCount.textContent = `${totalIncomplete} tasks remaining`;
        }
        
        function escapeHtml(str) {
            return (str || '').replace(/[&<>"']/g, match => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[match]));
        }

        // Task operations
        function addTask() {
            const text = inputEl.value.trim();
            if (text) {
                const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `task-${Date.now()}`;
                const activeTasks = Object.values(tasks).filter(t => !t.completed);
                
                const newTask = {
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    order: activeTasks.length,
                    timeSpent: 0,
                    timerStartTime: null,
                    lastUpdated: new Date().toISOString(),
                    keywords: []
                };
                
                if (useFirebase && !isGuest) {
                    dbRef.child(newTaskId).set(newTask);
                } else {
                    tasks[newTaskId] = newTask;
                    saveAllTasks();
                    renderTasks();
                }
                
                inputEl.value = '';
            }
            
            // Prevent default form submission behavior
            return false;
        }

        function toggleTask(taskId) {
            const task = tasks[taskId];
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            
            // 1. Update Data
            task.completed = !task.completed;
            
            if (task.completed) {
                const sound = document.getElementById('completion-sound');
                if (sound) {
                    sound.currentTime = 0; // Reset sound so it plays instantly
                    sound.volume = 0.5;    // Adjust volume (0.1 to 1.0)
                    sound.play().catch(e => console.log("Audio play blocked:", e));
                }

                if (expandedTasks[taskId]) {
                    expandedTasks[taskId] = false;
                    clearTaskTimer(taskId);
                    
                    // Force visual close immediately before animation starts
                    if (taskItem) {
                        const detailsDiv = taskItem.querySelector('.task-details');
                        const dropdownBtn = taskItem.querySelector('.dropdown-btn');
                        if (detailsDiv) detailsDiv.classList.remove('visible');
                        if (dropdownBtn) dropdownBtn.classList.remove('rotated');
                    }
                }
                // ---------------------------------------------

                task.completedAt = new Date().toISOString();
                stopTimer(taskId);
                
                // 2. VISUALS & ANIMATION FLAG
                if (taskItem) {
                    // SET FLAG: This tells the Firebase listener "Don't refresh the list yet!"
                    isAnimatingCompletion = true; 
                    
                    taskItem.classList.add('completed');
                    const checkbox = taskItem.querySelector('.task-checkbox');
                    if (checkbox) checkbox.checked = true;
                    
                    // --- TRIGGER EXISTING ANIMATIONS ---
                    // These functions exist in your code, so we call them directly:
                    triggerRpgLevelUp(taskId);       // Gold Burst + XP Text
                    triggerFireStorm(taskId);        // Fire effect
                    triggerCompletionConfetti(taskId); // Confetti explosion
                }
                
                // 3. Save Data 
                updateStreakData();
                updateTaskInStorage(taskId);
                updateTimeStats();
                
                // 4. Wait 1.6s for animation, THEN refresh
                setTimeout(() => {
                    // CLEAR FLAG: Now the listener is allowed to update the list again
                    isAnimatingCompletion = false;
                    
                    renderTasks();
                    updateStats();
                }, 600); 

            } else {
                // Un-checking: No animation needed, render immediately
                task.completedAt = null;
                if (task.timerStartTime) task.timerStartTime = null;
                
                updateStreakData();
                updateTaskInStorage(taskId);
                renderTasks();
                updateStats();
                updateTimeStats();
            }
        }
                        


        function triggerRpgLevelUp(taskId) {
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (!taskItem) return;

            // 1. Trigger Background Burst
            taskItem.classList.add('rpg-glow-active');
            setTimeout(() => taskItem.classList.remove('rpg-glow-active'), 600);

            // 2. Create Floating XP Text
            const checkbox = taskItem.querySelector('.task-checkbox');
            const rect = checkbox.getBoundingClientRect(); // Get exact position of checkbox

            const floatEl = document.createElement('div');
            floatEl.classList.add('rpg-floating-text');
            floatEl.innerText = "Well done!"; // You can change this text!

            // Position it right on top of the checkbox
            floatEl.style.left = (rect.left + 10) + 'px'; 
            floatEl.style.top = (rect.top - 10) + 'px';

            document.body.appendChild(floatEl);

            // Cleanup element after animation
            setTimeout(() => floatEl.remove(), 1000);
        }

        function triggerFireStorm(taskId) {
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (!taskItem) return;

            // 1. Add Rumble Effect to the row
            taskItem.classList.add('fire-rumble');
            setTimeout(() => taskItem.classList.remove('fire-rumble'), 500);

            // 2. Generate Fire Particles across the whole width
            const particleCount = 40; // Number of flames
            
            for (let i = 0; i < particleCount; i++) {
                const flame = document.createElement('div');
                flame.classList.add('fire-particle');
                
                // Randomize horizontal position (0% to 100% of the row)
                const leftPos = Math.random() * 100;
                flame.style.left = leftPos + '%';
                
                // Randomize flame height (how high it goes) - Negative pixels means Up
                const riseHeight = -1 * (30 + Math.random() * 40) + 'px'; 
                flame.style.setProperty('--rise-height', riseHeight);
                
                // Randomize size slightly
                const scale = 0.5 + Math.random() * 1.5;
                flame.style.transform = `scale(${scale})`;
                
                // Randomize speed (0.5s to 1.2s)
                const duration = 0.5 + Math.random() * 0.7 + 's';
                flame.style.animation = `burnUp ${duration} ease-out forwards`;
                
                // Randomize start time slightly so they don't all pop up at once
                flame.style.animationDelay = (Math.random() * 0.2) + 's';

                taskItem.appendChild(flame);

                // Cleanup
                setTimeout(() => { flame.remove(); }, 1500);
            }
        }


        function triggerCompletionConfetti(taskId) {
            const taskItem = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (!taskItem) return;

            // 1. Flash the row
            taskItem.classList.add('completion-flash');
            setTimeout(() => taskItem.classList.remove('completion-flash'), 500);

            // 2. Find the checkbox to center the explosion
            const checkbox = taskItem.querySelector('.task-checkbox');
            const rect = checkbox.getBoundingClientRect();
            
            // Create 20 particles
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.classList.add('confetti-particle');
                
                // Randomize color (Green, Purple, Pink)
                const colors = ['#00b894', '#6c5ce7', '#fd79a8'];
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Randomize direction (spread)
                // x: -100px to +100px, y: -100px to +100px
                const x = (Math.random() - 0.5) * 200 + 'px';
                const y = (Math.random() - 0.5) * 200 + 'px';
                
                particle.style.setProperty('--x', x);
                particle.style.setProperty('--y', y);
                
                // Set fixed position based on checkbox
                // Note: We use 'fixed' to escape the overflow:hidden of the task list if needed, 
                // but 'absolute' works if the container isn't clipping. 
                // Let's use absolute relative to the body/dashboard for safety.
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = (rect.top + rect.height / 2) + 'px';
                particle.style.position = 'fixed'; 
                
                particle.style.animation = `explode-dist 0.8s ease-out forwards`;
                
                document.body.appendChild(particle);
                
                // Cleanup
                setTimeout(() => { particle.remove(); }, 800);
            }
        }

        // Storage functions
        function updateTaskInStorage(taskId) {
            tasks[taskId].lastUpdated = new Date().toISOString();
            if (useFirebase && !isGuest) {
                dbRef.child(taskId).update(tasks[taskId]);
            } else {
                saveAllTasks();
            }
        }

        function saveAllTasks() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/tasks').set(tasks);
                return;
            }
            if (!useFirebase || isGuest) {
                localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
            }
        }
        // Helper to detect if we really need to re-render the DOM
        function hasStructuralChanges(oldTasks, newTasks) {
            const oldKeys = Object.keys(oldTasks || {});
            const newKeys = Object.keys(newTasks || {});

            // 1. Different number of tasks?
            if (oldKeys.length !== newKeys.length) return true;

            // 2. Check content of each task
            for (let key of newKeys) {
                const oldT = oldTasks[key];
                const newT = newTasks[key];

                // If task didn't exist before
                if (!oldT) return true; 

                // Check properties that affect the VISUAL layout (Order, Text, Completion, Keywords)
                if (oldT.text !== newT.text) return true;
                if (oldT.completed !== newT.completed) return true;
                if (oldT.order !== newT.order) return true;
                
                // Check keywords array comparison
                const oldK = JSON.stringify(oldT.keywords || []);
                const newK = JSON.stringify(newT.keywords || []);
                if (oldK !== newK) return true;
            }

            // If we get here, only 'timeSpent', 'lastUpdated', or 'timerStartTime' changed.
            // These don't require a full DOM destroy/rebuild.
            return false;
        }

        

        function loadTasks() {
            // 1. Logic for Logged In Firebase Users
            if (useFirebase && currentUserId && !isGuest) {
                setupModeListeners(); 

                dbRef = firebase.database().ref('users/' + currentUserId + '/tasks');
                dbRef.on('value', snap => {
                    const newTasks = snap.val() || {};

                    // --- FIX START: SYNC STOPPED TIMERS ---
                    // This block stops local timers if the database says they are paused.
                    // This prevents "Window B" from overwriting the pause you did in "Window A".
                    Object.keys(timerIntervals).forEach(taskId => {
                        const remoteTask = newTasks[taskId];
                        // If task was deleted remotely OR exists but has no timerStartTime (is paused)
                        if (!remoteTask || !remoteTask.timerStartTime) {
                            
                            // 1. Stop the local 10-second save loop
                            if (timerIntervals[taskId] && timerIntervals[taskId].storageInterval) {
                                clearInterval(timerIntervals[taskId].storageInterval);
                            }
                            delete timerIntervals[taskId];

                            // 2. Update the UI button immediately (visual feedback)
                            const btn = document.getElementById(`quick-btn-${taskId}`);
                            if(btn) {
                                btn.classList.remove('running');
                                btn.innerHTML = '▶';
                                btn.title = 'Start Timer';
                                btn.setAttribute('onclick', `event.stopPropagation(); startTimer('${taskId}')`);
                            }
                        }
                    });
                    // --- FIX END ---
                    
                    // If data updates but structure is same (e.g. timer tick), don't re-render
                    if (displayMode !== 'static' && !hasStructuralChanges(tasks, newTasks)) {
                        tasks = newTasks;
                        updateStreakData();
                        updateTimeStats();
                        updateStats();
                        // We must still check restore here, in case a "Start" command came from another window
                        restoreRunningTimers(); 
                        return; 
                    }

                    tasks = newTasks;
                    if (isAnimatingCompletion) {
                        console.log("Animation playing: Skipping listener render");
                        return; 
                    }
                    
                    // Initialization Chain
                    loadStreakData(() => {
                        loadDisplayMode(() => {
                            // FORCE DEFAULT: If new user (no mode saved), set Pinned Top
                            if (!displayMode) {  
                                displayMode = 'rotate-incompleted';
                                // Update UI checkbox
                                const radio = document.getElementById('mode-rotate-incompleted');
                                if(radio) radio.checked = true;
                            }
                            restoreRunningTimers();
                            renderTasks(); // Triggers animation automatically
                            updateStreakData();
                            updateTimeStats();
                            updateStats();
                            refreshAllTimeDisplays();
                        });
                    });
                });

            // 2. Logic for GUEST / LocalStorage Users
            } else {
                const storedTasks = localStorage.getItem('obs_todo_tasks');
                
                if (storedTasks) {
                    tasks = JSON.parse(storedTasks);
                } else {
                    // NEW GUEST: Generate 5 default tasks
                    tasks = generateDefaultTasks();
                    localStorage.setItem('obs_todo_tasks', JSON.stringify(tasks));
                }
                
                // Cleanup old daily tasks for guests
                if (isGuest) {
                    const today = new Date().toDateString();
                    let hasChanges = false;
                    Object.keys(tasks).forEach(taskId => {
                        const task = tasks[taskId];
                        if (task.completed && task.completedAt) {
                            if (new Date(task.completedAt).toDateString() !== today) {
                                delete tasks[taskId];
                                hasChanges = true;
                            }
                        }
                    });
                    if (hasChanges) saveAllTasks();
                }
                
                loadStreakData(() => {
                    loadDisplayMode(() => {
                        // If no mode is saved in LocalStorage (First time visitor), FORCE 'rotate-incompleted'
                        const storedMode = localStorage.getItem('obs_todo_displayMode');
                        
                        if (!storedMode) {
                            displayMode = 'rotate-incompleted';
                            saveDisplayMode(); // Save immediately so it persists
                            
                            // Visually check the correct radio button
                            const radio = document.getElementById('mode-rotate-incompleted');
                            if(radio) radio.checked = true;
                            
                            // Update text description
                            updateModeDescription();
                        }

                        restoreRunningTimers();
                        renderTasks(); 
                        updateStreakData();
                        updateTimeStats();
                        updateStats();
                    });
                });
            }
        }



        // Display Mode Functions - CONVEYOR BELT IMPLEMENTATION
        function handleDisplayModeChange() {
            const selectedMode = document.querySelector('input[name="display-mode"]:checked').value;
            displayMode = selectedMode;
            
            // Save the display mode
            saveDisplayMode();
            
            // Update mode description
            updateModeDescription();
            
            // Stop any existing conveyor and clean up
            stopConveyor();
            
            // Reset conveyor state
            conveyorTasks = [];
            conveyorPosition = 0;
            isConveyorPaused = false;
            
            // Apply the selected mode
            if (displayMode !== 'static' && currentTab === 'active') {
                initConveyor();
            } else {
                // Reset to normal rendering for static mode
                conveyorContainer.classList.remove('conveyor-container');
                conveyorTrack.style.transform = 'translateY(0)';
                renderTasks();
            }

            // Trigger OBS Refresh by changing the URL hash
            triggerObsRefresh(); 
        }

        function updateModeDescription() {
            const descriptionEl = document.getElementById('mode-description');
            let description = '';
            
            switch(displayMode) {
                case 'static':
                    description = 'Current tasks are displayed in a static list.';
                    break;
                case 'bounce':
                    description = 'The list gently bobs up and down. Perfect for short lists (1-3 tasks) to keep the screen alive.';
                    break;
                case 'loop-incompleted':
                    description = 'Incompleted tasks will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'loop-all':
                    description = 'All tasks (including completed today) will continuously move from bottom to top like a conveyor belt.';
                    break;
                case 'rotate-incompleted':
                    description = 'Incompleted tasks (except the top one) will rotate positions periodically.';
                    break;
            }
            
            descriptionEl.textContent = description;
        }

        
        function initConveyor() {
        // 1. Filter tasks (Standard logic)
            conveyorTasks = Object.entries(tasks)
                .filter(([id, task]) => {
                    if (displayMode === 'loop-incompleted' || displayMode === 'rotate-incompleted' || displayMode === 'bounce') {
                        return !task.completed;
                    } else if (displayMode === 'loop-all') {
                        return !task.completed || (task.completed && isToday(task.completedAt));
                    }
                    return false;
                })
                .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

            if (conveyorTasks.length === 0) {
                renderTasks();
                return;
            }
            

            // 2. APPLY SPECIFIC HEIGHTS PER MODE
            const tasksContainer = document.getElementById('tasks-container');
            const conveyorContainer = document.getElementById('conveyor-container');
            const count = conveyorTasks.length;

            if (count < 5) {
                tasksContainer.style.maxHeight = 'none';
                if (conveyorContainer) conveyorContainer.style.minHeight = '0px';

                // --- SEPARATE CONFIGURATION FOR EACH MODE ---
                switch (displayMode) {
                    
                    case 'rotate-incompleted': 
                        // "Pinned Top + Looped" (Needs space for the pinned header)
                        switch (count) {
                            case 4: tasksContainer.style.height = '220px'; break; 
                            case 3: tasksContainer.style.height = '155px'; break;
                            case 2: tasksContainer.style.height = '100px'; break;
                            case 1: tasksContainer.style.height = '55px';  break;
                        }
                        break;

                    case 'loop-incompleted':
                        // "Loop Active" (Standard loop, usually tight)
                        switch (count) {
                            case 4: tasksContainer.style.height = '215px'; break;
                            case 3: tasksContainer.style.height = '120px'; break;
                            case 2: tasksContainer.style.height = '95px'; break;
                            case 1: tasksContainer.style.height = '52px';  break;
                        }
                        break;

                    case 'loop-all':
                        // "Loop All" (Often same as Loop Active, but separated here for you)
                        switch (count) {
                            case 4: tasksContainer.style.height = '215px'; break;
                            case 3: tasksContainer.style.height = '160px'; break;
                            case 2: tasksContainer.style.height = '105px'; break;
                            case 1: tasksContainer.style.height = '52px';  break;
                        }
                        break;

                    case 'bounce':
                        // "Auto-scroll Mode" (Needs slightly more room to visibly bounce)
                        switch (count) {
                            case 4: tasksContainer.style.height = '230px'; break;
                            case 3: tasksContainer.style.height = '175px'; break;
                            case 2: tasksContainer.style.height = '115px'; break;
                            case 1: tasksContainer.style.height = '60px';  break;
                        }
                        break;
                }

            } else {
                // Default for large lists (5+ tasks)
                tasksContainer.style.height = '272px'; 
                tasksContainer.style.maxHeight = '272px';
                if (conveyorContainer) conveyorContainer.style.minHeight = '100px'; 
            }

            // 3. Setup Animation State
            conveyorPosition = 0;
            isConveyorPaused = false;
            bounceDirection = 1; 
            bouncePauseTimer = 0;
            
            conveyorContainer.classList.add('conveyor-container');
            conveyorTrack.style.transform = 'translateY(0)';
            
            renderConveyorTasks();
            if (tasksContainer) {
                tasksContainer.scrollTop = 0;
            }


            startMasterLoop(); 
        }

    function startConveyor() {
        // Deprecated - logic moved to startMasterLoop
        startMasterLoop();
    }

    function stopConveyor() {
        // Stop loop if safe
        if (Object.keys(timerIntervals).length === 0 && pomoState !== 'WORK' && pomoState !== 'BREAK') {
            stopMasterLoop();
        }
        
        const staticContainer = document.getElementById('static-top-task');
        if (staticContainer) {
            staticContainer.remove();
        }
        
        // --- NEW: Reset Height Logic ---
        const tasksContainer = document.getElementById('tasks-container');
        if (tasksContainer) {
            // Clear the inline styles so CSS takes over again
            tasksContainer.style.height = ''; 
            tasksContainer.style.maxHeight = ''; 
        }
        // -------------------------------
        
        // Clean up container
        taskListEl.innerHTML = '';
        conveyorContainer.classList.remove('conveyor-container');
        conveyorTrack.style.transform = 'translateY(0)';
    }


        function renderConveyorTasks() {
            // Find or create the static container for the fixed top task
            const tasksContainer = document.getElementById('tasks-container');
            const staticTaskContainerId = 'static-top-task';
            let staticContainer = document.getElementById(staticTaskContainerId);

            // Clean up static container if we're NOT in rotate-incompleted mode
            if (displayMode !== 'rotate-incompleted' && staticContainer) {
                staticContainer.remove();
                staticContainer = null;
            }

            // 1. Mode: Rotate Incompleted (Static Top + Moving Conveyor)
            if (displayMode === 'rotate-incompleted' && conveyorTasks.length > 0) {
                
                // Ensure the static container exists
                if (!staticContainer) {
                    staticContainer = document.createElement('div');
                    staticContainer.id = staticTaskContainerId;
                    staticContainer.style.marginBottom = '8px'; // Space between static and moving parts
                    // Insert it before the conveyor-container
                    tasksContainer.insertBefore(staticContainer, conveyorContainer);
                }
                
                // Render the static task (first task in the list)
                const [staticTaskId, staticTask] = conveyorTasks[0];
                const staticTaskItem = renderTaskElement(staticTaskId, staticTask);
                
                // Apply visual cue and remove list margin
                staticTaskItem.style.marginBottom = '0';
                staticTaskItem.style.backgroundColor = 'rgba(255,255,255,.12)';
                
                staticContainer.innerHTML = '';
                staticContainer.appendChild(staticTaskItem);
                
                // Render the moving tasks (all subsequent tasks)
                const movingTasks = conveyorTasks.slice(1);
                taskListEl.innerHTML = '';
                
                if (movingTasks.length === 0) {
                    taskListEl.innerHTML = `<li class="empty-state" style="padding-top:0; padding-bottom:10px;">No other tasks to loop.</li>`;
                } else {
                    movingTasks.forEach(([taskId, task]) => {
                        const taskItem = renderTaskElement(taskId, task);
                        taskListEl.appendChild(taskItem);
                    });
                }
                
                // Ensure conveyor mode is active
                conveyorContainer.classList.add('conveyor-container');

            } else {
                // 2. Mode: Other Loops (Full Moving Conveyor) or Static (Render everything in one list)
                
                // Clean up static container if it exists (this is the key fix)
                if (staticContainer) {
                    staticContainer.remove();
                }

                taskListEl.innerHTML = '';
                conveyorContainer.classList.add('conveyor-container');
                
                if (conveyorTasks.length === 0) {
                    taskListEl.innerHTML = `<li class="empty-state">No tasks to display.</li>`;
                    return;
                }
                
                // Render all tasks for the full conveyor loop
                conveyorTasks.forEach(([taskId, task]) => {
                    const taskItem = renderTaskElement(taskId, task);
                    taskListEl.appendChild(taskItem);
                });
            }
        }
        
        function moveConveyor(deltaTime = 16) { 
            if (conveyorTasks.length === 0) return;

            // --- CASE 1: BOUNCE MODE ---
            // This mode relies on manipulating the ScrollBar (scrollTop) directly
            if (displayMode === 'bounce') {
                if (bouncePauseTimer > 0) {
                    bouncePauseTimer -= deltaTime;
                    return; 
                }

                const viewingWindow = document.getElementById('tasks-container');
                const maxScroll = viewingWindow.scrollHeight - viewingWindow.clientHeight;

                // Safety: If content fits perfectly, ensure we sit at top and do nothing
                if (maxScroll <= 0) {
                    viewingWindow.scrollTop = 0;
                    return;
                }

                // Ensure CSS Transform is cleared so it doesn't fight the scrollbar
                conveyorTrack.style.transform = `translateY(0px)`;

                const yoyoSpeed = 30; // px per second
                const movement = (yoyoSpeed * deltaTime) / 1000;

                if (bounceDirection === 1) { // Moving DOWN
                    conveyorPosition += movement;
                    if (conveyorPosition >= maxScroll) {
                        conveyorPosition = maxScroll;
                        bounceDirection = -1; 
                        bouncePauseTimer = 1000; 
                    }
                } else { // Moving UP
                    conveyorPosition -= movement;
                    if (conveyorPosition <= 0) {
                        conveyorPosition = 0;
                        bounceDirection = 1; 
                        bouncePauseTimer = 1000; 
                    }
                }

                viewingWindow.scrollTop = conveyorPosition;
                return; 
            }

            // --- CASE 2: STANDARD LOOP MODES ---
            // These modes rely on CSS Transform. The ScrollBar MUST stay at 0 (Top).
            
            const viewingWindow = document.getElementById('tasks-container');
            if (viewingWindow) {
                // FORCE View to top. This prevents the "empty view" bug if 
                // you were previously scrolled down in Bounce mode.
                viewingWindow.scrollTop = 0;
            }

            conveyorTrack.style.transition = 'none';

            const pixelsPerSecond = conveyorSpeed; 
            const movement = (pixelsPerSecond * deltaTime) / 1000;
            conveyorPosition -= movement; // Moves UP
            
            const firstTask = taskListEl.firstElementChild;
            
            if (firstTask) {
                const taskHeight = firstTask.offsetHeight + 8; // Height + Margin
                
                // If the first task has moved completely out of view (upwards)
                if (Math.abs(conveyorPosition) >= taskHeight) {
                    taskListEl.appendChild(firstTask); // Move it to the bottom
                    conveyorPosition += taskHeight;    // Reset position mathematically
                }
            }

            conveyorTrack.style.transform = `translateY(${conveyorPosition}px)`;
        }




        function handleRotateIncompleted() {
            // For rotate-incompleted mode, we periodically rotate the tasks (except the first one)
            // Check if it's time to rotate (every 5 seconds)
            const now = Date.now();
            if (!window.lastRotateTime) window.lastRotateTime = now;
            
            if (now - window.lastRotateTime > 5000) { // 5 seconds
                window.lastRotateTime = now;
                
                // Get incomplete tasks except the first one
                const incompleteTasks = Object.entries(tasks)
                    .filter(([id, task]) => !task.completed)
                    .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));
                
                if (incompleteTasks.length <= 2) return;
                
                // Keep the first task fixed, rotate the rest
                const fixedTask = incompleteTasks[0];
                const tasksToRotate = incompleteTasks.slice(1);
                
                // Rotate the tasks (move first to end)
                const rotatedTasks = [...tasksToRotate.slice(1), tasksToRotate[0]];
                
                // Update the order
                let order = 1; // Start from 1 because 0 is the fixed task
                rotatedTasks.forEach(([id, task]) => {
                    tasks[id].order = order++;
                });
                
                // Save and re-render
                saveAllTasks();
                renderTasks();
            }
        }

        function pauseConveyor() {
            isConveyorPaused = true;
        }

        function resumeConveyor() {
            isConveyorPaused = false;
        }

        // Initialize display mode on page load
        function initializeDisplayMode() {
            loadDisplayMode(() => {
                // If no stored mode, default to 'rotate-incompleted' (Pinned Top + Looped)
                if (!displayMode) {
                    displayMode = 'rotate-incompleted'; // CHANGED DEFAULT HERE
                    
                    // Update the radio button in UI
                    const radio = document.getElementById('mode-rotate-incompleted');
                    if(radio) radio.checked = true;
                    
                    saveDisplayMode(); 
                }
                
                // Stop any existing conveyor
                stopConveyor();
                
                // Initialize conveyor for the current mode
                if (currentTab === 'active' && displayMode !== 'static') {
                    initConveyor();
                }
                
                updateModeDescription();
            });
        }

        

        // --- Authentication Functions ---
        function showLogin() {
            // Always show the marketing hero on the login page
            const hero = document.getElementById('marketing-hero');
            if (hero) hero.style.display = 'block';

            loginContainer.style.display = 'block';
            dashboardWrapper.style.display = 'none';
            passwordResetContainer.style.display = 'none';
            document.querySelector('.footer').style.display = 'none';
            const footerGuide = document.getElementById('footer-setup-guide');
            if (footerGuide) {
                footerGuide.style.display = 'none';
            }
        }

        function showDashboard() {
            const hero = document.getElementById('marketing-hero');
            
            // Logic for hiding/showing the marketing hero
            if (hero) {
                if (isGuest) {
                    hero.style.display = 'block';
                } else {
                    hero.style.display = 'none';
                }
            }

            loginContainer.style.display = 'none';
            dashboardWrapper.style.display = 'block';
            passwordResetContainer.style.display = 'none';
            logoutBtn.style.display = 'inline-block';
            document.querySelector('.footer').style.display = 'flex';

            const footerGuide = document.getElementById('footer-setup-guide');
            if (footerGuide) {
                if (isGuest) {
                    footerGuide.style.display = 'none'; // Hide for Guests
                } else {
                    footerGuide.style.display = 'inline-block'; // Show for Registered Users
                }
            }

            // Update user status display
            if (isGuest) {
                // --- GUEST MODE ---
                userStatusEl.textContent = "Guest Mode"; 
                userStatusEl.classList.remove('hidden-status');
                userStatusEl.classList.add('visible-status');
                userStatusEl.style.color = "var(--accent)"; 
                toggleUserStatusBtn.style.display = 'none'; 
                
                // Set button to "Sign in" so guests can go log in
                logoutBtn.textContent = "Sign in"; 

            } else {
                // --- LOGGED IN MODE ---
                userStatusEl.textContent = `${currentUser.email}`;
                userStatusEl.classList.add('hidden-status');
                userStatusEl.classList.remove('visible-status');
                userStatusEl.style.color = ""; 
                toggleUserStatusBtn.textContent = '🔒';
                toggleUserStatusBtn.style.display = 'flex'; 
                
                // NEW LINE: Explicitly set button to "Logout"
                logoutBtn.textContent = "Logout";
            }
        }
        // --- Password Reset Functions ---
        function showPasswordReset() {
            loginContainer.style.display = 'none';
            dashboardWrapper.style.display = 'none';
            passwordResetContainer.style.display = 'block';
            resetMessage.textContent = '';
            resetMessage.className = 'reset-message';
        }

        function handlePasswordReset(e) {
            e.preventDefault();
            const email = resetEmail.value.trim();
            
            if (!email) {
                showResetMessage('Please enter your email address.', 'error');
                return;
            }
            
            if (useFirebase) {
                firebase.auth().sendPasswordResetEmail(email)
                    .then(() => {
                        showResetMessage('Password reset email sent! Check your inbox.', 'success');
                        resetEmail.value = '';
                    })
                    .catch((error) => {
                        let errorMessage = 'Error sending password reset email.';
                        if (error.code === 'auth/user-not-found') {
                            errorMessage = 'No account found with this email address.';
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = 'Invalid email address.';
                        }
                        showResetMessage(errorMessage, 'error');
                    });
            } else {
                // Mock password reset for localStorage mode
                showResetMessage('Password reset functionality requires Firebase authentication.', 'error');
            }
        }

        function showResetMessage(message, type) {
            resetMessage.textContent = message;
            resetMessage.className = `reset-message reset-${type}`;
        }

        function handleSignup(e) {
            e.preventDefault();
            const email = signupEmail.value;
            const password = signupPassword.value;
            
            if (useFirebase) {
                firebase.auth().createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        currentUserId = currentUser.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks(); // Load user-specific tasks
                    })
                    .catch((error) => {
                        const errorDiv = document.getElementById('auth-error-msg');
                        if(errorDiv) errorDiv.textContent = 'Signup error: ' + error.message;
                    });
            } else {
                // Mock authentication for localStorage mode
                currentUser = { email: email };
                currentUserId = 'local_user';
                isGuest = false;
                localStorage.setItem('obs_todo_mock_user', email);
                showDashboard();
                loadTasks();
            }
        }

        function handleLogin(e) {
            e.preventDefault();
            const email = loginEmail.value;
            const password = loginPassword.value;
            
            if (useFirebase) {
                firebase.auth().signInWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        currentUserId = currentUser.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks(); // Load user-specific tasks
                    })
                    .catch((error) => {
                        const errorDiv = document.getElementById('auth-error-msg');
                        if(errorDiv) errorDiv.textContent = 'Login error: ' + error.message;
                    });
            } else {
                // Mock authentication for localStorage mode
                currentUser = { email: email };
                currentUserId = 'local_user';
                isGuest = false;
                localStorage.setItem('obs_todo_mock_user', email);
                showDashboard();
                loadTasks();
            }
        }

        function handleGuestLogin() {
            currentUser = { email: 'guest@example.com' };
            currentUserId = 'guest_user';
            isGuest = true;
            showDashboard();
            loadTasks();
        }

        function handleLogout() {
            // If it's a real user, sign them out
            if (useFirebase && currentUser && !isGuest) {
                firebase.auth().signOut();
            }

            listenersInitialized = false;
            
            currentUser = null;
            currentUserId = null;
            isGuest = false;
            
            // Clear mock user but NOT the tasks (so guest tasks remain in cache)
            localStorage.removeItem('obs_todo_mock_user');
            
            // Show the login screen explicitly
            showLogin();
            
            // Clear form fields
            if(signupEmail) signupEmail.value = '';
            if(signupPassword) signupPassword.value = '';
            if(loginEmail) loginEmail.value = '';
            if(loginPassword) loginPassword.value = '';
        }

        function initializeAuth() {
            // Determine if we should check Firebase or localStorage
            if (useFirebase) {
                firebase.auth().onAuthStateChanged((user) => {
                    if (user) {
                        // User is logged in
                        currentUser = user;
                        currentUserId = user.uid;
                        isGuest = false;
                        showDashboard();
                        loadTasks();
                        loadKeywords(); 
                    } else {
                        // User is NOT logged in -> AUTO GUEST MODE
                        handleGuestLogin();
                    }
                });
            } else {
                // LocalStorage mode check
                const mockUser = localStorage.getItem('obs_todo_mock_user');
                if (mockUser) {
                    currentUser = { email: mockUser };
                    currentUserId = 'local_user';
                    isGuest = false;
                    showDashboard();
                    loadTasks();
                    loadKeywords();
                } else {
                    // No mock user -> AUTO GUEST MODE
                    handleGuestLogin();
                }
            }
            
            // Ensure Pomodoro UI is set correctly on load based on HTML default
            handleTimerModeChange();
        }

        // --- Generate Insights Function ---
        function generateInsights() {
            const insightsBtn = document.getElementById('generate-insights-btn');
            const loadingDiv = document.getElementById('insights-loading');
            const resultDiv = document.getElementById('insights-result');
            
            // Show loading state
            insightsBtn.disabled = true;
            loadingDiv.style.display = 'block';
            resultDiv.innerHTML = '';
            
            try {
                // Initialize Firebase Functions
                const functions = firebase.functions();
                
                // Reference our function
                const callGenerateInsights = functions.httpsCallable('generateInsights');
                
                // Prepare completed tasks data
                const completedTasks = Object.values(tasks)
                    .filter(task => task.completed && task.completedAt)
                    .map(task => ({
                        text: task.text,
                        completedAt: task.completedAt,
                        timeSpent: task.timeSpent || 0,
                        keywords: task.keywords || []
                    }));
                
                // Prepare stats data
                const stats = {
                    currentStreak: document.getElementById('report-current-streak').textContent,
                    longestStreak: document.getElementById('report-longest-streak').textContent,
                    totalCompleted: document.getElementById('report-total-completed').textContent,
                    totalHours: document.getElementById('report-total-hours').textContent
                };
                
                // Call the function
                callGenerateInsights({ 
                    allCompletedTasks: completedTasks, 
                    stats: stats 
                })
                .then((result) => {
                    // Display the insights with basic formatting
                    resultDiv.innerHTML = marked.parse(result.data.insights);
                })
                .catch((error) => {
                    console.error('Error calling generateInsights:', error);
                    resultDiv.innerHTML = 'Error generating insights: ' + error.message;
                })
                .finally(() => {
                    // Hide loading state
                    insightsBtn.disabled = false;
                    loadingDiv.style.display = 'none';
                });
                
            } catch (error) {
                console.error('Error setting up insights generation:', error);
                resultDiv.innerHTML = 'Error setting up insights generation: ' + error.message;
                insightsBtn.disabled = false;
                loadingDiv.style.display = 'none';
            }
        }

        // --- Minimal Mode Functions ---
        function toggleMinimalMode() {
            const selectedMode = document.querySelector('input[name="minimal-mode"]:checked').value;
            minimalMode = selectedMode === 'minimal';
            
            // Save the minimal mode state
            saveMinimalMode();
            
            // Apply minimal mode
            applyMinimalMode();
        }

        function saveMinimalMode() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/minimalMode').set(minimalMode);
            } else {
                localStorage.setItem('obs_todo_minimalMode', minimalMode);
            }
        }

        function loadMinimalMode(callback) {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/minimalMode').once('value').then(snap => {
                    const storedMode = snap.val();
                    if (storedMode !== null) {
                        minimalMode = storedMode;
                        // Update the radio button
                        document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`).checked = true;
                        applyMinimalMode();
                    }
                    if (callback) callback();
                });
            } else {
                const storedMode = localStorage.getItem('obs_todo_minimalMode');
                if (storedMode !== null) {
                    minimalMode = storedMode === 'true';
                    // Update the radio button
                    document.getElementById(`mode-${minimalMode ? 'minimal' : 'normal'}`).checked = true;
                    applyMinimalMode();
                }
                if (callback) callback();
            }
        }

        function applyMinimalMode() {
            if (minimalMode) {
                document.body.classList.add('minimal-mode');
            } else {
                document.body.classList.remove('minimal-mode');
            }
            
            // Trigger OBS Refresh by changing the URL hash
            triggerObsRefresh();
        }




        /* --- REWARD SYSTEM LOGIC --- */

        let rewardData = {
            startHours: 0,         // The total lifetime hours when the user STARTED this 1000h journey
            isActive: true,
            reward1: "",
            reward2: "",
            history: []            // Array to store completed runs
        };

        // 1. Load Reward Data
        function loadRewardData() {
            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/rewards').once('value').then(snap => {
                    const data = snap.val();
                    if (data) {
                        rewardData = data;
                        updateRewardUI();
                    } else {
                        // First time setup: Set startHours to current total lifetime hours
                        // so they start from 0 progress on the bar.
                        initNewRewardJourney(); 
                    }
                });
            } else {
                const stored = localStorage.getItem('obs_todo_rewards');
                if (stored) {
                    rewardData = JSON.parse(stored);
                    updateRewardUI();
                } else {
                    initNewRewardJourney();
                }
            }
        }

        function initNewRewardJourney() {
            const currentTotalSeconds = calculateLifetimeTotal();
            const currentTotalHours = currentTotalSeconds / 3600;
            
            // OLD LOGIC: rewardData.startHours = currentTotalHours; 
            // This made it start at 0% regardless of your past work.
            
            // NEW LOGIC: Snap to the most recent 1000-hour milestone.
            // Example: If you have 450 hours, this calculates 0. Progress = 450/1000.
            // Example: If you have 1200 hours, this calculates 1000. Progress = 200/1000.
            rewardData.startHours = Math.floor(currentTotalHours / 1000) * 1000;
            
            rewardData.isActive = true;
            
            // Only reset texts if they are undefined, otherwise keep them
            if (typeof rewardData.reward1 === 'undefined') rewardData.reward1 = "";
            if (typeof rewardData.reward2 === 'undefined') rewardData.reward2 = "";
            
            if (!rewardData.history) rewardData.history = [];
            
            saveRewardData();
            updateRewardUI();
        }
        // 2. Save Reward Data
        function saveRewardData() {
            // Grab inputs if available
            const r1 = document.getElementById('reward-input-1');
            const r2 = document.getElementById('reward-input-2');
            
            if (r1 && r2) {
                rewardData.reward1 = r1.value;
                rewardData.reward2 = r2.value;
            }

            if (useFirebase && currentUserId && !isGuest) {
                firebase.database().ref('users/' + currentUserId + '/rewards').set(rewardData);
            } else {
                localStorage.setItem('obs_todo_rewards', JSON.stringify(rewardData));
            }
        }

        // 3. Update the UI (Bar, Inputs, Win State)
       /* --- REWARD SYSTEM LOGIC --- */

        // 1. Update the UI (Bar, Inputs, Win State, Texts)
        function updateRewardUI() {
            // Fill inputs
            const r1 = document.getElementById('reward-input-1');
            const r2 = document.getElementById('reward-input-2');
            if (r1 && r1.value === "") r1.value = rewardData.reward1 || "";
            if (r2 && r2.value === "") r2.value = rewardData.reward2 || "";

            // 1. Get Absolute Total Hours
            const lifetimeSeconds = calculateLifetimeTotal();
            const currentTotalHours = lifetimeSeconds / 3600;

            // 2. Determine "Level" (0-1000 = Level 1, 1000-2000 = Level 2)
            const currentLoopIndex = Math.floor(currentTotalHours / 1000); 
            const currentTierStart = currentLoopIndex * 1000;
            const currentTierEnd = currentTierStart + 1000;

            // 3. Calculate Progress for the Bar (0% to 100%)
            let progressInCurrentTier = currentTotalHours - currentTierStart;
            let percentage = (progressInCurrentTier / 1000) * 100;
            if (percentage > 100) percentage = 100;

            // 4. Update Bar & Text
            const bar = document.getElementById('reward-progress-bar');
            const textEl = document.getElementById('reward-progress-text');
            const titleEl = document.getElementById('reward-quest-title');
            
            if (bar) bar.style.width = `${percentage}%`;
            
            // UPDATED TEXT: Shows "1,250 / 2,000 Hours" instead of "250 / 1000"
            if (textEl) {
                textEl.textContent = `${currentTotalHours.toFixed(1)} / ${currentTierEnd} Hours`;
            }
            
            // Update Title to show Level
            if (titleEl) {
                titleEl.textContent = `Current Quest: Level ${currentLoopIndex + 1} (${currentTierStart}h - ${currentTierEnd}h)`;
            }

            // 5. Handle "Collection" Button Visibility
            const collectionBtn = document.getElementById('toggle-collection-btn');
            if (collectionBtn) {
                if (rewardData.history && rewardData.history.length > 0) {
                    collectionBtn.style.display = 'block';
                } else {
                    collectionBtn.style.display = 'none';
                }
            }

            // 6. Win Condition Logic
            const activeDiv = document.getElementById('reward-active-state');
            const winDiv = document.getElementById('reward-win-state');

            // How many rewards have we claimed in the past?
            const rewardsClaimed = rewardData.history ? rewardData.history.length : 0;

            // If our current Level Index is higher than the number of rewards we've claimed,
            // it means we finished a 1000h block and haven't clicked the button yet.
            if (currentLoopIndex > rewardsClaimed) {
                // --- WIN STATE ---
                if (activeDiv) activeDiv.style.display = 'none';
                if (winDiv) {
                    winDiv.style.display = 'block';
                    document.getElementById('won-rewards-text').textContent = 
                        `${rewardData.reward1 || 'Reward 1'} & ${rewardData.reward2 || 'Reward 2'}`;
                }
            } else {
                // --- ACTIVE STATE ---
                if (activeDiv) activeDiv.style.display = 'block';
                if (winDiv) winDiv.style.display = 'none';
            }
        }

        // 2. Reset / Claim Reward (Triggered by Button Click)
        function resetRewardJourney(event) {
            // A. Trigger Confetti immediately at button location
            if (event) {
                const rect = event.target.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                triggerRewardConfetti(centerX, centerY);
            } else {
                // Fallback to center screen
                triggerRewardConfetti(window.innerWidth/2, window.innerHeight/2);
            }

            // B. Save to History
            if (!rewardData.history) rewardData.history = [];
            rewardData.history.push({
                date: new Date().toISOString(),
                reward1: rewardData.reward1,
                reward2: rewardData.reward2
            });
            
            // C. Clear inputs for the NEW journey
            rewardData.reward1 = "";
            rewardData.reward2 = "";
            
            saveRewardData();
            
            // D. Force UI Update
            // This will see that (currentLoopIndex == rewardsClaimed) and switch back to Active State
            // The "Start" number will naturally now be 1000, 2000, etc via the updateRewardUI math.
            updateRewardUI();
            
            // E. Open the collection tab automatically to show the new badge
            const collectionSection = document.getElementById('reward-collection-section');
            if (collectionSection) {
                collectionSection.style.display = 'block'; // Show it
                renderCollection(); // Refresh list
            }
        }

        // 3. Toggle Collection Visibility
        function toggleCollection() {
            const section = document.getElementById('reward-collection-section');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                renderCollection();
            } else {
                section.style.display = 'none';
            }
        }

        // 4. Render Collection
        function renderCollection() {
            const grid = document.getElementById('collection-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            if (rewardData.history && rewardData.history.length > 0) {
                // Reverse order so newest is first
                [...rewardData.history].reverse().forEach((item, index) => {
                    // Calculate which level this was (History length - index)
                    const levelNum = rewardData.history.length - index;
                    
                    const div = document.createElement('div');
                    div.className = 'collected-item';
                    div.title = `Level ${levelNum} Complete\n${new Date(item.date).toLocaleDateString()}\nRewards: ${item.reward1}, ${item.reward2}`;
                    
                    // Image
                    div.innerHTML = `<img src="img/gift.png">`;
                    
                    grid.appendChild(div);
                });
            }
        }

        // 7. Fun "Poke" Animation
        function pokeCharacter() {
            const charImg = document.getElementById('active-character-img');
            if (charImg) {
                charImg.style.transform = "scale(0.9) rotate(-10deg)";
                setTimeout(() => {
                    charImg.style.transform = "";
                }, 150);
            }
        }

        // 8. Massive Confetti for Reward
        function triggerRewardConfetti(x, y) {
            const colors = ['#fdcb6e', '#ffeaa7', '#fab1a0', '#ffffff', '#00b894'];
            
            for (let i = 0; i < 100; i++) {
                const p = document.createElement('div');
                p.className = 'confetti-particle';
                p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                p.style.width = (Math.random() * 8 + 4) + 'px';
                p.style.height = p.style.width;
                
                // Random explosion direction
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 200 + 50;
                
                const tx = Math.cos(angle) * velocity + 'px';
                const ty = Math.sin(angle) * velocity + 'px';
                
                p.style.setProperty('--x', tx);
                p.style.setProperty('--y', ty);
                
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                p.style.position = 'fixed';
                
                p.style.animation = `explode-dist 1s ease-out forwards`;
                
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 1000);
            }
        }
















        // Event listeners
        addBtn.addEventListener('click', function(e) {
            e.preventDefault(); // Prevent any default behavior
            addTask();
        });
        inputEl.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Add this line to prevent form submission
                addTask();
            }
        });
        toggleUserStatusBtn.addEventListener('click', toggleUserStatus);

       // --- Tab switching logic ---
        // --- Tab switching logic ---
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                const selectedTab = tab.dataset.tab;
                editingTaskId = null; // Cancel editing when switching tabs

                // Hide button and message by default
                loadMoreBtn.style.display = 'none';
                noMoreTasksMsg.style.display = 'none';

                if (selectedTab === 'active' || selectedTab === 'completed') {
                    // Show tasks, hide reporting
                    taskContentWrapper.style.display = 'block';
                    reportingContentWrapper.style.display = 'none';
                    
                    // Set the task list tab
                    currentTab = selectedTab;
                    
                    // --- NEW: Toggle between Active Adder and Offline Logger ---
                    if (currentTab === 'completed') {
                        // Show Offline Logger, Hide Active Adder
                        document.getElementById('active-task-form').style.display = 'none';
                        document.getElementById('completed-task-form').style.display = 'flex';
                        updateOfflineKeywordDropdown(); // Refresh keywords in the dropdown

                        // ORIGINAL LOGIC: logic for 'completed' tab
                        completedDaysRange = 1; 
                        stopConveyor();
                        
                        // ORIGINAL LOGIC: Check if we should show the "Load More" button
                        const cutoffDate = new Date();
                        cutoffDate.setHours(0, 0, 0, 0); // Start of today
                        const hasMoreTasks = Object.values(tasks).some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            const completedDate = new Date(task.completedAt);
                            return completedDate < cutoffDate; // Any task completed *before* today
                        });
                        
                        // ORIGINAL LOGIC: Show the button if tasks older than today exist
                        if (hasMoreTasks) {
                            loadMoreBtn.style.display = 'block';
                        }
                        
                    } else {
                        // It's the 'active' tab: Show Active Adder, Hide Offline Logger
                        document.getElementById('active-task-form').style.display = 'flex';
                        document.getElementById('completed-task-form').style.display = 'none';

                        // ORIGINAL LOGIC: if displayMode isn't static
                        if (displayMode !== 'static') {
                            initConveyor();
                        }
                    }
                    
                    renderTasks();
                    
                } else if (selectedTab === 'reporting') {
                    // ORIGINAL LOGIC: Hide tasks, show reporting
                    taskContentWrapper.style.display = 'none';
                    reportingContentWrapper.style.display = 'block';
                    
                    // ORIGINAL LOGIC: Stop conveyor
                    stopConveyor();
                    
                    // ORIGINAL LOGIC: Render the reports
                    renderReports();
                }
            });
        });

        function loadMoreCompletedTasks() {
            // Add 30 more days to the range
            completedDaysRange += 30;
            
            // Re-render the task list
            renderTasks();
            
            // Check if there are any tasks *older* than our new range
            const now = new Date();
            const cutoffDate = new Date(now);
            cutoffDate.setDate(now.getDate() - completedDaysRange);
            cutoffDate.setHours(0, 0, 0, 0);

            const hasMoreTasks = Object.values(tasks).some(task => {
                if (!task.completed || !task.completedAt) return false;
                const completedDate = new Date(task.completedAt);
                return completedDate < cutoffDate; // Is there *any* task before the new cutoff?
            });

            // If no more tasks are found, hide the button and show the message
            if (!hasMoreTasks) {
                loadMoreBtn.style.display = 'none';
                noMoreTasksMsg.style.display = 'block';
            }
        }

        loadMoreBtn.addEventListener('click', loadMoreCompletedTasks);
        // --- END OF NEW CODE BLOCK ---

        // Keyword management listeners

       // --- Safe Event Listeners ---
        // --- Safe Event Listeners for Keywords ---

        // Handle all Manage Keywords buttons (found in both Active and Completed tabs)
        const globalKeywordButtons = document.querySelectorAll('.global-manage-btn');
        globalKeywordButtons.forEach(btn => {
            btn.addEventListener('click', showKeywordManagement);
        });

        if (closeKeywordManagement) {
            closeKeywordManagement.addEventListener('click', hideKeywordManagement);
        }

        if (addNewKeywordBtn) {
            addNewKeywordBtn.addEventListener('click', () => {
                const newKeyword = newKeywordInput.value.trim();
                if (newKeyword && !keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveKeywords();
                    renderKeywordManager();
                    renderTasks(); 
                    newKeywordInput.value = '';
                    
                    // Sync the offline logger dropdown immediately if user is on Completed tab
                    if (currentTab === 'completed') {
                        updateOfflineKeywordDropdown();
                    }
                }
            });
        }


        const containerEl = document.getElementById('tasks-container');
        
        // Display mode listeners
        document.addEventListener('DOMContentLoaded', function() {
            const modeRadios = document.querySelectorAll('input[name="display-mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', handleDisplayModeChange);
            });
            
            // Initialize mode description (will be updated by initializeDisplayMode)
            updateModeDescription();
        });

        // --- UPDATED: Pausing Logic ---

        // 1. When mouse ENTERS the big box -> Pause indefinitely
        containerEl.addEventListener('mouseenter', () => {
            if (displayMode !== 'static') {
                pauseConveyor();
                containerEl.classList.add('is-paused'); // Triggers CSS animation
            }
        });

        // 2. When mouse LEAVES the big box -> Resume
        containerEl.addEventListener('mouseleave', () => {
            if (displayMode !== 'static') {
                resumeConveyor();
                containerEl.classList.remove('is-paused'); // Removes CSS animation
            }
        });

        // --- Authentication Event Listeners ---
        signupForm.addEventListener('submit', handleSignup);
        loginForm.addEventListener('submit', handleLogin);
        guestBtn.addEventListener('click', handleGuestLogin);
        logoutBtn.addEventListener('click', handleLogout);
        
        // --- Password Reset Event Listeners ---
        forgotPasswordLink.addEventListener('click', showPasswordReset);
        passwordResetForm.addEventListener('submit', handlePasswordReset);
        backToLoginBtn.addEventListener('click', showLogin);
        
        // --- Streak Calendar Event Listeners ---
        prevMonthBtn.addEventListener('click', prevMonth);
        nextMonthBtn.addEventListener('click', nextMonth);

        // --- Event listener for generate insights button ---
        document.addEventListener('DOMContentLoaded', function() {
            const generateInsightsBtn = document.getElementById('generate-insights-btn');
            if (generateInsightsBtn) {
                generateInsightsBtn.addEventListener('click', generateInsights);
            }
            
        });

        // --- Minimal Mode Event Listeners ---
        document.addEventListener('DOMContentLoaded', function() {
            const minimalModeRadios = document.querySelectorAll('input[name="minimal-mode"]');
            minimalModeRadios.forEach(radio => {
                radio.addEventListener('change', toggleMinimalMode);
            });
            
            // Load minimal mode state
            loadMinimalMode();
        });

        // --- Event listeners for Daily Progress Chart filters ---
        document.addEventListener('DOMContentLoaded', () => {
            const progressFilters = document.querySelectorAll('input[name="daily-progress-metric"], input[name="daily-progress-range"]');
            progressFilters.forEach(radio => {
                radio.addEventListener('change', () => {
                    // Only update if the reporting tab is active
                    if (document.querySelector('.tab[data-tab="reporting"]').classList.contains('active')) {
                        updateDailyProgressChart();
                    }
                });
            });
        });

        // Save data when the user closes the window or refreshes
        window.addEventListener('beforeunload', () => {
            // Loop through all running timers and save them
            Object.keys(timerIntervals).forEach(taskId => {
                if (tasks[taskId]) {
                    // Ensure the latest time is captured
                    updateTaskInStorage(taskId);
                }
            });
        });
            

        
        

        function updateOfflineKeywordDropdown() {
            const dropdown = document.getElementById('offline-task-keyword');
            const currentVal = dropdown.value;
            dropdown.innerHTML = '<option value="">No Keyword</option>';
            
            // Uses the global 'keywords' array from your app
            keywords.forEach(kw => {
                const option = document.createElement('option');
                option.value = kw;
                option.textContent = kw;
                dropdown.appendChild(option);
            });
            dropdown.value = currentVal;
        }


        function renderWeeklyProgress() {
            const tbody = document.getElementById('weekly-progress-body');
            if (!tbody) return;
            tbody.innerHTML = '';

            const allTasks = Object.values(tasks);
            // Filter only completed tasks with a valid date
            const completedTasks = allTasks.filter(t => t.completed && t.completedAt);

            // 1. Group Data by Week
            const weeksData = {};

            completedTasks.forEach(task => {
                const date = new Date(task.completedAt);
                
                // Calculate "Week Start" (Monday)
                const day = date.getDay();
                const diff = date.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
                const monday = new Date(date.setDate(diff));
                monday.setHours(0, 0, 0, 0);
                
                // Create a Key string for sorting/grouping (e.g., "Jan 12, 2025")
                const weekKey = monday.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                const sortKey = monday.getTime(); // Timestamp for easy sorting later

                if (!weeksData[sortKey]) {
                    weeksData[sortKey] = {
                        label: weekKey,
                        totalSeconds: 0,
                        keywords: {}
                    };
                }

                // Accumulate Time
                const duration = task.timeSpent || 0;
                weeksData[sortKey].totalSeconds += duration;

                // Accumulate Keyword Stats (Weighted by time spent)
                if (task.keywords && task.keywords.length > 0) {
                    task.keywords.forEach(kw => {
                        weeksData[sortKey].keywords[kw] = (weeksData[sortKey].keywords[kw] || 0) + duration;
                    });
                } else {
                    weeksData[sortKey].keywords['Uncategorized'] = (weeksData[sortKey].keywords['Uncategorized'] || 0) + duration;
                }
            });

            // 2. Sort Weeks (Newest First)
            const sortedWeekKeys = Object.keys(weeksData).sort((a, b) => b - a);

            if (sortedWeekKeys.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" style="text-align:center; padding: 20px; color: var(--primary-light);">No data available yet.</td></tr>';
                return;
            }

            // 3. Render Rows
            sortedWeekKeys.forEach(key => {
                const week = weeksData[key];
                
                // Convert seconds to hours formatted
                const hours = (week.totalSeconds / 3600).toFixed(1);

                // Sort Keywords by time spent for this week to find top 3
                const sortedKeywords = Object.entries(week.keywords)
                    .sort(([, timeA], [, timeB]) => timeB - timeA)
                    .slice(0, 3) // Top 3
                    .map(([kw]) => kw);

                // Create Keyword HTML
                let keywordHTML = '';
                if (sortedKeywords.length > 0) {
                    keywordHTML = sortedKeywords.map(kw => `<span class="table-keyword-pill">${escapeHtml(kw)}</span>`).join('');
                } else {
                    keywordHTML = '<span style="opacity:0.5; font-size:0.8rem;">—</span>';
                }

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${week.label}</td>
                    <td style="color: var(--secondary); font-weight:bold;">${hours}h</td>
                    <td>${keywordHTML}</td>
                `;
                tbody.appendChild(tr);
            });
}














        function addOfflineTask() {
            const text = document.getElementById('offline-task-text').value.trim();
            const mins = parseInt(document.getElementById('offline-task-mins').value) || 0;
            const keyword = document.getElementById('offline-task-keyword').value;

            if (!text) return;

            // Use current ID generation logic
            const newTaskId = useFirebase && !isGuest ? dbRef.push().key : `offline-${Date.now()}`;
            
            const newTask = {
                text: text,
                completed: true,
                completedAt: new Date().toISOString(),
                createdAt: new Date().toISOString(),
                order: 0,
                timeSpent: mins * 60, // Store as seconds
                timerStartTime: null,
                lastUpdated: new Date().toISOString(),
                keywords: keyword ? [keyword] : []
            };

            if (useFirebase && !isGuest) {
                dbRef.child(newTaskId).set(newTask).then(() => {
                    refreshAllTimeDisplays(); // Trigger after firebase update
                });

            } else {
                tasks[newTaskId] = newTask;
                saveAllTasks();
                renderTasks();
                refreshAllTimeDisplays();
            }
            // --- REFRESH UI STATS ---
            updateTimeStats();
            updateStats();
            updateStreakData();

            // Reset fields
            document.getElementById('offline-task-text').value = '';
            document.getElementById('offline-task-mins').value = '';
            updateStreakData();
        }
        function refreshAllTimeDisplays() {
            // Recalculate the math
            const dailySeconds = calculateDailyTotal();
            const lifetimeSeconds = calculateLifetimeTotal();
            const totalHours = (lifetimeSeconds / 3600).toFixed(1);

            // Update the DOM elements
            if (dailyTotalEl) dailyTotalEl.textContent = formatTime(dailySeconds);
            if (totalHoursEl) totalHoursEl.textContent = `${totalHours} hours`;
            if (reportTotalHoursEl) reportTotalHoursEl.textContent = totalHours;
            
            // Update the Progress bar (since it relies on completed vs remaining)
            updateStats();
        }

        // Initial load
        initializeAuth(); // Initialize authentication instead of directly loading tasks
    </script>
</body>
</html>
